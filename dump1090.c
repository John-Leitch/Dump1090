/**
 * \file    dump1090.c
 * \ingroup Main
 * \brief   Dump1090, a Mode-S messages decoder for RTLSDR devices.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <math.h>
#include <malloc.h>
#include <signal.h>
#include <fcntl.h>
#include <ctype.h>
#include <limits.h>
#include <assert.h>
#include <sys/stat.h>
#include <io.h>
#include <conio.h>
#include <process.h>


#include "misc.h"
#include "trace.h"
#include "sdrplay.h"
#define __lassert(cond) 

 /**
  * \addtogroup Main      Main decoder
  * \addtogroup Misc      Support functions
  * \addtogroup Mongoose  Web server
  *
  * \mainpage Dump1090
  *
  * # Introduction
  *
  * A simple ADS-B (**Automatic Dependent Surveillance - Broadcast**) receiver, decoder and web-server. <br>
  * It requires a *RTLSDR* USB-stick and a USB-driver installed using the *Automatic Driver Installer*
  * [**Zadig**](https://zadig.akeo.ie/).
  *
  * The code for Osmocom's [**librtlsdr**](https://osmocom.org/projects/rtl-sdr/wiki) is built into this program.
  * Hence no dependency on *RTLSDR.DLL*.
  *
  * This *Mode S* decoder is based on the Dump1090 by *Salvatore Sanfilippo*.
  *
  * ### Basic block-diagram:
  * \image html dump1090-blocks.png
  *
  * ### Example Web-client page:
  * \image html dump1090-web.png
  *
  * ### More here later ...
  *
  * Copyright (C) 2012 by Salvatore Sanfilippo <antirez@gmail.com>
  *
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
  * met:
  * ```
  *  *  Redistributions of source code must retain the above copyright
  *     notice, this list of conditions and the following disclaimer.
  *
  *  *  Redistributions in binary form must reproduce the above copyright
  *     notice, this list of conditions and the following disclaimer in the
  *     documentation and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * ```
  */



global_data Modes;


const uint16_t magnitude_lut[129 * 129] =
{
    0,360,720,1080,1440,1800,2160,2520,2880,3240,3600,3960,4320,4680,5040,5400,5760,6120,6480,6840,7200,7560,7920,8280,8640,9000,9360,9720,10080,10440,10800,11160,11520,11880,12240,12600,12960,13320,13680,14040,14400,14760,15120,15480,15840,16200,16560,16920,17280,17640,18000,18360,18720,19080,19440,19800,20160,20520,20880,21240,21600,21960,22320,22680,23040,23400,23760,24120,24480,24840,25200,25560,25920,26280,26640,27000,27360,27720,28080,28440,28800,29160,29520,29880,30240,30600,30960,31320,31680,32040,32400,32760,33120,33480,33840,34200,34560,34920,35280,35640,36000,36360,36720,37080,37440,37800,38160,38520,38880,39240,39600,39960,40320,40680,41040,41400,41760,42120,42480,42840,43200,43560,43920,44280,44640,45000,45360,45720,46080,360,509,805,1138,1484,1836,2190,2546,2902,3260,3618,3976,4335,4694,5053,5412,5771,6131,6490,6849,7209,7569,7928,8288,8647,9007,9367,9727,10086,10446,10806,11166,11526,11885,12245,12605,12965,13325,13685,14045,14404,14764,15124,15484,15844,16204,16564,16924,17284,17644,18004,18364,18723,19083,19443,19803,20163,20523,20883,21243,21603,21963,22323,22683,23043,23403,23763,24123,24483,24843,25203,25563,25922,26282,26642,27002,27362,27722,28082,28442,28802,29162,29522,29882,30242,30602,30962,31322,31682,32042,32402,32762,33122,33482,33842,34202,34562,34922,35282,35642,36002,36362,36722,37082,37442,37802,38162,38522,38882,39242,39602,39962,40322,40682,41042,41402,41762,42122,42482,42842,43201,43561,43921,44281,44641,45001,45361,45721,46081,720,805,1018,1298,1610,1939,2277,2621,2969,3319,3671,4025,4380,4735,5091,5448,5805,6162,6520,6878,7236,7594,7953,8311,8670,9029,9388,9747,10106,10465,10824,11183,11542,11902,12261,12621,12980,13339,13699,14058,14418,14778,15137,15497,15856,16216,16576,16935,17295,17655,18014,18374,18734,19094,19453,19813,20173,20533,20892,21252,21612,21972,22332,22691,23051,23411,23771,24131,24491,24850,25210,25570,25930,26290,26650,27010,27369,27729,28089,28449,28809,29169,29529,29889,30249,30608,30968,31328,31688,32048,32408,32768,33128,33488,33848,34208,34567,34927,35287,35647,36007,36367,36727,37087,37447,37807,38167,38527,38887,39247,39607,39966,40326,40686,41046,41406,41766,42126,42486,42846,43206,43566,43926,44286,44646,45006,45366,45726,46086,1080,1138,1298,1527,1800,2099,2415,2742,3076,3415,3759,4105,4453,4803,5154,5507,5860,6215,6569,6925,7281,7637,7993,8350,8707,9065,9422,9780,10138,10496,10854,11212,11571,11929,12288,12646,13005,13364,13723,14081,14440,14799,15159,15518,15877,16236,16595,16954,17314,17673,18032,18392,18751,19111,19470,19829,20189,20548,20908,21267,21627,21987,22346,22706,23065,23425,23785,24144,24504,24863,25223,25583,25942,26302,26662,27022,27381,27741,28101,28460,28820,29180,29540,29900,30259,30619,30979,31339,31698,32058,32418,32778,33138,33497,33857,34217,34577,34937,35297,35656,36016,36376,36736,37096,37456,37815,38175,38535,38895,39255,39615,39975,40334,40694,41054,41414,41774,42134,42494,42854,43213,43573,43933,44293,44653,45013,45373,45733,46093,1440,1484,1610,1800,2036,2305,2596,2902,3220,3546,3877,4214,4554,4897,5242,5589,5937,6287,6638,6990,7343,7696,8050,8404,8759,9114,9470,9826,10182,10539,10896,11253,11610,11967,12324,12682,13040,13398,13756,14114,14472,14830,15188,15547,15905,16264,16622,16981,17340,17699,18058,18416,18775,19134,19493,19852,20211,20570,20930,21289,21648,22007,22366,22726,23085,23444,23804,24163,24522,24882,25241,25601,25960,26319,26679,27038,27398,27757,28117,28476,28836,29196,29555,29915,30274,30634,30993,31353,31713,32072,32432,32792,33151,33511,33871,34230,34590,34950,35309,35669,36029,36389,36748,37108,37468,37827,38187,38547,38907,39266,39626,39986,40346,40705,41065,41425,41785,42145,42504,42864,43224,43584,43944,44303,44663,45023,45383,45743,46102,1800,1836,1939,2099,2305,2546,2812,3097,3396,3706,4025,4350,4680,5014,5352,5692,6035,6379,6725,7073,7422,7771,8122,8473,8826,9178,9532,9885,10239,10594,10949,11304,11660,12016,12372,12728,13084,13441,13798,14155,14512,14869,15227,15584,15942,16300,16658,17015,17373,17732,18090,18448,18806,19165,19523,19882,20240,20599,20957,21316,21675,22034,22392,22751,23110,23469,23828,24187,24546,24905,25264,25623,25982,26342,26701,27060,27419,27778,28138,28497,28856,29216,29575,29934,30294,30653,31012,31372,31731,32091,32450,32809,33169,33528,33888,34247,34607,34966,35326,35685,36045,36405,36764,37124,37483,37843,38202,38562,38922,39281,39641,40001,40360,40720,41079,41439,41799,42158,42518,42878,43237,43597,43957,44317,44676,45036,45396,45755,46115,2160,2190,2277,2415,2596,2812,3055,3319,3600,3894,4198,4511,4830,5154,5483,5816,6152,6490,6831,7173,7517,7863,8209,8557,8906,9256,9606,9957,10309,10661,11014,11367,11721,12075,12429,12784,13139,13494,13849,14205,14561,14917,15274,15630,15987,16343,16700,17057,17414,17772,18129,18487,18844,19202,19560,19917,20275,20633,20991,21350,21708,22066,22424,22783,23141,23499,23858,24217,24575,24934,25292,25651,26010,26369,26727,27086,27445,27804,28163,28522,28881,29240,29599,29958,30317,30676,31035,31394,31754,32113,32472,32831,33190,33550,33909,34268,34627,34987,35346,35705,36065,36424,36783,37143,37502,37862,38221,38581,38940,39299,39659,40018,40378,40737,41097,41456,41816,42175,42535,42894,43254,43614,43973,44333,44692,45052,45411,45771,46131,2520,2546,2621,2742,2902,3097,3319,3564,3827,4105,4394,4694,5001,5315,5635,5959,6287,6619,6953,7289,7628,7969,8311,8655,9000,9346,9693,10041,10390,10740,11090,11441,11792,12144,12497,12850,13203,13556,13910,14264,14619,14974,15329,15684,16039,16395,16751,17107,17463,17819,18176,18532,18889,19246,19603,19960,20317,20674,21032,21389,21747,22104,22462,22820,23177,23535,23893,24251,24609,24967,25326,25684,26042,26401,26759,27117,27476,27834,28193,28551,28910,29269,29627,29986,30345,30704,31062,31421,31780,32139,32498,32857,33216,33575,33934,34293,34652,35011,35370,35729,36088,36447,36806,37166,37525,37884,38243,38602,38962,39321,39680,40039,40399,40758,41117,41477,41836,42195,42555,42914,43273,43633,43992,44352,44711,45071,45430,45789,46149,2880,2902,2969,3076,3220,3396,3600,3827,4073,4335,4610,4897,5192,5495,5805,6120,6440,6764,7091,7422,7755,8090,8427,8767,9107,9450,9793,10138,10483,10830,11177,11526,11875,12224,12574,12925,13276,13628,13980,14332,14685,15038,15392,15746,16100,16454,16809,17163,17518,17874,18229,18585,18940,19296,19652,20008,20365,20721,21078,21434,21791,22148,22505,22862,23219,23577,23934,24291,24649,25006,25364,25722,26080,26437,26795,27153,27511,27869,28227,28585,28944,29302,29660,30018,30377,30735,31094,31452,31811,32169,32528,32886,33245,33604,33962,34321,34680,35039,35397,35756,36115,36474,36833,37192,37551,37910,38269,38628,38987,39346,39705,40064,40423,40782,41141,41500,41859,42218,42578,42937,43296,43655,44014,44374,44733,45092,45451,45811,46170,3240,3260,3319,3415,3546,3706,3894,4105,4335,4582,4843,5117,5400,5692,5992,6297,6609,6925,7245,7569,7895,8225,8557,8891,9228,9565,9905,10246,10588,10931,11276,11621,11967,12314,12662,13010,13359,13708,14058,14409,14760,15111,15463,15815,16168,16521,16874,17227,17581,17935,18289,18644,18998,19353,19708,20063,20419,20774,21130,21486,21842,22198,22554,22910,23267,23623,23980,24337,24693,25050,25407,25765,26122,26479,26836,27194,27551,27909,28266,28624,28982,29339,29697,30055,30413,30771,31129,31487,31845,32203,32562,32920,33278,33636,33995,34353,34712,35070,35428,35787,36146,36504,36863,37221,37580,37939,38297,38656,39015,39374,39732,40091,40450,40809,41168,41527,41886,42244,42603,42962,43321,43680,44039,44398,44757,45116,45476,45835,46194,3600,3618,3671,3759,3877,4025,4198,4394,4610,4843,5091,5352,5623,5904,6194,6490,6792,7100,7413,7730,8050,8373,8700,9029,9360,9693,10028,10365,10704,11043,11384,11726,12069,12413,12758,13104,13451,13798,14146,14494,14843,15193,15543,15893,16244,16595,16947,17299,17651,18004,18356,18710,19063,19417,19771,20125,20479,20833,21188,21543,21898,22253,22608,22964,23320,23675,24031,24387,24743,25100,25456,25812,26169,26525,26882,27239,27596,27953,28310,28667,29024,29381,29739,30096,30454,30811,31169,31526,31884,32242,32599,32957,33315,33673,34031,34389,34747,35105,35463,35821,36180,36538,36896,37254,37613,37971,38329,38688,39046,39405,39763,40122,40480,40839,41198,41556,41915,42274,42632,42991,43350,43709,44067,44426,44785,45144,45503,45862,46220,3960,3976,4025,4105,4214,4350,4511,4694,4897,5117,5352,5600,5860,6131,6410,6696,6990,7289,7594,7904,8217,8534,8855,9178,9504,9833,10163,10496,10830,11166,11503,11842,12182,12523,12865,13208,13552,13896,14242,14588,14935,15282,15630,15978,16327,16677,17027,17377,17728,18079,18430,18782,19134,19487,19839,20192,20545,20899,21252,21606,21960,22314,22669,23023,23378,23733,24088,24443,24798,25154,25509,25865,26221,26577,26933,27289,27645,28001,28358,28714,29071,29428,29784,30141,30498,30855,31212,31569,31927,32284,32641,32998,33356,33713,34071,34428,34786,35144,35502,35859,36217,36575,36933,37291,37649,38007,38365,38723,39081,39439,39798,40156,40514,40872,41231,41589,41947,42306,42664,43023,43381,43740,44098,44457,44815,45174,45533,45891,46250,4320,4335,4380,4453,4554,4680,4830,5001,5192,5400,5623,5860,6109,6369,6638,6915,7200,7491,7788,8090,8397,8707,9022,9339,9660,9983,10309,10637,10967,11298,11632,11967,12303,12641,12980,13320,13661,14003,14346,14690,15034,15379,15725,16071,16419,16766,17114,17463,17812,18161,18511,18861,19212,19563,19914,20266,20618,20970,21322,21675,22028,22381,22734,23088,23442,23795,24150,24504,24858,25213,25568,25922,26278,26633,26988,27343,27699,28055,28410,28766,29122,29478,29834,30191,30547,30903,31260,31617,31973,32330,32687,33044,33401,33758,34115,34472,34829,35186,35544,35901,36258,36616,36973,37331,37688,38046,38404,38761,39119,39477,39835,40193,40551,40909,41267,41625,41983,42341,42699,43057,43415,43774,44132,44490,44849,45207,45565,45924,46282,4680,4694,4735,4803,4897,5014,5154,5315,5495,5692,5904,6131,6369,6619,6878,7146,7422,7704,7993,8288,8587,8891,9199,9511,9826,10144,10465,10788,11113,11441,11770,12102,12434,12769,13104,13441,13779,14118,14458,14799,15141,15484,15828,16172,16517,16862,17209,17555,17903,18250,18598,18947,19296,19646,19995,20346,20696,21047,21398,21749,22101,22453,22805,23158,23511,23863,24217,24570,24923,25277,25631,25985,26339,26693,27048,27403,27757,28112,28467,28822,29178,29533,29889,30244,30600,30956,31312,31668,32024,32380,32736,33093,33449,33806,34162,34519,34875,35232,35589,35946,36303,36660,37017,37374,37731,38089,38446,38803,39161,39518,39876,40233,40591,40948,41306,41664,42021,42379,42737,43095,43453,43811,44169,44527,44885,45243,45601,45959,46317,5040,5053,5091,5154,5242,5352,5483,5635,5805,5992,6194,6410,6638,6878,7128,7387,7654,7928,8209,8496,8789,9086,9388,9693,10003,10315,10631,10949,11270,11593,11918,12245,12574,12905,13237,13571,13906,14242,14579,14917,15257,15597,15938,16280,16622,16966,17310,17655,18000,18346,18692,19039,19387,19734,20083,20431,20780,21130,21480,21830,22180,22531,22882,23233,23585,23937,24289,24641,24993,25346,25699,26052,26405,26759,27113,27466,27820,28174,28529,28883,29238,29592,29947,30302,30657,31012,31368,31723,32078,32434,32790,33145,33501,33857,34213,34569,34926,35282,35638,35995,36351,36708,37064,37421,37778,38135,38491,38848,39205,39562,39919,40277,40634,40991,41348,41706,42063,42420,42778,43135,43493,43851,44208,44566,44924,45281,45639,45997,46355,5400,5412,5448,5507,5589,5692,5816,5959,6120,6297,6490,6696,6915,7146,7387,7637,7895,8162,8435,8715,9000,9291,9586,9885,10189,10496,10806,11119,11435,11754,12075,12398,12723,13050,13378,13708,14040,14373,14707,15043,15379,15717,16055,16395,16735,17076,17418,17761,18104,18448,18793,19138,19483,19829,20176,20523,20871,21219,21567,21916,22265,22614,22964,23314,23664,24015,24366,24717,25069,25420,25772,26124,26477,26829,27182,27535,27888,28241,28595,28948,29302,29656,30010,30364,30718,31073,31427,31782,32137,32492,32847,33202,33557,33913,34268,34624,34979,35335,35691,36047,36403,36759,37115,37471,37827,38184,38540,38897,39253,39610,39966,40323,40680,41037,41394,41751,42108,42465,42822,43179,43536,43893,44251,44608,44965,45323,45680,46038,46395,5760,5771,5805,5860,5937,6035,6152,6287,6440,6609,6792,6990,7200,7422,7654,7895,8146,8404,8670,8942,9220,9504,9793,10086,10384,10685,10990,11298,11610,11924,12240,12559,12880,13203,13528,13854,14182,14512,14843,15176,15509,15844,16180,16517,16855,17194,17533,17874,18215,18557,18899,19242,19586,19930,20275,20621,20967,21313,21660,22007,22355,22703,23051,23400,23749,24098,24448,24798,25149,25499,25850,26201,26552,26904,27256,27608,27960,28312,28665,29017,29370,29723,30077,30430,30784,31137,31491,31845,32199,32554,32908,33263,33617,33972,34327,34682,35037,35392,35747,36102,36458,36813,37169,37525,37880,38236,38592,38948,39304,39660,40017,40373,40729,41086,41442,41799,42155,42512,42869,43225,43582,43939,44296,44653,45010,45367,45724,46081,46439,6120,6131,6162,6215,6287,6379,6490,6619,6764,6925,7100,7289,7491,7704,7928,8162,8404,8655,8913,9178,9450,9727,10009,10296,10588,10884,11183,11486,11792,12102,12413,12728,13045,13364,13685,14008,14332,14659,14987,15316,15647,15978,16312,16646,16981,17317,17655,17993,18332,18671,19012,19353,19695,20037,20381,20724,21068,21413,21758,22104,22450,22797,23144,23491,23839,24187,24536,24884,25233,25583,25932,26282,26633,26983,27334,27685,28036,28388,28739,29091,29443,29795,30148,30500,30853,31206,31559,31912,32266,32619,32973,33327,33681,34035,34389,34743,35098,35452,35807,36162,36516,36871,37227,37582,37937,38292,38648,39003,39359,39714,40070,40426,40782,41138,41494,41850,42206,42562,42919,43275,43631,43988,44344,44701,45058,45414,45771,46128,46485,6480,6490,6520,6569,6638,6725,6831,6953,7091,7245,7413,7594,7788,7993,8209,8435,8670,8913,9164,9422,9687,9957,10233,10514,10800,11090,11384,11682,11983,12288,12595,12905,13217,13532,13849,14169,14490,14813,15137,15463,15791,16120,16450,16782,17114,17448,17783,18118,18455,18793,19131,19470,19810,20150,20492,20833,21176,21519,21862,22206,22551,22896,23242,23588,23934,24281,24628,24975,25323,25671,26020,26369,26718,27067,27417,27767,28117,28467,28818,29169,29520,29871,30223,30575,30926,31279,31631,31983,32336,32689,33042,33395,33748,34101,34455,34808,35162,35516,35870,36224,36579,36933,37287,37642,37997,38351,38706,39061,39416,39771,40127,40482,40837,41193,41548,41904,42260,42616,42971,43327,43683,44039,44395,44752,45108,45464,45821,46177,46533,6840,6849,6878,6925,6990,7073,7173,7289,7422,7569,7730,7904,8090,8288,8496,8715,8942,9178,9422,9673,9931,10195,10465,10740,11020,11304,11593,11885,12182,12481,12784,13089,13398,13708,14022,14337,14654,14974,15295,15618,15942,16268,16595,16924,17254,17585,17917,18250,18585,18920,19256,19593,19930,20269,20608,20948,21289,21630,21972,22314,22657,23001,23345,23689,24034,24379,24725,25071,25418,25765,26112,26459,26807,27156,27504,27853,28202,28551,28901,29251,29601,29951,30302,30653,31004,31355,31707,32058,32410,32762,33114,33466,33819,34172,34524,34877,35230,35584,35937,36290,36644,36998,37352,37706,38060,38414,38768,39123,39477,39832,40186,40541,40896,41251,41606,41961,42316,42672,43027,43383,43738,44094,44449,44805,45161,45517,45873,46229,46585,7200,7209,7236,7281,7343,7422,7517,7628,7755,7895,8050,8217,8397,8587,8789,9000,9220,9450,9687,9931,10182,10440,10704,10973,11247,11526,11809,12096,12387,12682,12980,13281,13585,13892,14201,14512,14826,15141,15459,15779,16100,16422,16747,17073,17400,17728,18058,18388,18720,19053,19387,19721,20057,20393,20730,21068,21407,21747,22087,22427,22768,23110,23453,23795,24139,24483,24827,25172,25517,25862,26208,26555,26901,27248,27596,27944,28292,28640,28988,29337,29686,30036,30385,30735,31085,31436,31786,32137,32488,32839,33190,33542,33894,34245,34597,34950,35302,35655,36007,36360,36713,37066,37419,37773,38126,38480,38833,39187,39541,39895,40249,40603,40958,41312,41667,42021,42376,42731,43086,43441,43796,44151,44506,44862,45217,45572,45928,46283,46639,7560,7569,7594,7637,7696,7771,7863,7969,8090,8225,8373,8534,8707,8891,9086,9291,9504,9727,9957,10195,10440,10691,10949,11212,11481,11754,12032,12314,12600,12890,13183,13480,13779,14081,14386,14694,15004,15316,15630,15946,16264,16583,16905,17227,17552,17877,18204,18532,18861,19192,19523,19856,20189,20523,20858,21194,21531,21868,22206,22545,22885,23225,23566,23907,24249,24591,24934,25277,25621,25965,26310,26655,27000,27346,27692,28038,28385,28732,29080,29428,29776,30124,30473,30822,31171,31520,31870,32219,32570,32920,33270,33621,33972,34323,34674,35026,35377,35729,36081,36433,36785,37138,37490,37843,38196,38549,38902,39255,39608,39962,40315,40669,41023,41377,41731,42085,42439,42793,43147,43502,43857,44211,44566,44921,45276,45631,45986,46341,46696,7920,7928,7953,7993,8050,8122,8209,8311,8427,8557,8700,8855,9022,9199,9388,9586,9793,10009,10233,10465,10704,10949,11201,11458,11721,11989,12261,12538,12819,13104,13393,13685,13980,14278,14579,14882,15188,15497,15807,16120,16434,16751,17069,17388,17710,18032,18356,18682,19009,19336,19665,19995,20326,20658,20991,21325,21660,21995,22332,22669,23006,23345,23684,24023,24363,24704,25045,25387,25729,26072,26415,26759,27103,27447,27792,28138,28483,28829,29176,29522,29869,30216,30564,30912,31260,31608,31957,32306,32655,33004,33354,33704,34054,34404,34754,35105,35456,35807,36158,36509,36861,37213,37564,37916,38269,38621,38973,39326,39678,40031,40384,40737,41090,41444,41797,42151,42504,42858,43212,43566,43920,44274,44628,44983,45337,45692,46046,46401,46756,8280,8288,8311,8350,8404,8473,8557,8655,8767,8891,9029,9178,9339,9511,9693,9885,10086,10296,10514,10740,10973,11212,11458,11710,11967,12229,12497,12769,13045,13325,13609,13896,14187,14481,14778,15077,15379,15684,15991,16300,16611,16924,17239,17555,17874,18193,18515,18837,19161,19487,19813,20141,20469,20799,21130,21462,21794,22128,22462,22797,23133,23469,23806,24144,24483,24822,25161,25502,25842,26184,26525,26868,27210,27554,27897,28241,28585,28930,29275,29621,29967,30313,30659,31006,31353,31700,32048,32396,32744,33093,33441,33790,34139,34489,34838,35188,35538,35888,36239,36589,36940,37291,37642,37993,38345,38696,39048,39400,39752,40104,40456,40809,41161,41514,41867,42220,42573,42926,43279,43633,43986,44340,44694,45047,45401,45755,46110,46464,46818,8640,8647,8670,8707,8759,8826,8906,9000,9107,9228,9360,9504,9660,9826,10003,10189,10384,10588,10800,11020,11247,11481,11721,11967,12219,12476,12738,13005,13276,13552,13831,14114,14400,14690,14982,15278,15576,15877,16180,16485,16793,17103,17414,17728,18043,18360,18678,18998,19320,19642,19966,20291,20618,20945,21274,21603,21933,22265,22597,22930,23264,23599,23934,24270,24607,24944,25282,25621,25960,26300,26640,26981,27322,27664,28006,28349,28692,29035,29379,29723,30068,30413,30758,31104,31450,31796,32143,32490,32837,33185,33532,33880,34228,34577,34926,35274,35624,35973,36323,36672,37022,37372,37723,38073,38424,38775,39126,39477,39828,40180,40532,40883,41235,41587,41940,42292,42644,42997,43350,43703,44056,44409,44762,45115,45468,45822,46176,46529,46883,9000,9007,9029,9065,9114,9178,9256,9346,9450,9565,9693,9833,9983,10144,10315,10496,10685,10884,11090,11304,11526,11754,11989,12229,12476,12728,12985,13247,13513,13784,14058,14337,14619,14904,15193,15484,15779,16076,16375,16677,16981,17287,17596,17906,18218,18532,18848,19165,19483,19803,20125,20447,20771,21096,21422,21749,22078,22407,22737,23068,23400,23733,24066,24400,24735,25071,25407,25744,26082,26420,26759,27098,27438,27778,28119,28460,28802,29144,29487,29830,30173,30517,30861,31206,31551,31896,32242,32587,32934,33280,33627,33974,34321,34669,35016,35364,35713,36061,36410,36759,37108,37457,37807,38157,38507,38857,39207,39557,39908,40259,40610,40961,41312,41664,42015,42367,42719,43071,43423,43775,44128,44480,44833,45185,45538,45891,46244,46597,46951,9360,9367,9388,9422,9470,9532,9606,9693,9793,9905,10028,10163,10309,10465,10631,10806,10990,11183,11384,11593,11809,12032,12261,12497,12738,12985,13237,13494,13756,14022,14292,14566,14843,15124,15409,15696,15987,16280,16576,16874,17175,17478,17783,18090,18399,18710,19022,19336,19652,19969,20288,20608,20930,21252,21576,21901,22227,22554,22882,23211,23541,23872,24203,24536,24869,25203,25537,25872,26208,26545,26882,27220,27558,27897,28236,28576,28917,29258,29599,29941,30283,30625,30968,31312,31655,32000,32344,32689,33034,33379,33725,34071,34417,34764,35111,35458,35805,36153,36501,36849,37197,37545,37894,38243,38592,38942,39291,39641,39991,40341,40691,41042,41392,41743,42094,42445,42796,43147,43499,43851,44202,44554,44906,45258,45611,45963,46316,46668,47021,9720,9727,9747,9780,9826,9885,9957,10041,10138,10246,10365,10496,10637,10788,10949,11119,11298,11486,11682,11885,12096,12314,12538,12769,13005,13247,13494,13746,14003,14264,14530,14799,15073,15350,15630,15913,16200,16489,16782,17076,17373,17673,17975,18279,18585,18892,19202,19513,19826,20141,20457,20774,21093,21413,21735,22057,22381,22706,23032,23358,23686,24015,24345,24675,25006,25338,25671,26005,26339,26674,27010,27346,27683,28020,28358,28696,29035,29375,29715,30055,30396,30737,31079,31421,31764,32107,32450,32794,33138,33482,33827,34172,34517,34862,35208,35554,35901,36248,36594,36942,37289,37637,37985,38333,38681,39030,39378,39727,40077,40426,40775,41125,41475,41825,42175,42526,42876,43227,43578,43929,44280,44631,44983,45334,45686,46038,46390,46742,47094,10080,10086,10106,10138,10182,10239,10309,10390,10483,10588,10704,10830,10967,11113,11270,11435,11610,11792,11983,12182,12387,12600,12819,13045,13276,13513,13756,14003,14255,14512,14773,15038,15307,15580,15856,16136,16419,16704,16993,17284,17577,17874,18172,18473,18775,19080,19387,19695,20005,20317,20630,20945,21261,21579,21898,22218,22540,22862,23186,23511,23836,24163,24491,24819,25149,25479,25810,26142,26474,26807,27141,27476,27811,28147,28483,28820,29158,29496,29834,30173,30513,30853,31194,31534,31876,32217,32560,32902,33245,33588,33932,34276,34620,34965,35309,35655,36000,36346,36692,37038,37385,37731,38078,38426,38773,39121,39469,39817,40165,40514,40863,41212,41561,41910,42260,42609,42959,43309,43660,44010,44360,44711,45062,45413,45764,46115,46467,46818,47170,10440,10446,10465,10496,10539,10594,10661,10740,10830,10931,11043,11166,11298,11441,11593,11754,11924,12102,12288,12481,12682,12890,13104,13325,13552,13784,14022,14264,14512,14764,15021,15282,15547,15815,16088,16363,16642,16924,17209,17496,17786,18079,18374,18671,18971,19273,19576,19882,20189,20498,20808,21121,21434,21749,22066,22384,22703,23023,23345,23667,23991,24315,24641,24967,25295,25623,25952,26282,26613,26945,27277,27610,27944,28278,28613,28948,29284,29621,29958,30296,30634,30973,31312,31651,31991,32332,32673,33014,33356,33698,34040,34383,34726,35070,35414,35758,36102,36447,36792,37138,37483,37829,38175,38522,38868,39215,39562,39910,40257,40605,40953,41301,41650,41998,42347,42696,43045,43395,43744,44094,44444,44794,45144,45494,45845,46195,46546,46897,47248,10800,10806,10824,10854,10896,10949,11014,11090,11177,11276,11384,11503,11632,11770,11918,12075,12240,12413,12595,12784,12980,13183,13393,13609,13831,14058,14292,14530,14773,15021,15274,15530,15791,16055,16324,16595,16870,17148,17429,17713,18000,18289,18581,18875,19171,19470,19771,20073,20377,20684,20991,21301,21612,21925,22239,22554,22871,23189,23508,23828,24150,24472,24796,25120,25446,25772,26099,26428,26757,27086,27417,27748,28080,28413,28746,29080,29414,29750,30085,30422,30758,31096,31434,31772,32111,32450,32790,33130,33470,33811,34153,34494,34836,35179,35522,35865,36208,36552,36896,37240,37585,37930,38275,38621,38967,39313,39659,40005,40352,40699,41046,41394,41741,42089,42437,42786,43134,43483,43831,44180,44530,44879,45228,45578,45928,46278,46628,46978,47329,11160,11166,11183,11212,11253,11304,11367,11441,11526,11621,11726,11842,11967,12102,12245,12398,12559,12728,12905,13089,13281,13480,13685,13896,14114,14337,14566,14799,15038,15282,15530,15783,16039,16300,16564,16832,17103,17377,17655,17935,18218,18504,18793,19083,19377,19672,19969,20269,20570,20874,21179,21486,21794,22104,22416,22729,23043,23358,23675,23993,24313,24633,24955,25277,25601,25925,26250,26577,26904,27232,27561,27890,28220,28551,28883,29216,29549,29882,30216,30551,30887,31223,31559,31896,32234,32572,32910,33249,33588,33928,34268,34609,34950,35291,35633,35975,36317,36660,37003,37346,37690,38034,38378,38723,39068,39413,39758,40104,40450,40796,41143,41489,41836,42183,42530,42878,43225,43573,43921,44270,44618,44967,45316,45665,46014,46363,46713,47062,47412,11520,11526,11542,11571,11610,11660,11721,11792,11875,11967,12069,12182,12303,12434,12574,12723,12880,13045,13217,13398,13585,13779,13980,14187,14400,14619,14843,15073,15307,15547,15791,16039,16292,16548,16809,17073,17340,17611,17884,18161,18441,18723,19009,19296,19586,19878,20173,20469,20768,21068,21371,21675,21981,22288,22597,22907,23219,23533,23847,24163,24480,24798,25118,25438,25760,26082,26405,26730,27055,27381,27708,28036,28365,28694,29024,29355,29686,30018,30351,30685,31019,31353,31688,32024,32360,32697,33034,33371,33710,34048,34387,34726,35066,35407,35747,36088,36429,36771,37113,37456,37798,38141,38485,38828,39172,39516,39861,40206,40551,40896,41242,41587,41933,42280,42626,42973,43320,43667,44014,44362,44710,45058,45406,45754,46102,46451,46800,47149,47498,11880,11885,11902,11929,11967,12016,12075,12144,12224,12314,12413,12523,12641,12769,12905,13050,13203,13364,13532,13708,13892,14081,14278,14481,14690,14904,15124,15350,15580,15815,16055,16300,16548,16801,17057,17317,17581,17848,18118,18392,18668,18947,19229,19513,19800,20089,20381,20674,20970,21267,21567,21868,22171,22476,22783,23091,23400,23711,24023,24337,24651,24967,25285,25603,25922,26243,26564,26887,27210,27535,27860,28186,28513,28840,29169,29498,29828,30158,30490,30822,31154,31487,31821,32155,32490,32825,33161,33497,33834,34172,34509,34848,35186,35525,35865,36205,36545,36886,37227,37568,37910,38252,38594,38937,39280,39623,39966,40310,40655,40999,41344,41689,42034,42379,42725,43071,43417,43763,44110,44457,44804,45151,45498,45846,46194,46542,46890,47238,47587,12240,12245,12261,12288,12324,12372,12429,12497,12574,12662,12758,12865,12980,13104,13237,13378,13528,13685,13849,14022,14201,14386,14579,14778,14982,15193,15409,15630,15856,16088,16324,16564,16809,17057,17310,17566,17826,18090,18356,18626,18899,19175,19453,19734,20018,20304,20593,20883,21176,21471,21767,22066,22366,22669,22972,23278,23585,23893,24203,24514,24827,25141,25456,25772,26089,26408,26727,27048,27369,27692,28015,28340,28665,28991,29317,29645,29973,30302,30632,30962,31293,31625,31957,32290,32623,32957,33292,33627,33962,34298,34635,34972,35309,35647,35986,36324,36663,37003,37343,37683,38024,38365,38706,39048,39390,39732,40075,40418,40761,41105,41448,41793,42137,42482,42826,43171,43517,43862,44208,44554,44901,45247,45594,45941,46288,46635,46982,47330,47678,12600,12605,12621,12646,12682,12728,12784,12850,12925,13010,13104,13208,13320,13441,13571,13708,13854,14008,14169,14337,14512,14694,14882,15077,15278,15484,15696,15913,16136,16363,16595,16832,17073,17317,17566,17819,18075,18335,18598,18865,19134,19407,19682,19960,20240,20523,20808,21096,21386,21678,21972,22268,22565,22865,23166,23469,23774,24080,24387,24696,25006,25318,25631,25945,26260,26577,26894,27213,27532,27853,28174,28497,28820,29144,29469,29795,30122,30449,30777,31106,31436,31766,32097,32428,32760,33093,33426,33759,34094,34428,34764,35100,35436,35772,36110,36447,36785,37124,37462,37802,38141,38481,38822,39162,39503,39845,40186,40528,40871,41213,41556,41899,42243,42587,42931,43275,43619,43964,44309,44655,45000,45346,45692,46038,46384,46731,47077,47424,47772,12960,12965,12980,13005,13040,13084,13139,13203,13276,13359,13451,13552,13661,13779,13906,14040,14182,14332,14490,14654,14826,15004,15188,15379,15576,15779,15987,16200,16419,16642,16870,17103,17340,17581,17826,18075,18328,18585,18844,19107,19373,19642,19914,20189,20466,20746,21028,21313,21600,21889,22180,22473,22768,23065,23364,23664,23966,24270,24575,24882,25190,25499,25810,26122,26435,26749,27065,27381,27699,28018,28337,28658,28979,29302,29625,29949,30274,30600,30926,31254,31582,31910,32240,32570,32900,33231,33563,33895,34228,34562,34896,35230,35565,35901,36237,36573,36910,37247,37585,37923,38262,38601,38940,39280,39620,39960,40301,40642,40983,41325,41667,42009,42352,42695,43038,43381,43725,44069,44413,44757,45102,45447,45792,46138,46483,46829,47175,47521,47868,13320,13325,13339,13364,13398,13441,13494,13556,13628,13708,13798,13896,14003,14118,14242,14373,14512,14659,14813,14974,15141,15316,15497,15684,15877,16076,16280,16489,16704,16924,17148,17377,17611,17848,18090,18335,18585,18837,19094,19353,19616,19882,20150,20422,20696,20973,21252,21534,21818,22104,22392,22683,22975,23269,23566,23863,24163,24464,24767,25071,25377,25684,25992,26302,26613,26925,27239,27554,27869,28186,28504,28822,29142,29463,29784,30107,30430,30754,31079,31405,31731,32058,32386,32714,33044,33373,33704,34035,34366,34698,35031,35364,35698,36032,36367,36702,37038,37374,37711,38048,38385,38723,39061,39400,39739,40078,40418,40758,41098,41439,41780,42122,42463,42805,43147,43490,43833,44176,44519,44863,45207,45551,45895,46240,46585,46930,47275,47621,47967,13680,13685,13699,13723,13756,13798,13849,13910,13980,14058,14146,14242,14346,14458,14579,14707,14843,14987,15137,15295,15459,15630,15807,15991,16180,16375,16576,16782,16993,17209,17429,17655,17884,18118,18356,18598,18844,19094,19346,19603,19862,20125,20390,20658,20930,21203,21480,21758,22040,22323,22608,22896,23186,23477,23771,24066,24363,24662,24962,25264,25568,25872,26179,26486,26795,27105,27417,27729,28043,28358,28674,28991,29309,29627,29947,30268,30589,30912,31235,31559,31884,32209,32536,32863,33190,33519,33848,34177,34507,34838,35170,35502,35834,36167,36501,36835,37169,37504,37839,38175,38512,38848,39185,39523,39861,40199,40538,40877,41216,41556,41896,42237,42578,42919,43260,43602,43944,44286,44628,44971,45314,45658,46001,46345,46689,47033,47378,47723,48068,14040,14045,14058,14081,14114,14155,14205,14264,14332,14409,14494,14588,14690,14799,14917,15043,15176,15316,15463,15618,15779,15946,16120,16300,16485,16677,16874,17076,17284,17496,17713,17935,18161,18392,18626,18865,19107,19353,19603,19856,20112,20371,20633,20899,21167,21437,21711,21987,22265,22545,22828,23113,23400,23689,23980,24273,24567,24863,25161,25461,25762,26065,26369,26674,26981,27289,27598,27909,28220,28533,28847,29162,29478,29795,30113,30432,30752,31073,31394,31717,32040,32364,32689,33014,33340,33667,33995,34323,34652,34981,35311,35642,35973,36305,36637,36970,37303,37637,37971,38306,38641,38977,39313,39649,39986,40323,40661,40999,41337,41676,42015,42355,42695,43035,43375,43716,44057,44398,44740,45082,45424,45767,46110,46453,46796,47139,47483,47827,48171,14400,14404,14418,14440,14472,14512,14561,14619,14685,14760,14843,14935,15034,15141,15257,15379,15509,15647,15791,15942,16100,16264,16434,16611,16793,16981,17175,17373,17577,17786,18000,18218,18441,18668,18899,19134,19373,19616,19862,20112,20365,20621,20880,21142,21407,21675,21945,22218,22494,22771,23051,23333,23618,23904,24192,24483,24775,25069,25364,25661,25960,26260,26562,26865,27170,27476,27783,28092,28401,28712,29024,29337,29651,29967,30283,30600,30918,31237,31557,31878,32199,32522,32845,33169,33494,33819,34145,34472,34799,35127,35456,35785,36115,36445,36776,37108,37440,37773,38106,38439,38773,39108,39443,39778,40114,40450,40787,41124,41461,41799,42137,42475,42814,43153,43493,43833,44173,44514,44854,45195,45537,45878,46220,46563,46905,47248,47591,47934,48278,14760,14764,14778,14799,14830,14869,14917,14974,15038,15111,15193,15282,15379,15484,15597,15717,15844,15978,16120,16268,16422,16583,16751,16924,17103,17287,17478,17673,17874,18079,18289,18504,18723,18947,19175,19407,19642,19882,20125,20371,20621,20874,21130,21389,21651,21916,22183,22453,22726,23001,23278,23557,23839,24123,24408,24696,24986,25277,25570,25865,26161,26459,26759,27060,27362,27666,27971,28278,28585,28894,29204,29516,29828,30141,30456,30771,31087,31405,31723,32042,32362,32683,33004,33327,33650,33974,34298,34624,34950,35276,35604,35932,36260,36589,36919,37249,37580,37911,38243,38575,38908,39242,39575,39910,40244,40580,40915,41251,41587,41924,42261,42599,42937,43275,43614,43952,44292,44631,44971,45311,45652,45993,46334,46675,47017,47359,47701,48043,48386,15120,15124,15137,15159,15188,15227,15274,15329,15392,15463,15543,15630,15725,15828,15938,16055,16180,16312,16450,16595,16747,16905,17069,17239,17414,17596,17783,17975,18172,18374,18581,18793,19009,19229,19453,19682,19914,20150,20390,20633,20880,21130,21383,21639,21898,22160,22424,22691,22961,23233,23508,23785,24064,24345,24628,24913,25200,25489,25780,26072,26366,26662,26959,27258,27558,27860,28163,28467,28773,29080,29388,29697,30008,30319,30632,30945,31260,31576,31892,32209,32528,32847,33167,33488,33809,34132,34455,34779,35103,35428,35754,36081,36408,36736,37064,37393,37723,38053,38383,38715,39046,39378,39711,40044,40378,40712,41046,41381,41717,42052,42388,42725,43062,43399,43737,44075,44413,44752,45091,45430,45770,46110,46450,46790,47131,47472,47814,48155,48497,15480,15484,15497,15518,15547,15584,15630,15684,15746,15815,15893,15978,16071,16172,16280,16395,16517,16646,16782,16924,17073,17227,17388,17555,17728,17906,18090,18279,18473,18671,18875,19083,19296,19513,19734,19960,20189,20422,20658,20899,21142,21389,21639,21892,22148,22407,22669,22933,23200,23469,23741,24015,24291,24570,24850,25133,25418,25704,25992,26282,26574,26868,27163,27459,27757,28057,28358,28660,28964,29269,29575,29882,30191,30500,30811,31123,31436,31749,32064,32380,32697,33014,33333,33652,33972,34293,34614,34937,35260,35584,35908,36233,36559,36886,37213,37540,37869,38197,38527,38857,39187,39518,39850,40182,40514,40847,41180,41514,41848,42183,42518,42854,43189,43526,43862,44199,44537,44875,45213,45551,45890,46229,46568,46908,47248,47588,47929,48270,48611,15840,15844,15856,15877,15905,15942,15987,16039,16100,16168,16244,16327,16419,16517,16622,16735,16855,16981,17114,17254,17400,17552,17710,17874,18043,18218,18399,18585,18775,18971,19171,19377,19586,19800,20018,20240,20466,20696,20930,21167,21407,21651,21898,22148,22401,22657,22916,23177,23442,23708,23977,24249,24522,24798,25076,25356,25638,25922,26208,26496,26786,27077,27369,27664,27960,28257,28556,28856,29158,29461,29765,30070,30377,30685,30993,31303,31614,31927,32240,32554,32869,33185,33501,33819,34137,34457,34777,35098,35419,35742,36065,36389,36713,37038,37364,37690,38017,38345,38673,39001,39331,39660,39991,40322,40653,40985,41317,41650,41983,42316,42651,42985,43320,43655,43991,44327,44663,45000,45337,45675,46012,46351,46689,47028,47367,47706,48046,48386,48727,16200,16204,16216,16236,16264,16300,16343,16395,16454,16521,16595,16677,16766,16862,16966,17076,17194,17317,17448,17585,17728,17877,18032,18193,18360,18532,18710,18892,19080,19273,19470,19672,19878,20089,20304,20523,20746,20973,21203,21437,21675,21916,22160,22407,22657,22910,23166,23425,23686,23950,24217,24485,24756,25030,25305,25583,25862,26144,26428,26713,27000,27289,27579,27872,28165,28460,28757,29055,29355,29656,29958,30261,30566,30872,31179,31487,31796,32107,32418,32730,33044,33358,33673,33989,34306,34624,34942,35262,35582,35903,36224,36547,36870,37193,37518,37843,38168,38495,38822,39149,39477,39806,40135,40464,40795,41125,41456,41788,42120,42453,42786,43119,43453,43787,44122,44457,44792,45128,45464,45801,46138,46475,46812,47150,47489,47827,48166,48505,48845,16560,16564,16576,16595,16622,16658,16700,16751,16809,16874,16947,17027,17114,17209,17310,17418,17533,17655,17783,17917,18058,18204,18356,18515,18678,18848,19022,19202,19387,19576,19771,19969,20173,20381,20593,20808,21028,21252,21480,21711,21945,22183,22424,22669,22916,23166,23419,23675,23934,24195,24459,24725,24993,25264,25537,25812,26089,26369,26650,26933,27218,27504,27792,28082,28374,28667,28962,29258,29555,29854,30154,30456,30758,31062,31368,31674,31981,32290,32599,32910,33222,33534,33848,34162,34477,34794,35111,35428,35747,36067,36387,36708,37029,37352,37675,37998,38323,38648,38973,39299,39626,39954,40281,40610,40939,41268,41598,41929,42260,42591,42923,43255,43588,43921,44255,44589,44924,45258,45594,45929,46265,46602,46938,47275,47613,47950,48288,48627,48965,16920,16924,16935,16954,16981,17015,17057,17107,17163,17227,17299,17377,17463,17555,17655,17761,17874,17993,18118,18250,18388,18532,18682,18837,18998,19165,19336,19513,19695,19882,20073,20269,20469,20674,20883,21096,21313,21534,21758,21987,22218,22453,22691,22933,23177,23425,23675,23928,24184,24443,24704,24967,25233,25502,25772,26045,26319,26596,26875,27156,27438,27722,28008,28296,28585,28876,29169,29463,29758,30055,30353,30653,30954,31256,31559,31864,32169,32476,32784,33093,33402,33713,34025,34338,34652,34966,35282,35598,35915,36233,36552,36871,37192,37513,37834,38157,38480,38803,39128,39452,39778,40104,40431,40758,41086,41414,41743,42072,42402,42732,43063,43395,43726,44058,44391,44724,45058,45391,45726,46060,46395,46731,47066,47403,47739,48076,48413,48750,49088,17280,17284,17295,17314,17340,17373,17414,17463,17518,17581,17651,17728,17812,17903,18000,18104,18215,18332,18455,18585,18720,18861,19009,19161,19320,19483,19652,19826,20005,20189,20377,20570,20768,20970,21176,21386,21600,21818,22040,22265,22494,22726,22961,23200,23442,23686,23934,24184,24438,24693,24952,25213,25476,25742,26010,26280,26552,26827,27103,27381,27661,27944,28227,28513,28800,29089,29379,29671,29964,30259,30555,30853,31152,31452,31754,32056,32360,32665,32971,33278,33586,33895,34206,34517,34829,35142,35456,35771,36086,36403,36720,37038,37357,37676,37997,38318,38639,38962,39285,39608,39932,40257,40583,40909,41235,41562,41890,42218,42547,42876,43206,43536,43867,44198,44530,44862,45194,45527,45860,46194,46528,46862,47197,47532,47868,48204,48540,48877,49213,17640,17644,17655,17673,17699,17732,17772,17819,17874,17935,18004,18079,18161,18250,18346,18448,18557,18671,18793,18920,19053,19192,19336,19487,19642,19803,19969,20141,20317,20498,20684,20874,21068,21267,21471,21678,21889,22104,22323,22545,22771,23001,23233,23469,23708,23950,24195,24443,24693,24947,25203,25461,25722,25985,26250,26518,26788,27060,27334,27610,27888,28168,28449,28732,29017,29304,29592,29882,30173,30466,30761,31056,31353,31651,31951,32252,32554,32857,33161,33466,33773,34080,34389,34698,35009,35320,35633,35946,36260,36575,36891,37207,37525,37843,38162,38481,38802,39123,39444,39767,40090,40413,40737,41062,41387,41713,42040,42367,42695,43023,43351,43680,44010,44340,44670,45001,45333,45665,45997,46330,46663,46996,47330,47664,47999,48334,48669,49005,49341,18000,18004,18014,18032,18058,18090,18129,18176,18229,18289,18356,18430,18511,18598,18692,18793,18899,19012,19131,19256,19387,19523,19665,19813,19966,20125,20288,20457,20630,20808,20991,21179,21371,21567,21767,21972,22180,22392,22608,22828,23051,23278,23508,23741,23977,24217,24459,24704,24952,25203,25456,25712,25970,26231,26494,26759,27026,27296,27568,27841,28117,28394,28674,28955,29238,29522,29808,30096,30385,30676,30968,31262,31557,31853,32151,32450,32750,33051,33354,33658,33962,34268,34575,34883,35192,35502,35812,36124,36437,36750,37064,37379,37695,38012,38329,38648,38967,39286,39607,39928,40249,40572,40894,41218,41542,41867,42192,42518,42845,43171,43499,43827,44155,44484,44814,45144,45474,45805,46136,46468,46800,47133,47465,47799,48132,48466,48801,49136,49471,18360,18364,18374,18392,18416,18448,18487,18532,18585,18644,18710,18782,18861,18947,19039,19138,19242,19353,19470,19593,19721,19856,19995,20141,20291,20447,20608,20774,20945,21121,21301,21486,21675,21868,22066,22268,22473,22683,22896,23113,23333,23557,23785,24015,24249,24485,24725,24967,25213,25461,25712,25965,26221,26479,26740,27002,27267,27535,27804,28075,28349,28624,28901,29180,29461,29743,30027,30313,30600,30889,31179,31471,31764,32058,32354,32651,32949,33249,33550,33851,34154,34459,34764,35070,35377,35685,35995,36305,36616,36928,37240,37554,37869,38184,38500,38817,39134,39452,39771,40091,40412,40733,41054,41377,41699,42023,42347,42672,42997,43323,43649,43976,44303,44631,44960,45289,45618,45948,46278,46609,46940,47271,47603,47935,48268,48601,48935,49269,49603,18720,18723,18734,18751,18775,18806,18844,18889,18940,18998,19063,19134,19212,19296,19387,19483,19586,19695,19810,19930,20057,20189,20326,20469,20618,20771,20930,21093,21261,21434,21612,21794,21981,22171,22366,22565,22768,22975,23186,23400,23618,23839,24064,24291,24522,24756,24993,25233,25476,25722,25970,26221,26474,26730,26988,27248,27511,27776,28043,28312,28583,28856,29131,29408,29686,29967,30249,30532,30817,31104,31392,31682,31973,32266,32560,32855,33151,33449,33748,34048,34349,34652,34955,35260,35565,35872,36180,36488,36798,37108,37419,37731,38044,38358,38673,38988,39304,39621,39939,40257,40576,40896,41216,41538,41859,42181,42504,42828,43152,43477,43802,44128,44454,44781,45108,45436,45764,46093,46422,46752,47082,47412,47743,48074,48406,48738,49071,49404,49737,19080,19083,19094,19111,19134,19165,19202,19246,19296,19353,19417,19487,19563,19646,19734,19829,19930,20037,20150,20269,20393,20523,20658,20799,20945,21096,21252,21413,21579,21749,21925,22104,22288,22476,22669,22865,23065,23269,23477,23689,23904,24123,24345,24570,24798,25030,25264,25502,25742,25985,26231,26479,26730,26983,27239,27497,27757,28020,28285,28551,28820,29091,29364,29638,29915,30193,30473,30754,31037,31322,31608,31896,32185,32476,32768,33061,33356,33652,33949,34247,34547,34848,35149,35452,35756,36061,36367,36674,36982,37291,37601,37911,38223,38535,38848,39162,39477,39793,40109,40426,40744,41062,41381,41701,42021,42342,42664,42986,43309,43633,43957,44281,44607,44932,45258,45585,45912,46240,46568,46897,47226,47555,47885,48216,48547,48878,49210,49542,49874,19440,19443,19453,19470,19493,19523,19560,19603,19652,19708,19771,19839,19914,19995,20083,20176,20275,20381,20492,20608,20730,20858,20991,21130,21274,21422,21576,21735,21898,22066,22239,22416,22597,22783,22972,23166,23364,23566,23771,23980,24192,24408,24628,24850,25076,25305,25537,25772,26010,26250,26494,26740,26988,27239,27492,27748,28006,28266,28529,28793,29060,29328,29599,29871,30146,30422,30699,30979,31260,31543,31827,32113,32400,32689,32979,33270,33563,33857,34153,34449,34747,35046,35346,35647,35950,36253,36557,36863,37169,37476,37785,38094,38404,38715,39026,39339,39652,39966,40281,40597,40913,41231,41548,41867,42186,42506,42826,43147,43469,43791,44114,44438,44762,45086,45411,45737,46063,46390,46717,47044,47372,47701,48030,48359,48689,49020,49350,49681,50013,19800,19803,19813,19829,19852,19882,19917,19960,20008,20063,20125,20192,20266,20346,20431,20523,20621,20724,20833,20948,21068,21194,21325,21462,21603,21749,21901,22057,22218,22384,22554,22729,22907,23091,23278,23469,23664,23863,24066,24273,24483,24696,24913,25133,25356,25583,25812,26045,26280,26518,26759,27002,27248,27497,27748,28001,28257,28515,28775,29038,29302,29568,29837,30107,30379,30653,30929,31206,31485,31766,32048,32332,32617,32904,33192,33482,33773,34065,34359,34654,34950,35247,35545,35845,36146,36447,36750,37054,37359,37664,37971,38279,38587,38897,39207,39518,39830,40143,40456,40771,41086,41402,41718,42035,42353,42672,42991,43311,43631,43952,44274,44596,44919,45243,45567,45891,46216,46542,46868,47194,47521,47849,48177,48505,48834,49163,49493,49823,50154,20160,20163,20173,20189,20211,20240,20275,20317,20365,20419,20479,20545,20618,20696,20780,20871,20967,21068,21176,21289,21407,21531,21660,21794,21933,22078,22227,22381,22540,22703,22871,23043,23219,23400,23585,23774,23966,24163,24363,24567,24775,24986,25200,25418,25638,25862,26089,26319,26552,26788,27026,27267,27511,27757,28006,28257,28511,28766,29024,29284,29546,29811,30077,30345,30615,30887,31160,31436,31713,31991,32272,32554,32837,33122,33408,33696,33985,34276,34567,34861,35155,35450,35747,36045,36344,36644,36945,37247,37551,37855,38160,38466,38773,39081,39390,39700,40010,40322,40634,40947,41260,41575,41890,42206,42523,42840,43158,43477,43796,44116,44436,44757,45079,45401,45724,46048,46372,46696,47021,47347,47672,47999,48326,48653,48981,49309,49638,49967,50297,20520,20523,20533,20548,20570,20599,20633,20674,20721,20774,20833,20899,20970,21047,21130,21219,21313,21413,21519,21630,21747,21868,21995,22128,22265,22407,22554,22706,22862,23023,23189,23358,23533,23711,23893,24080,24270,24464,24662,24863,25069,25277,25489,25704,25922,26144,26369,26596,26827,27060,27296,27535,27776,28020,28266,28515,28766,29020,29275,29533,29793,30055,30319,30585,30853,31123,31394,31668,31943,32219,32498,32778,33059,33342,33627,33913,34200,34489,34779,35070,35363,35656,35951,36248,36545,36843,37143,37443,37745,38048,38351,38656,38962,39268,39575,39884,40193,40503,40814,41125,41438,41751,42065,42379,42695,43011,43327,43645,43963,44281,44601,44921,45241,45562,45884,46206,46529,46853,47176,47501,47826,48151,48477,48804,49130,49458,49786,50114,50442,20880,20883,20892,20908,20930,20957,20991,21032,21078,21130,21188,21252,21322,21398,21480,21567,21660,21758,21862,21972,22087,22206,22332,22462,22597,22737,22882,23032,23186,23345,23508,23675,23847,24023,24203,24387,24575,24767,24962,25161,25364,25570,25780,25992,26208,26428,26650,26875,27103,27334,27568,27804,28043,28285,28529,28775,29024,29275,29529,29784,30042,30302,30564,30828,31094,31361,31631,31902,32175,32450,32726,33004,33284,33565,33848,34132,34417,34704,34992,35282,35573,35865,36158,36453,36748,37045,37343,37642,37942,38243,38545,38848,39152,39457,39763,40070,40378,40686,40996,41306,41617,41929,42241,42555,42869,43183,43499,43815,44132,44449,44768,45086,45406,45726,46046,46367,46689,47011,47334,47658,47981,48306,48631,48956,49282,49608,49935,50262,50590,21240,21243,21252,21267,21289,21316,21350,21389,21434,21486,21543,21606,21675,21749,21830,21916,22007,22104,22206,22314,22427,22545,22669,22797,22930,23068,23211,23358,23511,23667,23828,23993,24163,24337,24514,24696,24882,25071,25264,25461,25661,25865,26072,26282,26496,26713,26933,27156,27381,27610,27841,28075,28312,28551,28793,29038,29284,29533,29784,30038,30294,30551,30811,31073,31337,31602,31870,32139,32410,32683,32957,33233,33511,33790,34071,34353,34637,34922,35208,35496,35785,36076,36367,36660,36954,37249,37545,37843,38141,38441,38741,39043,39346,39649,39954,40259,40565,40872,41180,41489,41799,42109,42420,42732,43045,43359,43673,43988,44303,44620,44937,45254,45572,45891,46211,46531,46851,47172,47494,47816,48139,48462,48786,49111,49435,49761,50087,50413,50740,21600,21603,21612,21627,21648,21675,21708,21747,21791,21842,21898,21960,22028,22101,22180,22265,22355,22450,22551,22657,22768,22885,23006,23133,23264,23400,23541,23686,23836,23991,24150,24313,24480,24651,24827,25006,25190,25377,25568,25762,25960,26161,26366,26574,26786,27000,27218,27438,27661,27888,28117,28349,28583,28820,29060,29302,29546,29793,30042,30294,30547,30803,31060,31320,31582,31845,32111,32378,32647,32918,33190,33465,33740,34018,34296,34577,34859,35142,35427,35713,36000,36289,36579,36870,37162,37456,37750,38046,38343,38641,38940,39240,39541,39843,40146,40450,40755,41061,41367,41675,41983,42292,42602,42913,43224,43536,43849,44163,44477,44792,45108,45424,45741,46059,46377,46696,47016,47336,47656,47977,48299,48621,48944,49267,49591,49916,50240,50566,50891,21960,21963,21972,21987,22007,22034,22066,22104,22148,22198,22253,22314,22381,22453,22531,22614,22703,22797,22896,23001,23110,23225,23345,23469,23599,23733,23872,24015,24163,24315,24472,24633,24798,24967,25141,25318,25499,25684,25872,26065,26260,26459,26662,26868,27077,27289,27504,27722,27944,28168,28394,28624,28856,29091,29328,29568,29811,30055,30302,30551,30803,31056,31312,31569,31829,32091,32354,32619,32886,33155,33426,33698,33972,34247,34524,34803,35083,35364,35647,35932,36217,36504,36792,37082,37372,37664,37957,38252,38547,38843,39141,39439,39739,40039,40341,40643,40947,41251,41556,41862,42169,42477,42786,43095,43405,43716,44028,44340,44653,44967,45281,45597,45912,46229,46546,46864,47182,47501,47820,48140,48461,48782,49104,49426,49749,50072,50396,50720,51045,22320,22323,22332,22346,22366,22392,22424,22462,22505,22554,22608,22669,22734,22805,22882,22964,23051,23144,23242,23345,23453,23566,23684,23806,23934,24066,24203,24345,24491,24641,24796,24955,25118,25285,25456,25631,25810,25992,26179,26369,26562,26759,26959,27163,27369,27579,27792,28008,28227,28449,28674,28901,29131,29364,29599,29837,30077,30319,30564,30811,31060,31312,31565,31821,32078,32338,32599,32863,33128,33395,33663,33934,34206,34479,34754,35031,35309,35589,35870,36153,36437,36722,37008,37296,37585,37875,38167,38459,38753,39048,39344,39641,39939,40238,40538,40839,41141,41444,41748,42052,42358,42664,42971,43279,43588,43898,44208,44519,44831,45144,45457,45771,46086,46401,46717,47033,47351,47668,47987,48306,48625,48945,49266,49587,49909,50231,50554,50877,51201,22680,22683,22691,22706,22726,22751,22783,22820,22862,22910,22964,23023,23088,23158,23233,23314,23400,23491,23588,23689,23795,23907,24023,24144,24270,24400,24536,24675,24819,24967,25120,25277,25438,25603,25772,25945,26122,26302,26486,26674,26865,27060,27258,27459,27664,27872,28082,28296,28513,28732,28955,29180,29408,29638,29871,30107,30345,30585,30828,31073,31320,31569,31821,32074,32330,32587,32847,33108,33371,33636,33903,34172,34442,34713,34987,35262,35538,35816,36095,36376,36658,36942,37227,37513,37800,38089,38378,38669,38962,39255,39549,39845,40141,40439,40737,41037,41337,41639,41941,42244,42549,42854,43159,43466,43774,44082,44391,44701,45012,45323,45635,45948,46261,46575,46890,47205,47521,47838,48155,48473,48792,49111,49430,49750,50071,50392,50714,51036,51359,23040,23043,23051,23065,23085,23110,23141,23177,23219,23267,23320,23378,23442,23511,23585,23664,23749,23839,23934,24034,24139,24249,24363,24483,24607,24735,24869,25006,25149,25295,25446,25601,25760,25922,26089,26260,26435,26613,26795,26981,27170,27362,27558,27757,27960,28165,28374,28585,28800,29017,29238,29461,29686,29915,30146,30379,30615,30853,31094,31337,31582,31829,32078,32330,32583,32839,33097,33356,33617,33880,34145,34412,34680,34950,35221,35494,35769,36045,36323,36602,36882,37164,37447,37731,38017,38304,38592,38882,39172,39464,39757,40051,40346,40642,40939,41237,41536,41836,42137,42439,42742,43045,43350,43655,43961,44268,44576,44885,45194,45504,45815,46126,46439,46752,47065,47379,47694,48010,48326,48643,48960,49278,49596,49916,50235,50555,50876,51197,51519,23400,23403,23411,23425,23444,23469,23499,23535,23577,23623,23675,23733,23795,23863,23937,24015,24098,24187,24281,24379,24483,24591,24704,24822,24944,25071,25203,25338,25479,25623,25772,25925,26082,26243,26408,26577,26749,26925,27105,27289,27476,27666,27860,28057,28257,28460,28667,28876,29089,29304,29522,29743,29967,30193,30422,30653,30887,31123,31361,31602,31845,32091,32338,32587,32839,33093,33348,33606,33865,34126,34389,34654,34920,35188,35458,35729,36002,36276,36552,36829,37108,37388,37669,37952,38236,38522,38808,39096,39385,39675,39966,40259,40552,40847,41143,41439,41737,42035,42335,42635,42937,43239,43542,43846,44151,44457,44763,45071,45379,45687,45997,46307,46618,46930,47242,47555,47869,48184,48499,48814,49130,49447,49765,50083,50401,50720,51040,51360,51681,23760,23763,23771,23785,23804,23828,23858,23893,23934,23980,24031,24088,24150,24217,24289,24366,24448,24536,24628,24725,24827,24934,25045,25161,25282,25407,25537,25671,25810,25952,26099,26250,26405,26564,26727,26894,27065,27239,27417,27598,27783,27971,28163,28358,28556,28757,28962,29169,29379,29592,29808,30027,30249,30473,30699,30929,31160,31394,31631,31870,32111,32354,32599,32847,33097,33348,33602,33857,34115,34374,34635,34898,35162,35428,35696,35966,36237,36509,36783,37059,37336,37614,37894,38175,38458,38741,39026,39313,39600,39889,40178,40469,40761,41054,41348,41643,41940,42237,42535,42834,43134,43435,43737,44039,44343,44647,44952,45258,45565,45873,46181,46490,46800,47111,47422,47734,48046,48359,48673,48988,49303,49619,49935,50252,50569,50887,51206,51525,51845,24120,24123,24131,24144,24163,24187,24217,24251,24291,24337,24387,24443,24504,24570,24641,24717,24798,24884,24975,25071,25172,25277,25387,25502,25621,25744,25872,26005,26142,26282,26428,26577,26730,26887,27048,27213,27381,27554,27729,27909,28092,28278,28467,28660,28856,29055,29258,29463,29671,29882,30096,30313,30532,30754,30979,31206,31436,31668,31902,32139,32378,32619,32863,33108,33356,33606,33857,34111,34366,34624,34883,35144,35407,35671,35937,36205,36474,36745,37017,37291,37566,37843,38121,38400,38681,38963,39247,39531,39817,40104,40392,40682,40972,41264,41556,41850,42145,42440,42737,43035,43333,43633,43933,44235,44537,44840,45144,45448,45754,46060,46367,46675,46984,47293,47603,47914,48225,48537,48850,49163,49477,49792,50107,50423,50740,51057,51374,51692,52011,24480,24483,24491,24504,24522,24546,24575,24609,24649,24693,24743,24798,24858,24923,24993,25069,25149,25233,25323,25418,25517,25621,25729,25842,25960,26082,26208,26339,26474,26613,26757,26904,27055,27210,27369,27532,27699,27869,28043,28220,28401,28585,28773,28964,29158,29355,29555,29758,29964,30173,30385,30600,30817,31037,31260,31485,31713,31943,32175,32410,32647,32886,33128,33371,33617,33865,34115,34366,34620,34875,35133,35392,35653,35915,36180,36445,36713,36982,37253,37525,37798,38073,38350,38628,38907,39187,39469,39752,40036,40322,40608,40896,41185,41475,41766,42058,42352,42646,42941,43237,43535,43833,44132,44432,44733,45035,45337,45641,45945,46250,46556,46862,47170,47478,47787,48096,48406,48717,49029,49341,49654,49967,50282,50596,50912,51228,51544,51861,52179,24840,24843,24850,24863,24882,24905,24934,24967,25006,25050,25100,25154,25213,25277,25346,25420,25499,25583,25671,25765,25862,25965,26072,26184,26300,26420,26545,26674,26807,26945,27086,27232,27381,27535,27692,27853,28018,28186,28358,28533,28712,28894,29080,29269,29461,29656,29854,30055,30259,30466,30676,30889,31104,31322,31543,31766,31991,32219,32450,32683,32918,33155,33395,33636,33880,34126,34374,34624,34875,35129,35385,35642,35901,36162,36424,36688,36954,37221,37490,37761,38032,38306,38581,38857,39134,39413,39693,39975,40257,40541,40826,41113,41400,41689,41978,42269,42561,42854,43147,43442,43738,44035,44333,44631,44931,45231,45533,45835,46138,46441,46746,47051,47357,47664,47972,48280,48589,48899,49210,49521,49832,50145,50458,50771,51086,51401,51716,52032,52349,25200,25203,25210,25223,25241,25264,25292,25326,25364,25407,25456,25509,25568,25631,25699,25772,25850,25932,26020,26112,26208,26310,26415,26525,26640,26759,26882,27010,27141,27277,27417,27561,27708,27860,28015,28174,28337,28504,28674,28847,29024,29204,29388,29575,29765,29958,30154,30353,30555,30761,30968,31179,31392,31608,31827,32048,32272,32498,32726,32957,33190,33426,33663,33903,34145,34389,34635,34883,35133,35385,35638,35894,36151,36410,36671,36933,37197,37462,37730,37998,38269,38540,38813,39088,39364,39641,39919,40199,40480,40763,41046,41331,41617,41904,42192,42482,42772,43063,43356,43649,43944,44239,44535,44833,45131,45430,45730,46031,46332,46635,46938,47242,47547,47853,48159,48466,48774,49083,49392,49702,50013,50324,50636,50949,51262,51576,51890,52205,52521,25560,25563,25570,25583,25601,25623,25651,25684,25722,25765,25812,25865,25922,25985,26052,26124,26201,26282,26369,26459,26555,26655,26759,26868,26981,27098,27220,27346,27476,27610,27748,27890,28036,28186,28340,28497,28658,28822,28991,29162,29337,29516,29697,29882,30070,30261,30456,30653,30853,31056,31262,31471,31682,31896,32113,32332,32554,32778,33004,33233,33465,33698,33934,34172,34412,34654,34898,35144,35392,35642,35894,36147,36403,36660,36919,37179,37442,37706,37971,38238,38507,38777,39048,39321,39595,39871,40148,40426,40705,40986,41268,41552,41836,42122,42408,42696,42985,43275,43566,43858,44151,44445,44740,45036,45333,45631,45929,46229,46529,46830,47133,47435,47739,48043,48349,48655,48961,49269,49577,49886,50195,50505,50816,51128,51440,51752,52066,52380,52694,25920,25922,25930,25942,25960,25982,26010,26042,26080,26122,26169,26221,26278,26339,26405,26477,26552,26633,26718,26807,26901,27000,27103,27210,27322,27438,27558,27683,27811,27944,28080,28220,28365,28513,28665,28820,28979,29142,29309,29478,29651,29828,30008,30191,30377,30566,30758,30954,31152,31353,31557,31764,31973,32185,32400,32617,32837,33059,33284,33511,33740,33972,34206,34442,34680,34920,35162,35407,35653,35901,36151,36403,36656,36912,37169,37428,37688,37951,38214,38480,38746,39015,39285,39556,39828,40102,40378,40655,40932,41212,41492,41774,42057,42341,42626,42913,43200,43489,43778,44069,44360,44653,44947,45241,45537,45833,46131,46429,46728,47028,47329,47630,47933,48236,48540,48845,49150,49456,49763,50071,50379,50688,50998,51309,51620,51931,52243,52556,52870,26280,26282,26290,26302,26319,26342,26369,26401,26437,26479,26525,26577,26633,26693,26759,26829,26904,26983,27067,27156,27248,27346,27447,27554,27664,27778,27897,28020,28147,28278,28413,28551,28694,28840,28991,29144,29302,29463,29627,29795,29967,30141,30319,30500,30685,30872,31062,31256,31452,31651,31853,32058,32266,32476,32689,32904,33122,33342,33565,33790,34018,34247,34479,34713,34950,35188,35428,35671,35915,36162,36410,36660,36912,37166,37421,37678,37937,38197,38459,38723,38988,39255,39523,39793,40064,40336,40610,40885,41161,41439,41718,41998,42280,42562,42846,43131,43417,43704,43992,44281,44572,44863,45155,45448,45743,46038,46334,46631,46929,47227,47527,47827,48128,48430,48733,49037,49341,49646,49952,50258,50566,50873,51182,51491,51801,52112,52423,52735,53047,26640,26642,26650,26662,26679,26701,26727,26759,26795,26836,26882,26933,26988,27048,27113,27182,27256,27334,27417,27504,27596,27692,27792,27897,28006,28119,28236,28358,28483,28613,28746,28883,29024,29169,29317,29469,29625,29784,29947,30113,30283,30456,30632,30811,30993,31179,31368,31559,31754,31951,32151,32354,32560,32768,32979,33192,33408,33627,33848,34071,34296,34524,34754,34987,35221,35458,35696,35937,36180,36424,36671,36919,37169,37421,37675,37930,38187,38446,38706,38968,39232,39497,39763,40031,40301,40572,40844,41117,41392,41668,41946,42224,42504,42786,43068,43351,43636,43921,44208,44496,44785,45075,45366,45658,45950,46244,46539,46835,47131,47429,47727,48026,48326,48627,48928,49231,49534,49838,50142,50448,50754,51060,51368,51676,51985,52294,52604,52915,53226,27000,27002,27010,27022,27038,27060,27086,27117,27153,27194,27239,27289,27343,27403,27466,27535,27608,27685,27767,27853,27944,28038,28138,28241,28349,28460,28576,28696,28820,28948,29080,29216,29355,29498,29645,29795,29949,30107,30268,30432,30600,30771,30945,31123,31303,31487,31674,31864,32056,32252,32450,32651,32855,33061,33270,33482,33696,33913,34132,34353,34577,34803,35031,35262,35494,35729,35966,36205,36445,36688,36933,37179,37428,37678,37930,38184,38439,38696,38955,39215,39477,39740,40005,40272,40540,40809,41079,41351,41625,41899,42175,42453,42731,43011,43291,43573,43857,44141,44426,44713,45000,45289,45578,45869,46160,46453,46746,47040,47336,47632,47929,48227,48525,48825,49125,49426,49728,50031,50334,50639,50943,51249,51555,51862,52170,52479,52788,53097,53408,27360,27362,27369,27381,27398,27419,27445,27476,27511,27551,27596,27645,27699,27757,27820,27888,27960,28036,28117,28202,28292,28385,28483,28585,28692,28802,28917,29035,29158,29284,29414,29549,29686,29828,29973,30122,30274,30430,30589,30752,30918,31087,31260,31436,31614,31796,31981,32169,32360,32554,32750,32949,33151,33356,33563,33773,33985,34200,34417,34637,34859,35083,35309,35538,35769,36002,36237,36474,36713,36954,37197,37442,37688,37937,38187,38439,38693,38948,39205,39464,39724,39986,40249,40514,40780,41048,41317,41587,41859,42132,42407,42682,42959,43237,43517,43797,44079,44362,44646,44931,45217,45504,45792,46081,46372,46663,46955,47248,47542,47837,48132,48429,48727,49025,49324,49624,49925,50226,50528,50831,51135,51440,51745,52051,52357,52665,52973,53281,53590,27720,27722,27729,27741,27757,27778,27804,27834,27869,27909,27953,28001,28055,28112,28174,28241,28312,28388,28467,28551,28640,28732,28829,28930,29035,29144,29258,29375,29496,29621,29750,29882,30018,30158,30302,30449,30600,30754,30912,31073,31237,31405,31576,31749,31927,32107,32290,32476,32665,32857,33051,33249,33449,33652,33857,34065,34276,34489,34704,34922,35142,35364,35589,35816,36045,36276,36509,36745,36982,37221,37462,37706,37951,38197,38446,38696,38948,39202,39457,39714,39973,40233,40495,40758,41023,41289,41556,41825,42095,42367,42640,42914,43189,43466,43744,44023,44303,44585,44867,45151,45436,45721,46008,46296,46585,46875,47165,47457,47750,48043,48338,48633,48930,49227,49525,49823,50123,50423,50724,51026,51329,51632,51936,52241,52546,52853,53159,53467,53775,28080,28082,28089,28101,28117,28138,28163,28193,28227,28266,28310,28358,28410,28467,28529,28595,28665,28739,28818,28901,28988,29080,29176,29275,29379,29487,29599,29715,29834,29958,30085,30216,30351,30490,30632,30777,30926,31079,31235,31394,31557,31723,31892,32064,32240,32418,32599,32784,32971,33161,33354,33550,33748,33949,34153,34359,34567,34779,34992,35208,35427,35647,35870,36095,36323,36552,36783,37017,37253,37490,37730,37971,38214,38459,38706,38955,39205,39457,39711,39966,40223,40482,40742,41004,41267,41531,41797,42065,42333,42603,42875,43147,43421,43697,43973,44251,44530,44810,45091,45373,45656,45941,46226,46513,46800,47088,47378,47668,47960,48252,48545,48839,49134,49430,49727,50024,50323,50622,50922,51223,51524,51826,52129,52433,52737,53042,53348,53654,53962,28440,28442,28449,28460,28476,28497,28522,28551,28585,28624,28667,28714,28766,28822,28883,28948,29017,29091,29169,29251,29337,29428,29522,29621,29723,29830,29941,30055,30173,30296,30422,30551,30685,30822,30962,31106,31254,31405,31559,31717,31878,32042,32209,32380,32554,32730,32910,33093,33278,33466,33658,33851,34048,34247,34449,34654,34861,35070,35282,35496,35713,35932,36153,36376,36602,36829,37059,37291,37525,37761,37998,38238,38480,38723,38968,39215,39464,39714,39966,40220,40476,40733,40991,41251,41513,41776,42040,42306,42573,42842,43111,43383,43655,43929,44204,44480,44757,45036,45316,45597,45878,46161,46446,46731,47017,47304,47592,47881,48171,48462,48754,49047,49341,49636,49931,50227,50525,50823,51121,51421,51721,52022,52324,52627,52930,53234,53538,53844,54150,28800,28802,28809,28820,28836,28856,28881,28910,28944,28982,29024,29071,29122,29178,29238,29302,29370,29443,29520,29601,29686,29776,29869,29967,30068,30173,30283,30396,30513,30634,30758,30887,31019,31154,31293,31436,31582,31731,31884,32040,32199,32362,32528,32697,32869,33044,33222,33402,33586,33773,33962,34154,34349,34547,34747,34950,35155,35363,35573,35785,36000,36217,36437,36658,36882,37108,37336,37566,37798,38032,38269,38507,38746,38988,39232,39477,39724,39973,40223,40476,40729,40985,41242,41500,41760,42021,42284,42549,42814,43081,43350,43619,43890,44163,44436,44711,44987,45264,45542,45822,46102,46384,46667,46951,47236,47521,47808,48096,48385,48675,48965,49257,49549,49843,50137,50432,50728,51025,51322,51621,51920,52220,52521,52822,53124,53427,53731,54035,54340,29160,29162,29169,29180,29196,29216,29240,29269,29302,29339,29381,29428,29478,29533,29592,29656,29723,29795,29871,29951,30036,30124,30216,30313,30413,30517,30625,30737,30853,30973,31096,31223,31353,31487,31625,31766,31910,32058,32209,32364,32522,32683,32847,33014,33185,33358,33534,33713,33895,34080,34268,34459,34652,34848,35046,35247,35450,35656,35865,36076,36289,36504,36722,36942,37164,37388,37614,37843,38073,38306,38540,38777,39015,39255,39497,39740,39986,40233,40482,40733,40985,41238,41494,41751,42009,42269,42530,42793,43057,43323,43590,43858,44128,44398,44670,44944,45218,45494,45771,46049,46328,46609,46890,47172,47456,47740,48026,48312,48600,48888,49178,49468,49760,50052,50345,50639,50933,51229,51525,51822,52120,52419,52719,53019,53320,53622,53924,54228,54531,29520,29522,29529,29540,29555,29575,29599,29627,29660,29697,29739,29784,29834,29889,29947,30010,30077,30148,30223,30302,30385,30473,30564,30659,30758,30861,30968,31079,31194,31312,31434,31559,31688,31821,31957,32097,32240,32386,32536,32689,32845,33004,33167,33333,33501,33673,33848,34025,34206,34389,34575,34764,34955,35149,35346,35545,35747,35951,36158,36367,36579,36792,37008,37227,37447,37669,37894,38121,38350,38581,38813,39048,39285,39523,39763,40005,40249,40495,40742,40991,41242,41494,41748,42003,42260,42518,42778,43039,43302,43566,43831,44098,44366,44636,44906,45178,45451,45726,46001,46278,46556,46835,47115,47396,47678,47961,48245,48531,48817,49104,49392,49681,49971,50262,50554,50847,51140,51435,51730,52026,52323,52620,52919,53218,53518,53818,54120,54422,54725,29880,29882,29889,29900,29915,29934,29958,29986,30018,30055,30096,30141,30191,30244,30302,30364,30430,30500,30575,30653,30735,30822,30912,31006,31104,31206,31312,31421,31534,31651,31772,31896,32024,32155,32290,32428,32570,32714,32863,33014,33169,33327,33488,33652,33819,33989,34162,34338,34517,34698,34883,35070,35260,35452,35647,35845,36045,36248,36453,36660,36870,37082,37296,37513,37731,37952,38175,38400,38628,38857,39088,39321,39556,39793,40031,40272,40514,40758,41004,41251,41500,41751,42003,42257,42512,42769,43027,43287,43548,43811,44075,44340,44607,44875,45144,45414,45686,45959,46233,46508,46785,47062,47341,47621,47902,48184,48466,48750,49035,49321,49608,49896,50185,50475,50765,51057,51349,51642,51936,52231,52527,52823,53120,53418,53717,54017,54317,54618,54920,30240,30242,30249,30259,30274,30294,30317,30345,30377,30413,30454,30498,30547,30600,30657,30718,30784,30853,30926,31004,31085,31171,31260,31353,31450,31551,31655,31764,31876,31991,32111,32234,32360,32490,32623,32760,32900,33044,33190,33340,33494,33650,33809,33972,34137,34306,34477,34652,34829,35009,35192,35377,35565,35756,35950,36146,36344,36545,36748,36954,37162,37372,37585,37800,38017,38236,38458,38681,38907,39134,39364,39595,39828,40064,40301,40540,40780,41023,41267,41513,41760,42009,42260,42512,42766,43021,43278,43536,43796,44057,44319,44583,44849,45115,45383,45652,45922,46194,46467,46740,47016,47292,47569,47848,48127,48408,48689,48972,49256,49540,49826,50112,50400,50688,50978,51268,51559,51851,52144,52438,52732,53028,53324,53621,53918,54217,54516,54816,55116,30600,30602,30608,30619,30634,30653,30676,30704,30735,30771,30811,30855,30903,30956,31012,31073,31137,31206,31279,31355,31436,31520,31608,31700,31796,31896,32000,32107,32217,32332,32450,32572,32697,32825,32957,33093,33231,33373,33519,33667,33819,33974,34132,34293,34457,34624,34794,34966,35142,35320,35502,35685,35872,36061,36253,36447,36644,36843,37045,37249,37456,37664,37875,38089,38304,38522,38741,38963,39187,39413,39641,39871,40102,40336,40572,40809,41048,41289,41531,41776,42021,42269,42518,42769,43021,43275,43530,43787,44045,44305,44566,44828,45092,45357,45624,45891,46160,46430,46702,46974,47248,47523,47799,48076,48354,48633,48914,49195,49477,49761,50045,50331,50617,50904,51192,51481,51771,52062,52354,52646,52940,53234,53529,53825,54121,54418,54716,55015,55315,30960,30962,30968,30979,30993,31012,31035,31062,31094,31129,31169,31212,31260,31312,31368,31427,31491,31559,31631,31707,31786,31870,31957,32048,32143,32242,32344,32450,32560,32673,32790,32910,33034,33161,33292,33426,33563,33704,33848,33995,34145,34298,34455,34614,34777,34942,35111,35282,35456,35633,35812,35995,36180,36367,36557,36750,36945,37143,37343,37545,37750,37957,38167,38378,38592,38808,39026,39247,39469,39693,39919,40148,40378,40610,40844,41079,41317,41556,41797,42040,42284,42530,42778,43027,43278,43530,43784,44039,44296,44554,44814,45075,45337,45601,45866,46132,46400,46668,46938,47209,47482,47755,48030,48306,48583,48861,49140,49420,49701,49983,50266,50550,50835,51121,51408,51696,51985,52274,52565,52856,53148,53442,53735,54030,54325,54622,54919,55216,55515,31320,31322,31328,31339,31353,31372,31394,31421,31452,31487,31526,31569,31617,31668,31723,31782,31845,31912,31983,32058,32137,32219,32306,32396,32490,32587,32689,32794,32902,33014,33130,33249,33371,33497,33627,33759,33895,34035,34177,34323,34472,34624,34779,34937,35098,35262,35428,35598,35771,35946,36124,36305,36488,36674,36863,37054,37247,37443,37642,37843,38046,38252,38459,38669,38882,39096,39313,39531,39752,39975,40199,40426,40655,40885,41117,41351,41587,41825,42065,42306,42549,42793,43039,43287,43536,43787,44039,44293,44548,44805,45063,45323,45584,45846,46110,46374,46640,46908,47176,47446,47717,47989,48263,48537,48813,49090,49367,49646,49926,50207,50489,50771,51055,51340,51626,51912,52200,52488,52778,53068,53359,53651,53944,54237,54531,54826,55122,55419,55716,31680,31682,31688,31698,31713,31731,31754,31780,31811,31845,31884,31927,31973,32024,32078,32137,32199,32266,32336,32410,32488,32570,32655,32744,32837,32934,33034,33138,33245,33356,33470,33588,33710,33834,33962,34094,34228,34366,34507,34652,34799,34950,35103,35260,35419,35582,35747,35915,36086,36260,36437,36616,36798,36982,37169,37359,37551,37745,37942,38141,38343,38547,38753,38962,39172,39385,39600,39817,40036,40257,40480,40705,40932,41161,41392,41625,41859,42095,42333,42573,42814,43057,43302,43548,43796,44045,44296,44548,44802,45058,45314,45572,45832,46093,46355,46618,46883,47149,47416,47685,47954,48225,48497,48770,49045,49320,49596,49874,50153,50432,50713,50994,51277,51560,51845,52130,52417,52704,52992,53281,53571,53862,54153,54446,54739,55033,55328,55623,55919,32040,32042,32048,32058,32072,32091,32113,32139,32169,32203,32242,32284,32330,32380,32434,32492,32554,32619,32689,32762,32839,32920,33004,33093,33185,33280,33379,33482,33588,33698,33811,33928,34048,34172,34298,34428,34562,34698,34838,34981,35127,35276,35428,35584,35742,35903,36067,36233,36403,36575,36750,36928,37108,37291,37476,37664,37855,38048,38243,38441,38641,38843,39048,39255,39464,39675,39889,40104,40322,40541,40763,40986,41212,41439,41668,41899,42132,42367,42603,42842,43081,43323,43566,43811,44057,44305,44554,44805,45058,45311,45567,45823,46081,46341,46602,46864,47127,47392,47658,47925,48193,48462,48733,49005,49278,49552,49827,50103,50381,50659,50938,51219,51500,51782,52066,52350,52635,52921,53208,53496,53785,54074,54365,54656,54948,55241,55535,55829,56124,32400,32402,32408,32418,32432,32450,32472,32498,32528,32562,32599,32641,32687,32736,32790,32847,32908,32973,33042,33114,33190,33270,33354,33441,33532,33627,33725,33827,33932,34040,34153,34268,34387,34509,34635,34764,34896,35031,35170,35311,35456,35604,35754,35908,36065,36224,36387,36552,36720,36891,37064,37240,37419,37601,37785,37971,38160,38351,38545,38741,38940,39141,39344,39549,39757,39966,40178,40392,40608,40826,41046,41268,41492,41718,41946,42175,42407,42640,42875,43111,43350,43590,43831,44075,44319,44566,44814,45063,45314,45567,45821,46076,46332,46590,46850,47111,47372,47636,47900,48166,48433,48701,48971,49241,49513,49786,50059,50334,50610,50887,51166,51445,51725,52006,52288,52571,52855,53140,53426,53712,54000,54288,54578,54868,55159,55451,55743,56036,56331,32760,32762,32768,32778,32792,32809,32831,32857,32886,32920,32957,32998,33044,33093,33145,33202,33263,33327,33395,33466,33542,33621,33704,33790,33880,33974,34071,34172,34276,34383,34494,34609,34726,34848,34972,35100,35230,35364,35502,35642,35785,35932,36081,36233,36389,36547,36708,36871,37038,37207,37379,37554,37731,37911,38094,38279,38466,38656,38848,39043,39240,39439,39641,39845,40051,40259,40469,40682,40896,41113,41331,41552,41774,41998,42224,42453,42682,42914,43147,43383,43619,43858,44098,44340,44583,44828,45075,45323,45572,45823,46076,46330,46585,46842,47100,47359,47619,47881,48145,48409,48675,48941,49210,49479,49749,50021,50293,50567,50842,51117,51394,51672,51951,52231,52512,52794,53077,53360,53645,53930,54217,54504,54792,55081,55371,55662,55953,56245,56538,33120,33122,33128,33138,33151,33169,33190,33216,33245,33278,33315,33356,33401,33449,33501,33557,33617,33681,33748,33819,33894,33972,34054,34139,34228,34321,34417,34517,34620,34726,34836,34950,35066,35186,35309,35436,35565,35698,35834,35973,36115,36260,36408,36559,36713,36870,37029,37192,37357,37525,37695,37869,38044,38223,38404,38587,38773,38962,39152,39346,39541,39739,39939,40141,40346,40552,40761,40972,41185,41400,41617,41836,42057,42280,42504,42731,42959,43189,43421,43655,43890,44128,44366,44607,44849,45092,45337,45584,45832,46081,46332,46585,46839,47094,47351,47609,47868,48128,48390,48653,48918,49183,49450,49718,49987,50257,50528,50801,51074,51349,51625,51901,52179,52458,52737,53018,53299,53582,53865,54150,54435,54721,55008,55296,55585,55874,56165,56456,56748,33480,33482,33488,33497,33511,33528,33550,33575,33604,33636,33673,33713,33758,33806,33857,33913,33972,34035,34101,34172,34245,34323,34404,34489,34577,34669,34764,34862,34965,35070,35179,35291,35407,35525,35647,35772,35901,36032,36167,36305,36445,36589,36736,36886,37038,37193,37352,37513,37676,37843,38012,38184,38358,38535,38715,38897,39081,39268,39457,39649,39843,40039,40238,40439,40642,40847,41054,41264,41475,41689,41904,42122,42341,42562,42786,43011,43237,43466,43697,43929,44163,44398,44636,44875,45115,45357,45601,45846,46093,46341,46590,46842,47094,47348,47603,47860,48118,48377,48637,48899,49162,49426,49692,49958,50226,50495,50765,51036,51309,51582,51856,52132,52408,52686,52964,53244,53524,53805,54088,54371,54655,54940,55226,55512,55800,56088,56378,56668,56959,33840,33842,33848,33857,33871,33888,33909,33934,33962,33995,34031,34071,34115,34162,34213,34268,34327,34389,34455,34524,34597,34674,34754,34838,34926,35016,35111,35208,35309,35414,35522,35633,35747,35865,35986,36110,36237,36367,36501,36637,36776,36919,37064,37213,37364,37518,37675,37834,37997,38162,38329,38500,38673,38848,39026,39207,39390,39575,39763,39954,40146,40341,40538,40737,40939,41143,41348,41556,41766,41978,42192,42408,42626,42846,43068,43291,43517,43744,43973,44204,44436,44670,44906,45144,45383,45624,45866,46110,46355,46602,46850,47100,47351,47603,47857,48112,48369,48627,48886,49146,49408,49671,49935,50200,50467,50734,51003,51273,51544,51816,52089,52364,52639,52915,53192,53471,53750,54030,54311,54593,54876,55160,55445,55730,56017,56304,56592,56881,57171,34200,34202,34208,34217,34230,34247,34268,34293,34321,34353,34389,34428,34472,34519,34569,34624,34682,34743,34808,34877,34950,35026,35105,35188,35274,35364,35458,35554,35655,35758,35865,35975,36088,36205,36324,36447,36573,36702,36835,36970,37108,37249,37393,37540,37690,37843,37998,38157,38318,38481,38648,38817,38988,39162,39339,39518,39700,39884,40070,40259,40450,40643,40839,41037,41237,41439,41643,41850,42058,42269,42482,42696,42913,43131,43351,43573,43797,44023,44251,44480,44711,44944,45178,45414,45652,45891,46132,46374,46618,46864,47111,47359,47609,47860,48112,48366,48621,48878,49136,49395,49655,49917,50180,50444,50709,50975,51243,51511,51781,52052,52324,52597,52871,53146,53422,53699,53977,54256,54536,54817,55099,55382,55665,55950,56235,56521,56808,57096,57385,34560,34562,34567,34577,34590,34607,34627,34652,34680,34712,34747,34786,34829,34875,34926,34979,35037,35098,35162,35230,35302,35377,35456,35538,35624,35713,35805,35901,36000,36102,36208,36317,36429,36545,36663,36785,36910,37038,37169,37303,37440,37580,37723,37869,38017,38168,38323,38480,38639,38802,38967,39134,39304,39477,39652,39830,40010,40193,40378,40565,40755,40947,41141,41337,41536,41737,41940,42145,42352,42561,42772,42985,43200,43417,43636,43857,44079,44303,44530,44757,44987,45218,45451,45686,45922,46160,46400,46640,46883,47127,47372,47619,47868,48118,48369,48621,48875,49130,49387,49645,49904,50164,50426,50688,50952,51218,51484,51751,52020,52289,52560,52832,53105,53378,53653,53929,54206,54484,54763,55042,55323,55605,55887,56170,56455,56740,57026,57312,57600,34920,34922,34927,34937,34950,34966,34987,35011,35039,35070,35105,35144,35186,35232,35282,35335,35392,35452,35516,35584,35655,35729,35807,35888,35973,36061,36153,36248,36346,36447,36552,36660,36771,36886,37003,37124,37247,37374,37504,37637,37773,37911,38053,38197,38345,38495,38648,38803,38962,39123,39286,39452,39621,39793,39966,40143,40322,40503,40686,40872,41061,41251,41444,41639,41836,42035,42237,42440,42646,42854,43063,43275,43489,43704,43921,44141,44362,44585,44810,45036,45264,45494,45726,45959,46194,46430,46668,46908,47149,47392,47636,47881,48128,48377,48627,48878,49130,49384,49640,49896,50154,50413,50673,50935,51197,51461,51726,51992,52260,52528,52797,53068,53340,53612,53886,54161,54436,54713,54991,55269,55549,55829,56110,56393,56676,56960,57245,57530,57817,35280,35282,35287,35297,35309,35326,35346,35370,35397,35428,35463,35502,35544,35589,35638,35691,35747,35807,35870,35937,36007,36081,36158,36239,36323,36410,36501,36594,36692,36792,36896,37003,37113,37227,37343,37462,37585,37711,37839,37971,38106,38243,38383,38527,38673,38822,38973,39128,39285,39444,39607,39771,39939,40109,40281,40456,40634,40814,40996,41180,41367,41556,41748,41941,42137,42335,42535,42737,42941,43147,43356,43566,43778,43992,44208,44426,44646,44867,45091,45316,45542,45771,46001,46233,46467,46702,46938,47176,47416,47658,47900,48145,48390,48637,48886,49136,49387,49640,49893,50149,50405,50663,50922,51182,51443,51706,51970,52235,52501,52768,53036,53306,53576,53847,54120,54393,54668,54943,55220,55497,55776,56055,56335,56616,56898,57181,57465,57749,58035,35640,35642,35647,35656,35669,35685,35705,35729,35756,35787,35821,35859,35901,35946,35995,36047,36102,36162,36224,36290,36360,36433,36509,36589,36672,36759,36849,36942,37038,37138,37240,37346,37456,37568,37683,37802,37923,38048,38175,38306,38439,38575,38715,38857,39001,39149,39299,39452,39608,39767,39928,40091,40257,40426,40597,40771,40947,41125,41306,41489,41675,41862,42052,42244,42439,42635,42834,43035,43237,43442,43649,43858,44069,44281,44496,44713,44931,45151,45373,45597,45822,46049,46278,46508,46740,46974,47209,47446,47685,47925,48166,48409,48653,48899,49146,49395,49645,49896,50149,50403,50658,50914,51172,51431,51691,51952,52215,52479,52743,53009,53276,53544,53814,54084,54355,54628,54901,55175,55451,55727,56004,56282,56561,56841,57122,57404,57687,57970,58254,36000,36002,36007,36016,36029,36045,36065,36088,36115,36146,36180,36217,36258,36303,36351,36403,36458,36516,36579,36644,36713,36785,36861,36940,37022,37108,37197,37289,37385,37483,37585,37690,37798,37910,38024,38141,38262,38385,38512,38641,38773,38908,39046,39187,39331,39477,39626,39778,39932,40090,40249,40412,40576,40744,40913,41086,41260,41438,41617,41799,41983,42169,42358,42549,42742,42937,43134,43333,43535,43738,43944,44151,44360,44572,44785,45000,45217,45436,45656,45878,46102,46328,46556,46785,47016,47248,47482,47717,47954,48193,48433,48675,48918,49162,49408,49655,49904,50154,50405,50658,50912,51167,51423,51681,51940,52200,52461,52724,52987,53252,53518,53785,54053,54322,54592,54863,55135,55408,55683,55958,56234,56511,56789,57068,57347,57628,57910,58192,58475,36360,36362,36367,36376,36389,36405,36424,36447,36474,36504,36538,36575,36616,36660,36708,36759,36813,36871,36933,36998,37066,37138,37213,37291,37372,37457,37545,37637,37731,37829,37930,38034,38141,38252,38365,38481,38601,38723,38848,38977,39108,39242,39378,39518,39660,39806,39954,40104,40257,40413,40572,40733,40896,41062,41231,41402,41575,41751,41929,42109,42292,42477,42664,42854,43045,43239,43435,43633,43833,44035,44239,44445,44653,44863,45075,45289,45504,45721,45941,46161,46384,46609,46835,47062,47292,47523,47755,47989,48225,48462,48701,48941,49183,49426,49671,49917,50164,50413,50663,50914,51167,51421,51676,51932,52190,52449,52709,52970,53233,53496,53761,54026,54293,54561,54830,55100,55371,55643,55916,56190,56465,56741,57018,57295,57574,57854,58134,58415,58698,36720,36722,36727,36736,36748,36764,36783,36806,36833,36863,36896,36933,36973,37017,37064,37115,37169,37227,37287,37352,37419,37490,37564,37642,37723,37807,37894,37985,38078,38175,38275,38378,38485,38594,38706,38822,38940,39061,39185,39313,39443,39575,39711,39850,39991,40135,40281,40431,40583,40737,40894,41054,41216,41381,41548,41718,41890,42065,42241,42420,42602,42786,42971,43159,43350,43542,43737,43933,44132,44333,44535,44740,44947,45155,45366,45578,45792,46008,46226,46446,46667,46890,47115,47341,47569,47799,48030,48263,48497,48733,48971,49210,49450,49692,49935,50180,50426,50673,50922,51172,51423,51676,51930,52185,52442,52699,52958,53218,53479,53741,54005,54269,54535,54802,55069,55338,55608,55879,56151,56424,56697,56972,57248,57525,57802,58081,58360,58640,58921,37080,37082,37087,37096,37108,37124,37143,37166,37192,37221,37254,37291,37331,37374,37421,37471,37525,37582,37642,37706,37773,37843,37916,37993,38073,38157,38243,38333,38426,38522,38621,38723,38828,38937,39048,39162,39280,39400,39523,39649,39778,39910,40044,40182,40322,40464,40610,40758,40909,41062,41218,41377,41538,41701,41867,42035,42206,42379,42555,42732,42913,43095,43279,43466,43655,43846,44039,44235,44432,44631,44833,45036,45241,45448,45658,45869,46081,46296,46513,46731,46951,47172,47396,47621,47848,48076,48306,48537,48770,49005,49241,49479,49718,49958,50200,50444,50688,50935,51182,51431,51681,51932,52185,52439,52694,52951,53208,53467,53727,53988,54250,54514,54778,55044,55310,55578,55846,56116,56387,56659,56931,57205,57479,57755,58032,58309,58587,58866,59146,37440,37442,37447,37456,37468,37483,37502,37525,37551,37580,37613,37649,37688,37731,37778,37827,37880,37937,37997,38060,38126,38196,38269,38345,38424,38507,38592,38681,38773,38868,38967,39068,39172,39280,39390,39503,39620,39739,39861,39986,40114,40244,40378,40514,40653,40795,40939,41086,41235,41387,41542,41699,41859,42021,42186,42353,42523,42695,42869,43045,43224,43405,43588,43774,43961,44151,44343,44537,44733,44931,45131,45333,45537,45743,45950,46160,46372,46585,46800,47017,47236,47456,47678,47902,48127,48354,48583,48813,49045,49278,49513,49749,49987,50226,50467,50709,50952,51197,51443,51691,51940,52190,52442,52694,52948,53203,53460,53717,53976,54236,54497,54759,55022,55287,55552,55819,56086,56355,56624,56895,57166,57439,57712,57987,58262,58538,58816,59094,59373,37800,37802,37807,37815,37827,37843,37862,37884,37910,37939,37971,38007,38046,38089,38135,38184,38236,38292,38351,38414,38480,38549,38621,38696,38775,38857,38942,39030,39121,39215,39313,39413,39516,39623,39732,39845,39960,40078,40199,40323,40450,40580,40712,40847,40985,41125,41268,41414,41562,41713,41867,42023,42181,42342,42506,42672,42840,43011,43183,43359,43536,43716,43898,44082,44268,44457,44647,44840,45035,45231,45430,45631,45833,46038,46244,46453,46663,46875,47088,47304,47521,47740,47961,48184,48408,48633,48861,49090,49320,49552,49786,50021,50257,50495,50734,50975,51218,51461,51706,51952,52200,52449,52699,52951,53203,53457,53712,53969,54226,54485,54745,55006,55268,55531,55795,56061,56327,56594,56863,57132,57403,57674,57947,58220,58494,58769,59045,59322,59600,38160,38162,38167,38175,38187,38202,38221,38243,38269,38297,38329,38365,38404,38446,38491,38540,38592,38648,38706,38768,38833,38902,38973,39048,39126,39207,39291,39378,39469,39562,39659,39758,39861,39966,40075,40186,40301,40418,40538,40661,40787,40915,41046,41180,41317,41456,41598,41743,41890,42040,42192,42347,42504,42664,42826,42991,43158,43327,43499,43673,43849,44028,44208,44391,44576,44763,44952,45144,45337,45533,45730,45929,46131,46334,46539,46746,46955,47165,47378,47592,47808,48026,48245,48466,48689,48914,49140,49367,49596,49827,50059,50293,50528,50765,51003,51243,51484,51726,51970,52215,52461,52709,52958,53208,53460,53712,53966,54222,54478,54735,54994,55254,55515,55777,56040,56304,56569,56836,57103,57371,57640,57911,58182,58454,58727,59002,59277,59553,59829,38520,38522,38527,38535,38547,38562,38581,38602,38628,38656,38688,38723,38761,38803,38848,38897,38948,39003,39061,39123,39187,39255,39326,39400,39477,39557,39641,39727,39817,39910,40005,40104,40206,40310,40418,40528,40642,40758,40877,40999,41124,41251,41381,41514,41650,41788,41929,42072,42218,42367,42518,42672,42828,42986,43147,43311,43477,43645,43815,43988,44163,44340,44519,44701,44885,45071,45258,45448,45641,45835,46031,46229,46429,46631,46835,47040,47248,47457,47668,47881,48096,48312,48531,48750,48972,49195,49420,49646,49874,50103,50334,50567,50801,51036,51273,51511,51751,51992,52235,52479,52724,52970,53218,53467,53717,53969,54222,54476,54731,54987,55244,55503,55763,56024,56286,56549,56813,57078,57344,57611,57879,58149,58419,58690,58962,59235,59509,59784,60060,38880,38882,38887,38895,38907,38922,38940,38962,38987,39015,39046,39081,39119,39161,39205,39253,39304,39359,39416,39477,39541,39608,39678,39752,39828,39908,39991,40077,40165,40257,40352,40450,40551,40655,40761,40871,40983,41098,41216,41337,41461,41587,41717,41848,41983,42120,42260,42402,42547,42695,42845,42997,43152,43309,43469,43631,43796,43963,44132,44303,44477,44653,44831,45012,45194,45379,45565,45754,45945,46138,46332,46529,46728,46929,47131,47336,47542,47750,47960,48171,48385,48600,48817,49035,49256,49477,49701,49926,50153,50381,50610,50842,51074,51309,51544,51781,52020,52260,52501,52743,52987,53233,53479,53727,53976,54226,54478,54731,54985,55240,55496,55754,56012,56272,56533,56794,57057,57321,57586,57853,58120,58388,58657,58927,59198,59470,59743,60016,60291,39240,39242,39247,39255,39266,39281,39299,39321,39346,39374,39405,39439,39477,39518,39562,39610,39660,39714,39771,39832,39895,39962,40031,40104,40180,40259,40341,40426,40514,40605,40699,40796,40896,40999,41105,41213,41325,41439,41556,41676,41799,41924,42052,42183,42316,42453,42591,42732,42876,43023,43171,43323,43477,43633,43791,43952,44116,44281,44449,44620,44792,44967,45144,45323,45504,45687,45873,46060,46250,46441,46635,46830,47028,47227,47429,47632,47837,48043,48252,48462,48675,48888,49104,49321,49540,49761,49983,50207,50432,50659,50887,51117,51349,51582,51816,52052,52289,52528,52768,53009,53252,53496,53741,53988,54236,54485,54735,54987,55240,55494,55749,56005,56263,56521,56781,57042,57303,57566,57830,58095,58361,58628,58896,59165,59435,59706,59978,60250,60524,39600,39602,39607,39615,39626,39641,39659,39680,39705,39732,39763,39798,39835,39876,39919,39966,40017,40070,40127,40186,40249,40315,40384,40456,40532,40610,40691,40775,40863,40953,41046,41143,41242,41344,41448,41556,41667,41780,41896,42015,42137,42261,42388,42518,42651,42786,42923,43063,43206,43351,43499,43649,43802,43957,44114,44274,44436,44601,44768,44937,45108,45281,45457,45635,45815,45997,46181,46367,46556,46746,46938,47133,47329,47527,47727,47929,48132,48338,48545,48754,48965,49178,49392,49608,49826,50045,50266,50489,50713,50938,51166,51394,51625,51856,52089,52324,52560,52797,53036,53276,53518,53761,54005,54250,54497,54745,54994,55244,55496,55749,56003,56258,56514,56772,57030,57290,57550,57812,58075,58339,58604,58870,59137,59404,59673,59943,60214,60485,60758,39960,39962,39966,39975,39986,40001,40018,40039,40064,40091,40122,40156,40193,40233,40277,40323,40373,40426,40482,40541,40603,40669,40737,40809,40883,40961,41042,41125,41212,41301,41394,41489,41587,41689,41793,41899,42009,42122,42237,42355,42475,42599,42725,42854,42985,43119,43255,43395,43536,43680,43827,43976,44128,44281,44438,44596,44757,44921,45086,45254,45424,45597,45771,45948,46126,46307,46490,46675,46862,47051,47242,47435,47630,47827,48026,48227,48429,48633,48839,49047,49257,49468,49681,49896,50112,50331,50550,50771,50994,51219,51445,51672,51901,52132,52364,52597,52832,53068,53306,53544,53785,54026,54269,54514,54759,55006,55254,55503,55754,56005,56258,56512,56767,57023,57281,57539,57799,58059,58321,58584,58848,59112,59378,59645,59913,60181,60451,60722,60993,40320,40322,40326,40334,40346,40360,40378,40399,40423,40450,40480,40514,40551,40591,40634,40680,40729,40782,40837,40896,40958,41023,41090,41161,41235,41312,41392,41475,41561,41650,41741,41836,41933,42034,42137,42243,42352,42463,42578,42695,42814,42937,43062,43189,43320,43453,43588,43726,43867,44010,44155,44303,44454,44607,44762,44919,45079,45241,45406,45572,45741,45912,46086,46261,46439,46618,46800,46984,47170,47357,47547,47739,47933,48128,48326,48525,48727,48930,49134,49341,49549,49760,49971,50185,50400,50617,50835,51055,51277,51500,51725,51951,52179,52408,52639,52871,53105,53340,53576,53814,54053,54293,54535,54778,55022,55268,55515,55763,56012,56263,56514,56767,57021,57276,57532,57790,58048,58308,58568,58830,59093,59356,59621,59887,60153,60421,60690,60959,61230,40680,40682,40686,40694,40705,40720,40737,40758,40782,40809,40839,40872,40909,40948,40991,41037,41086,41138,41193,41251,41312,41377,41444,41514,41587,41664,41743,41825,41910,41998,42089,42183,42280,42379,42482,42587,42695,42805,42919,43035,43153,43275,43399,43526,43655,43787,43921,44058,44198,44340,44484,44631,44781,44932,45086,45243,45401,45562,45726,45891,46059,46229,46401,46575,46752,46930,47111,47293,47478,47664,47853,48043,48236,48430,48627,48825,49025,49227,49430,49636,49843,50052,50262,50475,50688,50904,51121,51340,51560,51782,52006,52231,52458,52686,52915,53146,53378,53612,53847,54084,54322,54561,54802,55044,55287,55531,55777,56024,56272,56521,56772,57023,57276,57530,57785,58042,58299,58557,58817,59077,59339,59601,59865,60130,60395,60662,60929,61198,61467,41040,41042,41046,41054,41065,41079,41097,41117,41141,41168,41198,41231,41267,41306,41348,41394,41442,41494,41548,41606,41667,41731,41797,41867,41940,42015,42094,42175,42260,42347,42437,42530,42626,42725,42826,42931,43038,43147,43260,43375,43493,43614,43737,43862,43991,44122,44255,44391,44530,44670,44814,44960,45108,45258,45411,45567,45724,45884,46046,46211,46377,46546,46717,46890,47065,47242,47422,47603,47787,47972,48159,48349,48540,48733,48928,49125,49324,49525,49727,49931,50137,50345,50554,50765,50978,51192,51408,51626,51845,52066,52288,52512,52737,52964,53192,53422,53653,53886,54120,54355,54592,54830,55069,55310,55552,55795,56040,56286,56533,56781,57030,57281,57532,57785,58039,58294,58551,58808,59066,59326,59586,59848,60110,60374,60638,60904,61170,61438,61706,41400,41402,41406,41414,41425,41439,41456,41477,41500,41527,41556,41589,41625,41664,41706,41751,41799,41850,41904,41961,42021,42085,42151,42220,42292,42367,42445,42526,42609,42696,42786,42878,42973,43071,43171,43275,43381,43490,43602,43716,43833,43952,44075,44199,44327,44457,44589,44724,44862,45001,45144,45289,45436,45585,45737,45891,46048,46206,46367,46531,46696,46864,47033,47205,47379,47555,47734,47914,48096,48280,48466,48655,48845,49037,49231,49426,49624,49823,50024,50227,50432,50639,50847,51057,51268,51481,51696,51912,52130,52350,52571,52794,53018,53244,53471,53699,53929,54161,54393,54628,54863,55100,55338,55578,55819,56061,56304,56549,56794,57042,57290,57539,57790,58042,58294,58548,58804,59060,59317,59575,59835,60095,60357,60619,60883,61147,61412,61679,61946,41760,41762,41766,41774,41785,41799,41816,41836,41859,41886,41915,41947,41983,42021,42063,42108,42155,42206,42260,42316,42376,42439,42504,42573,42644,42719,42796,42876,42959,43045,43134,43225,43320,43417,43517,43619,43725,43833,43944,44057,44173,44292,44413,44537,44663,44792,44924,45058,45194,45333,45474,45618,45764,45912,46063,46216,46372,46529,46689,46851,47016,47182,47351,47521,47694,47869,48046,48225,48406,48589,48774,48961,49150,49341,49534,49728,49925,50123,50323,50525,50728,50933,51140,51349,51559,51771,51985,52200,52417,52635,52855,53077,53299,53524,53750,53977,54206,54436,54668,54901,55135,55371,55608,55846,56086,56327,56569,56813,57057,57303,57550,57799,58048,58299,58551,58804,59058,59313,59569,59826,60084,60344,60604,60866,61128,61391,61656,61921,62187,42120,42122,42126,42134,42145,42158,42175,42195,42218,42244,42274,42306,42341,42379,42420,42465,42512,42562,42616,42672,42731,42793,42858,42926,42997,43071,43147,43227,43309,43395,43483,43573,43667,43763,43862,43964,44069,44176,44286,44398,44514,44631,44752,44875,45000,45128,45258,45391,45527,45665,45805,45948,46093,46240,46390,46542,46696,46853,47011,47172,47336,47501,47668,47838,48010,48184,48359,48537,48717,48899,49083,49269,49456,49646,49838,50031,50226,50423,50622,50823,51025,51229,51435,51642,51851,52062,52274,52488,52704,52921,53140,53360,53582,53805,54030,54256,54484,54713,54943,55175,55408,55643,55879,56116,56355,56594,56836,57078,57321,57566,57812,58059,58308,58557,58808,59060,59313,59567,59822,60078,60335,60593,60853,61113,61374,61637,61900,62164,62430,42480,42482,42486,42494,42504,42518,42535,42555,42578,42603,42632,42664,42699,42737,42778,42822,42869,42919,42971,43027,43086,43147,43212,43279,43350,43423,43499,43578,43660,43744,43831,43921,44014,44110,44208,44309,44413,44519,44628,44740,44854,44971,45091,45213,45337,45464,45594,45726,45860,45997,46136,46278,46422,46568,46717,46868,47021,47176,47334,47494,47656,47820,47987,48155,48326,48499,48673,48850,49029,49210,49392,49577,49763,49952,50142,50334,50528,50724,50922,51121,51322,51525,51730,51936,52144,52354,52565,52778,52992,53208,53426,53645,53865,54088,54311,54536,54763,54991,55220,55451,55683,55916,56151,56387,56624,56863,57103,57344,57586,57830,58075,58321,58568,58817,59066,59317,59569,59822,60076,60331,60587,60844,61103,61362,61622,61883,62146,62409,62673,42840,42842,42846,42854,42864,42878,42894,42914,42937,42962,42991,43023,43057,43095,43135,43179,43225,43275,43327,43383,43441,43502,43566,43633,43703,43775,43851,43929,44010,44094,44180,44270,44362,44457,44554,44655,44757,44863,44971,45082,45195,45311,45430,45551,45675,45801,45929,46060,46194,46330,46468,46609,46752,46897,47044,47194,47347,47501,47658,47816,47977,48140,48306,48473,48643,48814,48988,49163,49341,49521,49702,49886,50071,50258,50448,50639,50831,51026,51223,51421,51621,51822,52026,52231,52438,52646,52856,53068,53281,53496,53712,53930,54150,54371,54593,54817,55042,55269,55497,55727,55958,56190,56424,56659,56895,57132,57371,57611,57853,58095,58339,58584,58830,59077,59326,59575,59826,60078,60331,60585,60840,61096,61353,61612,61871,62131,62392,62654,62918,43200,43201,43206,43213,43224,43237,43254,43273,43296,43321,43350,43381,43415,43453,43493,43536,43582,43631,43683,43738,43796,43857,43920,43986,44056,44128,44202,44280,44360,44444,44530,44618,44710,44804,44901,45000,45102,45207,45314,45424,45537,45652,45770,45890,46012,46138,46265,46395,46528,46663,46800,46940,47082,47226,47372,47521,47672,47826,47981,48139,48299,48461,48625,48792,48960,49130,49303,49477,49654,49832,50013,50195,50379,50566,50754,50943,51135,51329,51524,51721,51920,52120,52323,52527,52732,52940,53148,53359,53571,53785,54000,54217,54435,54655,54876,55099,55323,55549,55776,56004,56234,56465,56697,56931,57166,57403,57640,57879,58120,58361,58604,58848,59093,59339,59586,59835,60084,60335,60587,60840,61094,61349,61605,61862,62121,62380,62640,62901,63163,43560,43561,43566,43573,43584,43597,43614,43633,43655,43680,43709,43740,43774,43811,43851,43893,43939,43988,44039,44094,44151,44211,44274,44340,44409,44480,44554,44631,44711,44794,44879,44967,45058,45151,45247,45346,45447,45551,45658,45767,45878,45993,46110,46229,46351,46475,46602,46731,46862,46996,47133,47271,47412,47555,47701,47849,47999,48151,48306,48462,48621,48782,48945,49111,49278,49447,49619,49792,49967,50145,50324,50505,50688,50873,51060,51249,51440,51632,51826,52022,52220,52419,52620,52823,53028,53234,53442,53651,53862,54074,54288,54504,54721,54940,55160,55382,55605,55829,56055,56282,56511,56741,56972,57205,57439,57674,57911,58149,58388,58628,58870,59112,59356,59601,59848,60095,60344,60593,60844,61096,61349,61603,61858,62114,62371,62630,62889,63149,63410,43920,43921,43926,43933,43944,43957,43973,43992,44014,44039,44067,44098,44132,44169,44208,44251,44296,44344,44395,44449,44506,44566,44628,44694,44762,44833,44906,44983,45062,45144,45228,45316,45406,45498,45594,45692,45792,45895,46001,46110,46220,46334,46450,46568,46689,46812,46938,47066,47197,47330,47465,47603,47743,47885,48030,48177,48326,48477,48631,48786,48944,49104,49266,49430,49596,49765,49935,50107,50282,50458,50636,50816,50998,51182,51368,51555,51745,51936,52129,52324,52521,52719,52919,53120,53324,53529,53735,53944,54153,54365,54578,54792,55008,55226,55445,55665,55887,56110,56335,56561,56789,57018,57248,57479,57712,57947,58182,58419,58657,58896,59137,59378,59621,59865,60110,60357,60604,60853,61103,61353,61605,61858,62112,62367,62623,62881,63139,63398,63658,44280,44281,44286,44293,44303,44317,44333,44352,44374,44398,44426,44457,44490,44527,44566,44608,44653,44701,44752,44805,44862,44921,44983,45047,45115,45185,45258,45334,45413,45494,45578,45665,45754,45846,45941,46038,46138,46240,46345,46453,46563,46675,46790,46908,47028,47150,47275,47403,47532,47664,47799,47935,48074,48216,48359,48505,48653,48804,48956,49111,49267,49426,49587,49750,49916,50083,50252,50423,50596,50771,50949,51128,51309,51491,51676,51862,52051,52241,52433,52627,52822,53019,53218,53418,53621,53825,54030,54237,54446,54656,54868,55081,55296,55512,55730,55950,56170,56393,56616,56841,57068,57295,57525,57755,57987,58220,58454,58690,58927,59165,59404,59645,59887,60130,60374,60619,60866,61113,61362,61612,61862,62114,62367,62621,62876,63133,63390,63648,63907,44640,44641,44646,44653,44663,44676,44692,44711,44733,44757,44785,44815,44849,44885,44924,44965,45010,45058,45108,45161,45217,45276,45337,45401,45468,45538,45611,45686,45764,45845,45928,46014,46102,46194,46288,46384,46483,46585,46689,46796,46905,47017,47131,47248,47367,47489,47613,47739,47868,47999,48132,48268,48406,48547,48689,48834,48981,49130,49282,49435,49591,49749,49909,50071,50235,50401,50569,50740,50912,51086,51262,51440,51620,51801,51985,52170,52357,52546,52737,52930,53124,53320,53518,53717,53918,54121,54325,54531,54739,54948,55159,55371,55585,55800,56017,56235,56455,56676,56898,57122,57347,57574,57802,58032,58262,58494,58727,58962,59198,59435,59673,59913,60153,60395,60638,60883,61128,61374,61622,61871,62121,62371,62623,62876,63130,63386,63642,63899,64157,45000,45001,45006,45013,45023,45036,45052,45071,45092,45116,45144,45174,45207,45243,45281,45323,45367,45414,45464,45517,45572,45631,45692,45755,45822,45891,45963,46038,46115,46195,46278,46363,46451,46542,46635,46731,46829,46930,47033,47139,47248,47359,47472,47588,47706,47827,47950,48076,48204,48334,48466,48601,48738,48878,49020,49163,49309,49458,49608,49761,49916,50072,50231,50392,50555,50720,50887,51057,51228,51401,51576,51752,51931,52112,52294,52479,52665,52853,53042,53234,53427,53622,53818,54017,54217,54418,54622,54826,55033,55241,55451,55662,55874,56088,56304,56521,56740,56960,57181,57404,57628,57854,58081,58309,58538,58769,59002,59235,59470,59706,59943,60181,60421,60662,60904,61147,61391,61637,61883,62131,62380,62630,62881,63133,63386,63640,63895,64151,64408,45360,45361,45366,45373,45383,45396,45411,45430,45451,45476,45503,45533,45565,45601,45639,45680,45724,45771,45821,45873,45928,45986,46046,46110,46176,46244,46316,46390,46467,46546,46628,46713,46800,46890,46982,47077,47175,47275,47378,47483,47591,47701,47814,47929,48046,48166,48288,48413,48540,48669,48801,48935,49071,49210,49350,49493,49638,49786,49935,50087,50240,50396,50554,50714,50876,51040,51206,51374,51544,51716,51890,52066,52243,52423,52604,52788,52973,53159,53348,53538,53731,53924,54120,54317,54516,54716,54919,55122,55328,55535,55743,55953,56165,56378,56592,56808,57026,57245,57465,57687,57910,58134,58360,58587,58816,59045,59277,59509,59743,59978,60214,60451,60690,60929,61170,61412,61656,61900,62146,62392,62640,62889,63139,63390,63642,63895,64149,64404,64660,45720,45721,45726,45733,45743,45755,45771,45789,45811,45835,45862,45891,45924,45959,45997,46038,46081,46128,46177,46229,46283,46341,46401,46464,46529,46597,46668,46742,46818,46897,46978,47062,47149,47238,47330,47424,47521,47621,47723,47827,47934,48043,48155,48270,48386,48505,48627,48750,48877,49005,49136,49269,49404,49542,49681,49823,49967,50114,50262,50413,50566,50720,50877,51036,51197,51360,51525,51692,51861,52032,52205,52380,52556,52735,52915,53097,53281,53467,53654,53844,54035,54228,54422,54618,54816,55015,55216,55419,55623,55829,56036,56245,56456,56668,56881,57096,57312,57530,57749,57970,58192,58415,58640,58866,59094,59322,59553,59784,60016,60250,60485,60722,60959,61198,61438,61679,61921,62164,62409,62654,62901,63149,63398,63648,63899,64151,64404,64658,64913,46080,46081,46086,46093,46102,46115,46131,46149,46170,46194,46220,46250,46282,46317,46355,46395,46439,46485,46533,46585,46639,46696,46756,46818,46883,46951,47021,47094,47170,47248,47329,47412,47498,47587,47678,47772,47868,47967,48068,48171,48278,48386,48497,48611,48727,48845,48965,49088,49213,49341,49471,49603,49737,49874,50013,50154,50297,50442,50590,50740,50891,51045,51201,51359,51519,51681,51845,52011,52179,52349,52521,52694,52870,53047,53226,53408,53590,53775,53962,54150,54340,54531,54725,54920,55116,55315,55515,55716,55919,56124,56331,56538,56748,56959,57171,57385,57600,57817,58035,58254,58475,58698,58921,59146,59373,59600,59829,60060,60291,60524,60758,60993,61230,61467,61706,61946,62187,62430,62673,62918,63163,63410,63658,63907,64157,64408,64660,64913,65167,
};

/**
 * \typedef struct modeS_message
 * The structure we use to store information about a decoded message.
 */
typedef struct modeS_message {
    uint8_t  msg[MODES_LONG_MSG_BYTES]; /**< Binary message. */
    int      msg_bits;                   /**< Number of bits in message */
    int      msg_type;                   /**< Downlink format # */
    bool     CRC_ok;                     /**< True if CRC was valid */
    uint32_t CRC;                        /**< Message CRC */
    double   sig_level;                  /**< RSSI, in the range [0..1], as a fraction of full-scale power */
    int      error_bit;                  /**< Bit corrected. -1 if no bit corrected. */
    int      AA1, AA2, AA3;              /**< ICAO Address bytes 1, 2 and 3 */
    bool     phase_corrected;            /**< True if phase correction was applied. */

    /** DF11
     */
    int ca;                              /**< Responder capabilities. */

    /** DF 17
     */
    int  ME_type;                        /**< Extended squitter message type. */
    int  ME_subtype;                     /**< Extended squitter message subtype. */
    int  heading;                        /**< Horizontal angle of flight. */
    bool heading_is_valid;
    int  aircraft_type;
    int  odd_flag;                       /**< 1 = Odd, 0 = Even CPR message. */
    int  UTC_flag;                       /**< UTC synchronized? */
    int  raw_latitude;                   /**< Non decoded latitude */
    int  raw_longitude;                  /**< Non decoded longitude */
    char flight[9];                     /**< 8 chars flight number. */
    int  EW_dir;                         /**< 0 = East, 1 = West. */
    int  EW_velocity;                    /**< E/W velocity. */
    int  NS_dir;                         /**< 0 = North, 1 = South. */
    int  NS_velocity;                    /**< N/S velocity. */
    int  vert_rate_source;               /**< Vertical rate source. */
    int  vert_rate_sign;                 /**< Vertical rate sign. */
    int  vert_rate;                      /**< Vertical rate. */
    int  velocity;                       /**< Computed from EW and NS velocity. */

    /** DF4, DF5, DF20, DF21
     */
    int flight_status;                   /**< Flight status for DF4, 5, 20 and 21 */
    int DR_status;                       /**< Request extraction of downlink request. */
    int UM_status;                       /**< Request extraction of downlink request. */
    int identity;                        /**< 13 bits identity (Squawk). */

    /** Fields used by multiple message types.
     */
    int altitude, unit;
} modeS_message;

aircraft* interactive_receive_data(const modeS_message* mm, uint64_t now);
void      modeS_send_raw_output(const modeS_message* mm);
void      modeS_send_SBS_output(const modeS_message* mm, const aircraft* a);
void      modeS_user_message(const modeS_message* mm);
void      set_est_home_distance(aircraft* a, uint64_t now);
void      spherical_to_cartesian(cartesian_t* cart, pos_t point);
bool      ICAO_is_military(uint32_t addr);

int       fix_single_bit_errors(uint8_t* msg, int bits);
int       fix_two_bits_errors(uint8_t* msg, int bits);
int       detect_modeS(void);
void      decode_hex_message(mg_iobuf* msg, int loop_cnt);
void      decode_SBS_message(mg_iobuf* msg, int loop_cnt);
int       modeS_message_len_by_type(int type);
void compute_magnitude_vector(void);
bool      background_tasks(void);
void      modeS_exit(void);
void      sigint_handler(int sig);

u_short        handler_port(intptr_t service);
const char* handler_descr(intptr_t service);
mg_connection* handler_conn(intptr_t service);
void           connection_read(connection* conn, msg_handler handler, bool is_server);
void           connection_send(intptr_t service, const void* msg, size_t len);
connection* connection_get_addr(const mg_addr* addr, intptr_t service, bool is_server);
void           connection_free(connection* this_conn, intptr_t service);
unsigned       connection_free_all(void);

static CONSOLE_SCREEN_BUFFER_INFO console_info;
static HANDLE console_hnd = INVALID_HANDLE_VALUE;
static DWORD  console_mode = 0;
static bool   dev_selection_done = false;

#define COLOUR_GREEN  10  /* bright green; FOREGROUND_INTENSITY + 2 */
#define COLOUR_RED    12  /* bright red;   FOREGROUND_INTENSITY + 4 */
#define COLOUR_WHITE  15  /* bright white; FOREGROUND_INTENSITY + 7 */

static void gotoxy(int x, int y)
{
    COORD coord = { 0,0 };

    if (console_hnd == INVALID_HANDLE_VALUE)
        return;

    coord.X = x - 1 + console_info.srWindow.Left;
    coord.Y = y - 1 + console_info.srWindow.Top;
    SetConsoleCursorPosition(console_hnd, coord);
}

static void clrscr(void)
{
    WORD width = console_info.srWindow.Right - console_info.srWindow.Left + 1;
    WORD y = console_info.srWindow.Top;

    while (y <= console_info.srWindow.Bottom)
    {
        DWORD written;
        COORD coord = { console_info.srWindow.Left, y++ };

        FillConsoleOutputCharacter(console_hnd, ' ', width, coord, &written);
        FillConsoleOutputAttribute(console_hnd, console_info.wAttributes, width, coord, &written);
    }
}

void setcolor(int color)
{
    WORD attr;

    if (console_hnd == INVALID_HANDLE_VALUE)
        return;

    attr = console_info.wAttributes;
    if (color > 0)
    {
        attr &= ~7;
        attr |= color;
    }
    SetConsoleTextAttribute(console_hnd, attr);
}

void console_title_stats(void)
{
    char            buf[100];
    char            gain[10];
    static uint64_t last_good_CRC = 0, last_bad_CRC = 0;
    static int      ovl_count = 0;
    static char* overload = "            ";
    uint64_t        good_CRC = Modes.stat.good_CRC + Modes.stat.fixed;
    uint64_t        bad_CRC = Modes.stat.bad_CRC - Modes.stat.fixed;

    if (Modes.gain_auto)
        strcpy(gain, "auto");
    else snprintf(gain, sizeof(gain), "%.1f", (double)Modes.gain / 10.0);

    if (bad_CRC - last_bad_CRC > 2 * (good_CRC - last_good_CRC))
    {
        overload = " (too high?)";
        ovl_count = 3;   /* let it show for 3 refreshes */
    }
    else if (ovl_count > 0 && --ovl_count == 0)
        overload = "            ";

    snprintf(buf, sizeof(buf), "Dev: %s. CRC: %llu / %llu / %llu. Gain: %s dB%s",
        Modes.selected_dev ? Modes.selected_dev : "?",
        good_CRC, Modes.stat.fixed, bad_CRC, gain, overload);

    last_good_CRC = good_CRC;
    last_bad_CRC = bad_CRC;
    SetConsoleTitle(buf);
}

static int gain_increase(int gain_idx)
{
    if (Modes.rtlsdr.device && gain_idx < Modes.rtlsdr.gain_count - 1)
    {
        Modes.gain = Modes.rtlsdr.gains[++gain_idx];
        rtlsdr_set_tuner_gain(Modes.rtlsdr.device, Modes.gain);
    }
    else if (Modes.sdrplay.device && gain_idx < Modes.sdrplay.gain_count - 1)
    {
        Modes.gain = Modes.sdrplay.gains[++gain_idx];
        sdrplay_set_gain(Modes.sdrplay.device, Modes.gain);
    }
    LOG_FILEONLY("Increasing gain to %.1f dB.\n", (double)Modes.gain / 10.0);
    return (gain_idx);
}

static int gain_decrease(int gain_idx)
{
    if (Modes.rtlsdr.device && gain_idx > 0)
    {
        Modes.gain = Modes.rtlsdr.gains[--gain_idx];
        rtlsdr_set_tuner_gain(Modes.rtlsdr.device, Modes.gain);
    }
    else if (Modes.sdrplay.device && gain_idx > 0)
    {
        Modes.gain = Modes.sdrplay.gains[--gain_idx];
        sdrplay_set_gain(Modes.sdrplay.device, Modes.gain);
    }
    LOG_FILEONLY("Decreasing gain to %.1f dB.\n", (double)Modes.gain / 10.0);
    return (gain_idx);
}

/**
 * Poll for '+/-' keypresses and adjust the RTLSDR / SDRplay gain accordingly.
 * But within the min/max gain settings for the device.
 */
void console_update_gain(void)
{
    static int gain_idx = -1;
    int i, ch;

    if (gain_idx == -1)
    {
        for (i = 0; i < Modes.rtlsdr.gain_count; i++)
            if (Modes.gain == Modes.rtlsdr.gains[i])
            {
                gain_idx = i;
                break;
            }
        if (Modes.sdrplay.device)
            gain_idx = Modes.sdrplay.gain_count / 2;
    }

    if (!_kbhit())
        return;

    ch = _getch();

    /* If we have auto-gain enabled, switch to manual gain
     * on a '-' or '+' keypress. Start with the middle gain-value.
     */
    if (Modes.gain_auto && (ch == '-' || ch == '+'))
    {
        LOG_FILEONLY("Gain: AUTO -> manual.\n");
        Modes.gain_auto = false;
        if (Modes.rtlsdr.device)
        {
            rtlsdr_set_tuner_gain_mode(Modes.rtlsdr.device, 1);
            gain_idx = Modes.rtlsdr.gain_count / 2;
        }
        else if (Modes.sdrplay.device)
        {
            sdrplay_set_gain(Modes.sdrplay.device, 0);
            gain_idx = Modes.sdrplay.gain_count / 2;
        }
    }

    if (ch == '+')
        gain_idx = gain_increase(gain_idx);
    else if (ch == '-')
        gain_idx = gain_decrease(gain_idx);
#if 0
    else if (ch == 'g' || ch == 'G')
    {
        if (Modes.gain_auto)
        {
            gain_manual();
            LOG_FILEONLY("Gain: AUTO -> manual.\n");
        }
        else
        {
            gain_auto();
            LOG_FILEONLY("Gain: manual -> AUTO.\n");
        }
    }
#endif

}

int console_init(void)
{
    console_hnd = GetStdHandle(STD_OUTPUT_HANDLE);
    if (console_hnd == INVALID_HANDLE_VALUE)
        return (1);

    GetConsoleScreenBufferInfo(console_hnd, &console_info);
    GetConsoleMode(console_hnd, &console_mode);
    if (console_mode & ENABLE_VIRTUAL_TERMINAL_PROCESSING)
        SetConsoleMode(console_hnd, console_mode | DISABLE_NEWLINE_AUTO_RETURN);

    if (Modes.interactive_rows == 0)  /* Option `--interactive-rows` not used */
        Modes.interactive_rows = console_info.srWindow.Bottom - console_info.srWindow.Top - 1;
    return (0);
}

void console_exit(void)
{
    gotoxy(1, Modes.interactive_rows);
    setcolor(0);
    if (console_hnd != INVALID_HANDLE_VALUE)
        SetConsoleMode(console_hnd, console_mode);
    console_hnd = INVALID_HANDLE_VALUE;
}

#if defined(_DEBUG)
static _CrtMemState last_state;

void crtdbug_exit(void)
{
    _CrtMemState new_state, diff_state;

    _CrtMemCheckpoint(&new_state);
    if (!_CrtMemDifference(&diff_state, &last_state, &new_state))
    {
        LOG_STDERR("No mem-leaks detected.\n");
        return;
    }
    LOG_STDERR("Mem-leak report:\n");
    _CrtCheckMemory();
    _CrtSetDbgFlag(0);
    _CrtDumpMemoryLeaks();
}

void crtdbug_init(void)
{
    _HFILE file = _CRTDBG_FILE_STDERR;
    int    mode = _CRTDBG_MODE_FILE;
    int    flags = _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF | _CRTDBG_DELAY_FREE_MEM_DF;

    _CrtSetReportFile(_CRT_ASSERT, file);
    _CrtSetReportMode(_CRT_ASSERT, mode);
    _CrtSetReportFile(_CRT_ERROR, file);
    _CrtSetReportMode(_CRT_ERROR, mode);
    _CrtSetReportFile(_CRT_WARN, file);
    _CrtSetReportMode(_CRT_WARN, mode);
    _CrtSetDbgFlag(flags | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
    _CrtMemCheckpoint(&last_state);
}
#endif  /* _DEBUG */

/**
 * Return a string describing an error-code from RTLSDR
 *
 * This can be from `librtlsdr` itself or from `WinUsb`.
 */
const char* get_rtlsdr_error(int err)
{
    if (err >= 0)
        return ("No error");
    if (err == -ENOMEM)
        return strerror(-err);

#if 0  // \todo
    return rtlsdr_error_name(err);
#else
    static char buf[100];
    snprintf(buf, sizeof(buf), "WinUsb-error %d", err);
    return (buf);
#endif
}

/**
 * Set the RTLSDR gain verbosively.
 */
void verbose_gain_set(rtlsdr_dev_t* dev, int gain)
{
    int r = rtlsdr_set_tuner_gain_mode(dev, 1);

    if (r < 0)
    {
        LOG_STDERR("WARNING: Failed to enable manual gain.\n");
        return;
    }
    r = rtlsdr_set_tuner_gain(dev, gain);
    if (r)
        LOG_STDERR("WARNING: Failed to set tuner gain.\n");
    else LOG_STDERR("Tuner gain set to %.0f dB.\n", gain / 10.0);
}

/**
 * Set the RTLSDR gain verbosively to AUTO.
 */
void verbose_gain_auto(rtlsdr_dev_t* dev)
{
    int r = rtlsdr_set_tuner_gain_mode(dev, 0);

    if (r)
        LOG_STDERR("WARNING: Failed to enable automatic gain.\n");
    else LOG_STDERR("Tuner gain set to automatic.\n");
}

/**
 * Set the RTLSDR gain verbosively to the nearest available
 * gain value given in `*target_gain`.
 */
void nearest_gain(rtlsdr_dev_t* dev, uint16_t* target_gain)
{
    int    gain_in;
    int    i, err1, err2, nearest;
    int    r = rtlsdr_set_tuner_gain_mode(dev, 1);
    char   gbuf[200], * p = gbuf;
    size_t left = sizeof(gbuf);

    if (r)
    {
        LOG_STDERR("WARNING: Failed to enable manual gain.\n");
        return;
    }

    Modes.rtlsdr.gain_count = rtlsdr_get_tuner_gains(dev, NULL);
    if (Modes.rtlsdr.gain_count <= 0)
        return;

    Modes.rtlsdr.gains = malloc(sizeof(int) * Modes.rtlsdr.gain_count);
    Modes.rtlsdr.gain_count = rtlsdr_get_tuner_gains(dev, Modes.rtlsdr.gains);
    nearest = Modes.rtlsdr.gains[0];
    if (!target_gain)
        return;

    gain_in = *target_gain;

    for (i = 0; i < Modes.rtlsdr.gain_count; i++)
    {
        err1 = abs(gain_in - nearest);
        err2 = abs(gain_in - Modes.rtlsdr.gains[i]);

        p += snprintf(p, left, "%.1f, ", Modes.rtlsdr.gains[i] / 10.0);
        left = sizeof(gbuf) - (p - gbuf) - 1;
        if (err2 < err1)
            nearest = Modes.rtlsdr.gains[i];
    }
    p[-2] = '\0';
    LOG_STDERR("Supported gains: %s.\n", gbuf);
    *target_gain = (uint16_t)nearest;
}

/**
 * Enable RTLSDR direct sampling mode (not used yet).
 */
void verbose_direct_sampling(rtlsdr_dev_t* dev, int on)
{
    int r = rtlsdr_set_direct_sampling(dev, on);

    if (r)
    {
        LOG_STDERR("WARNING: Failed to set direct sampling mode.\n");
        return;
    }
    if (on == 0)
        LOG_STDERR("Direct sampling mode disabled.\n");
    else if (on == 1)
        LOG_STDERR("Enabled direct sampling mode, input 1/I.\n");
    else if (on == 2)
        LOG_STDERR("Enabled direct sampling mode, input 2/Q.\n");
}

/**
 * Set RTLSDR PPM error-correction.
 */
void verbose_ppm_set(rtlsdr_dev_t* dev, int ppm_error)
{
    double tuner_freq = 0.0;
    int    r;

    r = rtlsdr_set_freq_correction(dev, ppm_error);
    if (r < 0)
        LOG_STDERR("WARNING: Failed to set PPM correction.\n");
    else
    {
        rtlsdr_get_xtal_freq(dev, NULL, &tuner_freq);
        LOG_STDERR("Tuner correction set to %d PPM; %.3lf MHz.\n", ppm_error, tuner_freq / 1E6);
    }
}

/**
 * Set RTLSDR automatic gain control.
 */
void verbose_agc_set(rtlsdr_dev_t* dev, int agc)
{
    int r = rtlsdr_set_agc_mode(dev, agc);

    if (r < 0)
        LOG_STDERR("WARNING: Failed to set AGC.\n");
    else LOG_STDERR("AGC %s okay.\n", agc ? "enabled" : "disabled");
}

/**
 * Set RTLSDR Bias-T
 */
void verbose_bias_tee(rtlsdr_dev_t* dev, int bias_t)
{
    int r = rtlsdr_set_bias_tee(dev, bias_t);

    if (bias_t)
    {
        if (r)
            LOG_STDERR("Failed to activate Bias-T.\n");
        else LOG_STDERR("Activated Bias-T on GPIO PIN 0.\n");
    }
}

/**
 * Add an aircraft record to `Modes.aircraft_list`.
 */
int aircraft_CSV_add_entry(const aircraft_CSV* rec)
{
    static aircraft_CSV* copy = NULL;
    static aircraft_CSV* dest = NULL;
    static aircraft_CSV* hi_end;

    /* Not a valid ICAO address. Parse error?
     */
    if (rec->addr > 0xFFFFFF)
    {
        return 1;
    }

    if (rec->addr == 0 || rec->addr > 0xFFFFFF)
        return (1);

    if (!copy)
    {
        copy = dest = malloc(ONE_MEGABYTE);  /* initial buffer */
        hi_end = copy + (ONE_MEGABYTE / sizeof(*rec));
    }
    else if (dest == hi_end - 1)
    {
        size_t new_num = 10000 + Modes.aircraft_num_CSV;

        copy = realloc(Modes.aircraft_list, sizeof(*rec) * new_num);
        dest = copy + Modes.aircraft_num_CSV;
        hi_end = copy + new_num;
    }

    if (!copy)
        return (0);

    Modes.aircraft_list = copy;
    assert(dest < hi_end);
    memcpy(dest, rec, sizeof(*rec));
    Modes.aircraft_num_CSV++;
    dest = copy + Modes.aircraft_num_CSV;
    return (1);
}

/**
 * The compare function for `qsort()` and `bsearch()`.
 */
int aircraft_CSV_compare_on_addr(const void* _a, const void* _b)
{
    const aircraft_CSV* a = (const aircraft_CSV*)_a;
    const aircraft_CSV* b = (const aircraft_CSV*)_b;

    if (a->addr < b->addr)
        return (-1);
    if (a->addr > b->addr)
        return (1);
    return (0);
}

/**
 * Do a binary search for an aircraft in `Modes.aircraft_list`.
 */
const aircraft_CSV* aircraft_CSV_lookup_entry(uint32_t addr)
{
    aircraft_CSV key = { addr, "" };

    if (!Modes.aircraft_list)
        return (NULL);
    return bsearch(&key, Modes.aircraft_list, Modes.aircraft_num_CSV,
        sizeof(*Modes.aircraft_list), aircraft_CSV_compare_on_addr);
}

/**
 * If `Modes.debug != 0`, do a simple test on the `Modes.aircraft_list`.
 */
void aircraft_CSV_test(void)
{
    const aircraft_CSV* a_CSV;
    const char* reg_num, * manufact;
    unsigned     i, num_ok;
    uint32_t     addr;
    static const aircraft_CSV a_tests[] = {
                 { 0xAA3487, "N757F",   "Raytheon Aircraft Company" },
                 { 0x800737, "VT-ANQ",  "Boeing" },
                 { 0xAB34DE, "N821DA",  "Beech"  },
                 { 0x800737, "VT-ANQ",  "Boeing" },
                 { 0xA713D5, "N555UW",  "Piper" },
                 { 0x3532C1, "T.23-01", "AIRBUS" },  // Spanish Air Force
    };
#if 0
    for (i = 0; i < min(100, Modes.aircraft_num_CSV); i++)
    {
        a_CSV = Modes.aircraft_list + i;
        LOG_STDOUT("  addr: %06X, reg-num: '%s'\n", a_CSV->addr, a_CSV->reg_num);
    }
#endif

    LOG_STDOUT("5 random records from \"%s\":\n", Modes.aircraft_db);
    for (i = num_ok = 0; i < DIM(a_tests); i++)
    {
        addr = a_tests[i].addr;
        a_CSV = aircraft_CSV_lookup_entry(addr);
        reg_num = manufact = "?";
        if (a_CSV && a_CSV->reg_num[0])
        {
            reg_num = a_CSV->reg_num;
            num_ok++;
        }
        if (a_CSV && a_CSV->manufact[0])
            manufact = a_CSV->manufact;
        LOG_STDOUT("  addr: %06X, reg-num: '%-7s', manufact: '%s' %s\n",
            addr, reg_num, manufact, ICAO_is_military(addr) ? ", Military" : "");
    }
    LOG_STDOUT("%3u OKAY\n", num_ok);
    LOG_STDOUT("%3u FAIL\n", i - num_ok);
}

/**
 * The CSV callback for adding a record to `Modes.aircraft_list`.
 *
 * \param[in]  ctx   the CSV context structure.
 * \param[in]  value the value for this CSV field in record `ctx->rec_num`.
 *
 * Match the fields 0, 1, 3 and 10 for a record like this:
 * ```
 * "icao24","registration","manufacturericao","manufacturername","model","typecode","serialnumber","linenumber",
 * "icaoaircrafttype","operator","operatorcallsign","operatoricao","operatoriata","owner","testreg","registered",
 * "reguntil","status","built","firstflightdate","seatconfiguration","engines","modes","adsb","acars","notes",
 * "categoryDescription"
 * ```
 *
 * 27 fields!
 */
int aircraft_CSV_parse(struct CSV_context* ctx, const char* value)
{
    static aircraft_CSV rec = { 0, "" };
    int    rc = 1;

    if (ctx->field_num == 0)        /* "icao24" field */
    {
        if (strlen(value) == 6)
            rec.addr = mg_unhexn(value, 6);
    }
    else if (ctx->field_num == 1)   /* "registration" field */
    {
        strncpy(rec.reg_num, value, sizeof(rec.reg_num));
    }
    else if (ctx->field_num == 3)   /* "manufacturername" field */
    {
        strncpy(rec.manufact, value, sizeof(rec.manufact));
    }
    else if (ctx->field_num == 10)  /* "operatorcallsign" field */
    {
        strncpy(rec.call_sign, value, sizeof(rec.call_sign));
    }
    else if (ctx->field_num == ctx->num_fields - 1)  /* we got the last field */
    {
        rc = aircraft_CSV_add_entry(&rec);
        memset(&rec, '\0', sizeof(rec));    /* ready for a new record. */
    }
    return (rc);
}

/**
 * Initialize the aircraft-database from .csv file.
 */
void aircraft_CSV_load(void)
{
    struct stat st;

    if (!_stricmp(Modes.aircraft_db, "NUL"))   /* User want no .csv file */
        return;

    if (stat(Modes.aircraft_db, &st) != 0)
    {
        LOG_STDERR("Aircraft database \"%s\" does not exist.\n", Modes.aircraft_db);
        return;
    }

    memset(&Modes.csv_ctx, '\0', sizeof(Modes.csv_ctx));
    Modes.csv_ctx.file_name = Modes.aircraft_db;
    Modes.csv_ctx.delimiter = ',';
    Modes.csv_ctx.callback = aircraft_CSV_parse;
    Modes.csv_ctx.line_size = 2000;
    if (!CSV_open_and_parse_file(&Modes.csv_ctx))
    {
        LOG_STDERR("Parsing of \"%s\" failed: %s\n", Modes.aircraft_db, strerror(errno));
        return;
    }

    TRACE(DEBUG_GENERAL, "Parsed %u records from: \"%s\"\n", Modes.aircraft_num_CSV, Modes.aircraft_db);
    if (Modes.aircraft_num_CSV > 0)
    {
        qsort(Modes.aircraft_list, Modes.aircraft_num_CSV, sizeof(*Modes.aircraft_list), aircraft_CSV_compare_on_addr);
        if (Modes.debug)
            aircraft_CSV_test();
    }
}

/**
 * Step 1: Initialize the program with default values.
 */
void modeS_init_config(void)
{
    memset(&Modes, '\0', sizeof(Modes));
    GetCurrentDirectoryA(sizeof(Modes.where_am_I), Modes.where_am_I);
    GetModuleFileNameA(NULL, Modes.who_am_I, sizeof(Modes.who_am_I));

    strcpy(Modes.web_page, basename(GMAP_HTML));
    strcpy(Modes.web_root, dirname(Modes.who_am_I));
    strcat(Modes.web_root, "\\web_root");
    snprintf(Modes.aircraft_db, sizeof(Modes.aircraft_db), "%s\\aircraftDatabase.csv", dirname(Modes.who_am_I));

    Modes.gain_auto = true;
    Modes.sample_rate = MODES_DEFAULT_RATE;
    Modes.freq = MODES_DEFAULT_FREQ;
    Modes.interactive_ttl = MODES_INTERACTIVE_TTL;
    Modes.interactive_rows = 25;
    Modes.json_interval = 200;
}
void dump_lut()
{
#define IQ_COUNT 129
    int         I, Q;
    printf("uint16_t magnitude_multi_lut[%d][%d] =\n{", IQ_COUNT, IQ_COUNT);
    for (I = 0; I < IQ_COUNT; I++)
    {
        printf(I == 0 ? "\n" : ",\n");
        printf("  { ");
        for (Q = 0; Q < IQ_COUNT; Q++)
        {
            printf(Q == 0 ? "0x%04x" : ", 0x%04x", (uint16_t)round(360 * hypot(I, Q)));
            //[I * 129 + Q] = (uint16_t)round(360 * hypot(I, Q));
        }

        printf("}");
    }
    printf("\n}\n");
    exit(0);
}
/**
 * Step 2:
 *  \li Open and append to the `--logfile` if specified.
 *  \li In `--net` mode (but not `--net-active` mode), check the precence of the Web-page.
 *  \li Set our home position from the env-var `%DUMP1090_HOMEPOS%`.
 *  \li Initialize the `Modes.data_mutex`.
 *  \li Setup a SIGINT/SIGBREAK handler for a clean exit.
 *  \li Allocate and initialize the needed buffers.
 *  \li Open and parse the `Modes.aircraft_db` file (unless `NUL`).
 */
int modeS_init(void)
{


    pos_t       pos;
    const char* env;

    if (Modes.logfile)
    {
        Modes.log = fopen(Modes.logfile, "a");
        if (!Modes.log)
            LOG_STDERR("Failed to create/append to \"%s\".\n", Modes.logfile);
        else
        {
            char   args[1000] = "";
            char   buf[sizeof(args) + MG_PATH_MAX + 10];
            char* p = args;
            size_t n, left = sizeof(args);
            int    i;

            for (i = 1; i < __argc && left > 2; i++)
            {
                n = snprintf(p, left, " %s", __argv[i]);
                p += n;
                left -= n;
            }
            fputc('\n', Modes.log);
            snprintf(buf, sizeof(buf), "------- Starting '%s%s' -----------\n", Modes.who_am_I, args);
            modeS_log(buf);
        }
    }

    /** By default, disable all logging from Mongoose
     */
    mg_log_set("0");

    if (!Modes.interactive)
    {
        if (Modes.debug & DEBUG_NET)
            mg_log_set("2");               /** Enable `LL_ERROR`, `LL_INFO` messages in Mongose */
        else if (Modes.debug & DEBUG_NET2)
            mg_log_set("3");               /** Enable `LL_DEBUG` messages in Mongose */
    }

    env = getenv("DUMP1090_HOMEPOS");
    if (env)
    {
        if (sscanf(env, "%lf,%lf", &pos.lat, &pos.lon) != 2 || !VALID_POS(pos))
        {
            LOG_STDERR("Invalid home-pos %s\n", env);
            return (1);
        }
        Modes.home_pos = pos;
        Modes.home_pos_ok = true;
        spherical_to_cartesian(&Modes.home_pos_cart, Modes.home_pos);
    }

    InitializeCriticalSection(&Modes.magnitude_mutex);
    InitializeCriticalSection(&Modes.data_mutex);
    InitializeCriticalSection(&Modes.print_mutex);
    signal(SIGINT, sigint_handler);
    signal(SIGBREAK, sigint_handler);

    /* We add a full message minus a final bit to the length, so that we
     * can carry the remaining part of the buffer that we can't process
     * in the message detection loop, back at the start of the next data
     * to process. This way we are able to also detect messages crossing
     * two reads.
     */

    Modes.data_ready = false;

    /**
     * Allocate the ICAO address cache. We use two uint32_t for every
     * entry because it's a addr / timestamp pair for every entry.
     */
    Modes.ICAO_cache = calloc(sizeof(uint32_t) * MODES_ICAO_CACHE_LEN * 2, 1);
    //Modes.data          = malloc (Modes.data_len);
    //Modes.magnitude     = malloc (2*Modes.data_len);
    /*Modes.magnitude_lut = malloc (sizeof(*Modes.magnitude_lut) * 129 * 129);*/

    if (!Modes.ICAO_cache)
    {
        LOG_STDERR("Out of memory allocating data buffer.\n");
        return (1);
    }

    memset(Modes.data, 127, RAW_IQ_DATA_LEN);

    /* Populate the I/Q -> Magnitude lookup table. It is used because
     * hypot() or round() may be expensive and may vary a lot depending on
     * the CRT used.
     *
     * We scale to 0-255 range multiplying by 1.4 in order to ensure that
     * every different I/Q pair will result in a different magnitude value,
     * not losing any resolution.
     */
     //for (I = 0; I < 129; I++)
     //{
     //    for (Q = 0; Q < 129; Q++)
     //    {
     //        Modes.magnitude_lut[I * 129 + Q] = (uint16_t)round(360 * hypot(I, Q));
     //    }
     //}

     //for (auto J = 0; J < 129 * 129; J++)
     //{
     //    if (magnitude_lut[J] != Modes.magnitude_lut[J])
     //    //printf("/*[%d]=*/ %d\n", J, Modes.magnitude_lut[J]);
     //    printf("%d,", Modes.magnitude_lut[J]);

     //}

    aircraft_CSV_load();

    if (Modes.interactive && Modes.debug == 0)
        return console_init();
    return (0);
}

/**
 * Step 3: Initialize the RTLSDR device.
 *
 * If `Modes.rtlsdr.name` is specified, select the device that matches `manufact`.
 * Otherwise select on `Modes.rtlsdr.index` where 0 is the first device found.
 *
 * If one have > 1 RTLSDR device with the same product name and serial-number,
 * then the program `rtl_eeprom -d 1 -M "name"` is handy to set them apart.
 * Like:
 *  ```
 *   manufact: Silver, product: RTL2838UHIDIR, serial: 00000001
 *   manufact: Blue, product: RTL2838UHIDIR, serial: 00000001
 *  ```
 */
int modeS_init_RTLSDR(void)
{
    int    i, rc, device_count;
    double gain;

    device_count = rtlsdr_get_device_count();
    if (!device_count)
    {
        LOG_STDERR("No supported RTLSDR devices found.\n");
        return (1);
    }

    LOG_STDERR("Found %d device(s):\n", device_count);
    for (i = 0; i < device_count; i++)
    {
        char manufact[256] = "??";
        char product[256] = "??";
        char serial[256] = "??";
        bool selected = false;
        int  r = rtlsdr_get_device_usb_strings(i, manufact, product, serial);

        if (r == 0)
        {
            if (Modes.rtlsdr.name && manufact[0] && !_stricmp(Modes.rtlsdr.name, manufact))
            {
                selected = true;
                Modes.rtlsdr.index = i;
            }
            else
                selected = (i == Modes.rtlsdr.index);

            if (selected)
            {
                char buf[sizeof(manufact) + sizeof(product)];

                strcpy(buf, manufact);
                strcat(buf, ": ");
                strcat(buf, product);
                Modes.selected_dev = _strdup(buf);
            }
        }
        LOG_STDERR("%d: %-10s %-20s SN: %s %s\n", i, manufact, product, serial,
            selected ? "(currently selected)" : "");
    }

#if defined(HAVE_rtlsdr_cal_imr)
    if (Modes.rtlsdr.calibrate)
        rtlsdr_cal_imr(1);
#endif

    rc = rtlsdr_open(&Modes.rtlsdr.device, Modes.rtlsdr.index);
    if (rc < 0)
    {
        LOG_STDERR("Error opening the RTLSDR device %d: %s.\n", Modes.rtlsdr.index, get_rtlsdr_error(rc));
        return (1);
    }

    /* Set gain, frequency, sample rate, and reset the device.
     */
    if (Modes.gain_auto)
    {
        nearest_gain(Modes.rtlsdr.device, NULL);
        verbose_gain_auto(Modes.rtlsdr.device);
    }
    else
    {
        nearest_gain(Modes.rtlsdr.device, &Modes.gain);
        verbose_gain_set(Modes.rtlsdr.device, Modes.gain);
    }

    if (Modes.dig_agc)
        verbose_agc_set(Modes.rtlsdr.device, 1);

    if (Modes.rtlsdr.ppm_error)
        verbose_ppm_set(Modes.rtlsdr.device, Modes.rtlsdr.ppm_error);

    if (Modes.bias_tee)
        verbose_bias_tee(Modes.rtlsdr.device, Modes.bias_tee);

    rc = rtlsdr_set_center_freq(Modes.rtlsdr.device, Modes.freq);
    if (rc)
    {
        LOG_STDERR("Error setting frequency: %d.\n", rc);
        return (1);
    }

    rc = rtlsdr_set_sample_rate(Modes.rtlsdr.device, Modes.sample_rate);
    if (rc)
    {
        LOG_STDERR("Error setting sample-rate: %d.\n", rc);
        return (1);
    }

    rtlsdr_reset_buffer(Modes.rtlsdr.device);

    LOG_STDERR("Tuned to %.03f MHz.\n", Modes.freq / 1E6);

    gain = rtlsdr_get_tuner_gain(Modes.rtlsdr.device);
    if ((unsigned int)gain == 0)
        LOG_STDERR("Gain reported by device: AUTO.\n");
    else LOG_STDERR("Gain reported by device: %.2f dB.\n", gain / 10.0);
    return (0);
}

/**
 * This reading callback gets data from the RTLSDR or SDRplay API asynchronously.
 * We then populate the data buffer.
 *
 * A Mutex is used to avoid race-condition with the decoding thread.
 */
void rx_callback(uint8_t* buf, uint32_t len, void* ctx)
{
    volatile bool exit = *(volatile bool*)ctx;

    if (exit)
        return;

    EnterCriticalSection(&Modes.data_mutex);
    if (len > MODES_DATA_LEN)
        len = MODES_DATA_LEN;

    /* Move the last part of the previous buffer, that was not processed,
     * to the start of the new buffer.
     */
    memcpy(Modes.data, Modes.data + MODES_DATA_LEN, 4 * (MODES_FULL_LEN - 1));

    /* Read the new data.
     */
    memcpy(Modes.data + 4 * (MODES_FULL_LEN - 1), buf, len);
    Modes.data_ready = true;
    LeaveCriticalSection(&Modes.data_mutex);
}

/**
 * This is used when `--infile` is specified in order to read data from file
 * instead of using a RTLSDR / SDRplay device.
 */
int read_from_data_file(void)
{
    if (Modes.loops > 0 && Modes.fd == STDIN_FILENO)
    {
        LOG_STDERR("Option `--loop <N>` not supported for `stdin`.\n");
        Modes.loops = 0;
    }

    do
    {
        int nread, toread;
        uint8_t* p;

        if (Modes.interactive)
        {
            /* When --infile and --interactive are used together, slow down
             * mimicking the real RTLSDR / SDRplay rate.
             */
            Sleep(1000);
        }

        /* Move the last part of the previous buffer, that was not processed,
         * on the start of the new buffer.
         */
        memcpy(Modes.data, Modes.data + MODES_DATA_LEN, 4 * (MODES_FULL_LEN - 1));
        toread = MODES_DATA_LEN;
        p = Modes.data + 4 * (MODES_FULL_LEN - 1);

        while (toread)
        {
            nread = _read(Modes.fd, p, toread);
            if (nread <= 0)
                break;
            p += nread;
            toread -= nread;
        }

        if (toread)
        {
            /* Not enough data on file to fill the buffer? Pad with
             * no signal.
             */
            memset(p, 127, toread);
        }

        compute_magnitude_vector();
        detect_modeS();
        background_tasks();

        if (Modes.exit || Modes.fd == STDIN_FILENO)
            break;

        /* seek the file again from the start
         * and re-play it if --loop was given.
         */
        if (Modes.loops > 0)
            Modes.loops--;
        if (Modes.loops == 0 || _lseek(Modes.fd, 0, SEEK_SET) == -1)
            break;
    } while (1);
    return (0);  /**\todo add a check for errors above */
}

/**
 * We read RTLSDR or SDRplay data using a separate thread, so the main thread
 * only handles decoding without caring about data acquisition.
 * Ref. `main_data_loop()` below.
 */
unsigned int __stdcall data_thread_fn(void* arg)
{
    int rc;

    if (Modes.sdrplay.device)
    {
        rc = sdrplay_read_async(Modes.sdrplay.device, rx_callback, (void*)&Modes.exit,
            MODES_ASYNC_BUF_NUMBER, MODES_DATA_LEN);

        TRACE(DEBUG_GENERAL, "sdrplay_read_async(): rc: %d / %s.\n",
            rc, sdrplay_strerror(rc));

        sigint_handler(0);   /* break out of main_data_loop() */
    }
    else if (Modes.rtlsdr.device)
    {
        rc = rtlsdr_read_async(Modes.rtlsdr.device, rx_callback, (void*)&Modes.exit,
            MODES_ASYNC_BUF_NUMBER, MODES_DATA_LEN);

        TRACE(DEBUG_GENERAL, "rtlsdr_read_async(): rc: %d/%s.\n",
            rc, get_rtlsdr_error(rc));

        sigint_handler(0);    /* break out of main_data_loop() */
    }
    MODES_NOTUSED(arg);
    return (0);
}

/**
 * Main data processing loop.
 *
 * This runs in the main thread of the program.
 */
void main_data_loop(void)
{
    while (!Modes.exit)
    {
        background_tasks();

        

        if (!Modes.data_ready) {
            //LeaveCriticalSection(&Modes.data_mutex);
            Sleep(1);
            continue;
        }

        EnterCriticalSection(&Modes.data_mutex);

        //EnterCriticalSection(&Modes.magnitude_mutex);

        compute_magnitude_vector();

        /* Signal to the other thread that we processed the available data
         * and we want more.
         */
        Modes.data_ready = false;
        LeaveCriticalSection(&Modes.data_mutex);

        /* Process data after releasing the lock, so that the capturing
         * thread can read data while we perform computationally expensive
         * stuff at the same time. (This should only be useful with very
         * slow processors).
         */


#if 0     /**\todo */
        if (Modes.sdrplay_device && Modes.sdrplay.over_sample)
        {
            struct mag_buf* buf = &Modes.mag_buffers[Modes.first_filled_buffer];
            demodulate_8000(buf);
        }
        else
#endif
            detect_modeS();
        //LeaveCriticalSection(&Modes.magnitude_mutex);

        

        if (/* rc > 0 && */ Modes.max_messages > 0)
        {
            if (--Modes.max_messages == 0)
            {
                LOG_STDOUT("'Modes.max_messages' reached 0.\n");
                Modes.exit = true;
            }
        }
    }
}

/**
 * Helper function for `dump_magnitude_vector()`.
 * It prints a single bar used to display raw signals.
 *
 * Since every magnitude sample is between 0 - 255, the function uses
 * up to 63 characters for every bar. Every character represents
 * a length of 4, 3, 2, 1, specifically:
 *
 * \li "O" is 4
 * \li "o" is 3
 * \li "-" is 2
 * \li "." is 1
 */
void dump_magnitude_bar(uint16_t magnitude, int index)
{
    const char* set = " .-o";
    char        buf[256];
    uint16_t    div = (magnitude / 256) / 4;
    uint16_t    rem = (magnitude / 256) % 4;
    int         markchar = ']';

    memset(buf, 'O', div);
    buf[div] = set[rem];
    buf[div + 1] = '\0';

    if (index >= 0)
    {
        /* preamble peaks are marked with ">"
         */
        if (index == 0 || index == 2 || index == 7 || index == 9)
            markchar = '>';

        /* Data peaks are marked to distinguish pairs of bits.
         */
        if (index >= 16)
            markchar = ((index - 16) / 2 & 1) ? '|' : ')';
        printf("[%3d%c |%-66s %u\n", index, markchar, buf, magnitude);
    }
    else
        printf("[%3d] |%-66s %u\n", index, buf, magnitude);
}

/**
 * Display an *ASCII-art* alike graphical representation of the undecoded
 * message as a magnitude signal.
 *
 * The message starts at the specified offset in the `m` buffer.
 * The function will display enough data to cover a short 56 bit
 * (`MODES_SHORT_MSG_BITS`) message.
 *
 * If possible a few samples before the start of the messsage are included
 * for context.
 */
void dump_magnitude_vector(const uint16_t* m, uint32_t offset)
{
    uint32_t padding = 5;  /* Show a few samples before the actual start. */
    uint32_t start = (offset < padding) ? 0 : offset - padding;
    uint32_t end = offset + (2 * MODES_PREAMBLE_US) + (2 * MODES_SHORT_MSG_BITS) - 1;
    uint32_t i;

    for (i = start; i <= end; i++)
        dump_magnitude_bar(m[i], i - offset);
}

/**
 * Produce a raw representation of the message as a Javascript file
 * loadable by `debug.html`.
 */
void dump_raw_message_JS(const char* descr, uint8_t* msg, const uint16_t* m, uint32_t offset, int fixable)
{
    int   padding = 5;     /* Show a few samples before the actual start. */
    int   start = offset - padding;
    int   end = offset + (MODES_PREAMBLE_US * 2) + (MODES_LONG_MSG_BITS * 2) - 1;
    int   j, fix1 = -1, fix2 = -1;
    FILE* fp;

    if (fixable != -1)
    {
        fix1 = fixable & 0xFF;
        if (fixable > 255)
            fix2 = fixable >> 8;
    }
    fp = fopen("frames.js", "a");
    if (!fp)
    {
        LOG_STDERR("Error opening frames.js: %s\n", strerror(errno));
        exit(1);
    }

    fprintf(fp, "frames.push({\"descr\": \"%s\", \"mag\": [", descr);
    for (j = start; j <= end; j++)
    {
        fprintf(fp, "%d", j < 0 ? 0 : m[j]);
        if (j != end)
            fprintf(fp, ",");
    }
    fprintf(fp, "], \"fix1\": %d, \"fix2\": %d, \"bits\": %d, \"hex\": \"",
        fix1, fix2, modeS_message_len_by_type(msg[0] >> 3));
    for (j = 0; j < MODES_LONG_MSG_BYTES; j++)
        fprintf(fp, "\\x%02x", msg[j]);
    fprintf(fp, "\"});\n");
    fclose(fp);
}

/**
 * This is a wrapper for `dump_magnitude_vector()` that also show the message
 * in hex format with an additional description.
 *
 * \param in  descr  the additional message to show to describe the dump.
 * \param out msg    the decoded message
 * \param in  m      the original magnitude vector
 * \param in  offset the offset where the message starts
 *
 * The function also produces the Javascript file used by `debug.html` to
 * display packets in a graphical format if the Javascript output was
 * enabled.
 */
void dump_raw_message(const char* descr, uint8_t* msg, const uint16_t* m, uint32_t offset)
{
    int j;
    int msg_type = msg[0] >> 3;
    int fixable = -1;

    if (msg_type == 11 || msg_type == 17)
    {
        int msg_bits = (msg_type == 11) ? MODES_SHORT_MSG_BITS :
            MODES_LONG_MSG_BITS;
        fixable = fix_single_bit_errors(msg, msg_bits);
        if (fixable == -1)
            fixable = fix_two_bits_errors(msg, msg_bits);
    }

    if (Modes.debug & DEBUG_JS)
    {
        dump_raw_message_JS(descr, msg, m, offset, fixable);
        return;
    }

    EnterCriticalSection(&Modes.print_mutex);

    printf("\n--- %s:\n    ", descr);
    for (j = 0; j < MODES_LONG_MSG_BYTES; j++)
    {
        printf("%02X", msg[j]);
        if (j == MODES_SHORT_MSG_BYTES - 1)
            printf(" ... ");
    }
    printf(" (DF %d, Fixable: %d)\n", msg_type, fixable);
    dump_magnitude_vector(m, offset);
    puts("---\n");

    LeaveCriticalSection(&Modes.print_mutex);
}

/**
 * Parity table for MODE S Messages.
 *
 * The table contains 112 (`MODES_LONG_MSG_BITS`) elements, every element
 * corresponds to a bit set in the message, starting from the first bit of
 * actual data after the preamble.
 *
 * For messages of 112 bit, the whole table is used.
 * For messages of 56 bits only the last 56 elements are used.
 *
 * The algorithm is as simple as XOR-ing all the elements in this table
 * for which the corresponding bit on the message is set to 1.
 *
 * The last 24 elements in this table are set to 0 as the checksum at the
 * end of the message should not affect the computation.
 *
 * \note
 * This function can be used with DF11 and DF17. Other modes have
 * the CRC *XOR-ed* with the sender address as they are replies to interrogations,
 * but a casual listener can't split the address from the checksum.
 */
const uint32_t modeS_checksum_table[MODES_LONG_MSG_BITS] = {
               0x3935EA, 0x1C9AF5, 0xF1B77E, 0x78DBBF, 0xC397DB, 0x9E31E9, 0xB0E2F0, 0x587178,
               0x2C38BC, 0x161C5E, 0x0B0E2F, 0xFA7D13, 0x82C48D, 0xBE9842, 0x5F4C21, 0xD05C14,
               0x682E0A, 0x341705, 0xE5F186, 0x72F8C3, 0xC68665, 0x9CB936, 0x4E5C9B, 0xD8D449,
               0x939020, 0x49C810, 0x24E408, 0x127204, 0x093902, 0x049C81, 0xFDB444, 0x7EDA22,
               0x3F6D11, 0xE04C8C, 0x702646, 0x381323, 0xE3F395, 0x8E03CE, 0x4701E7, 0xDC7AF7,
               0x91C77F, 0xB719BB, 0xA476D9, 0xADC168, 0x56E0B4, 0x2B705A, 0x15B82D, 0xF52612,
               0x7A9309, 0xC2B380, 0x6159C0, 0x30ACE0, 0x185670, 0x0C2B38, 0x06159C, 0x030ACE,
               0x018567, 0xFF38B7, 0x80665F, 0xBFC92B, 0xA01E91, 0xAFF54C, 0x57FAA6, 0x2BFD53,
               0xEA04AD, 0x8AF852, 0x457C29, 0xDD4410, 0x6EA208, 0x375104, 0x1BA882, 0x0DD441,
               0xF91024, 0x7C8812, 0x3E4409, 0xE0D800, 0x706C00, 0x383600, 0x1C1B00, 0x0E0D80,
               0x0706C0, 0x038360, 0x01C1B0, 0x00E0D8, 0x00706C, 0x003836, 0x001C1B, 0xFFF409,
               0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
               0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
               0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
};

uint32_t modeS_checksum(const uint8_t* msg, int bits)
{
    uint32_t crc = 0;
    int      offset = 0;
    int      j;

    if (bits != MODES_LONG_MSG_BITS)
        offset = MODES_LONG_MSG_BITS - MODES_SHORT_MSG_BITS;

    for (j = 0; j < bits; j++)
    {
        int byte = j / 8;
        int bit = j % 8;
        int bitmask = 1 << (7 - bit);

        /* If bit is set, XOR with corresponding table entry.
         */
        if (msg[byte] & bitmask)
            crc ^= modeS_checksum_table[j + offset];
    }
    return (crc); /* 24 bit checksum. */
}

/**
 * Given the Downlink Format (DF) of the message, return the message length
 * in bits.
 */
int modeS_message_len_by_type(int type)
{
    if (type == 16 || type == 17 || type == 19 || type == 20 || type == 21)
        return (MODES_LONG_MSG_BITS);
    return (MODES_SHORT_MSG_BITS);
}

/**
 * Try to fix single bit errors using the checksum. On success modifies
 * the original buffer with the fixed version, and returns the position
 * of the error bit. Otherwise if fixing failed, -1 is returned.
 */
int fix_single_bit_errors(uint8_t* msg, int bits)
{
    int     i;
    uint8_t aux[MODES_LONG_MSG_BITS / 8];

    for (i = 0; i < bits; i++)
    {
        int      byte = i / 8;
        int      bitmask = 1 << (7 - (i % 8));
        uint32_t crc1, crc2;

        memcpy(aux, msg, bits / 8);
        aux[byte] ^= bitmask;   /* Flip j-th bit. */

        crc1 = ((uint32_t)aux[(bits / 8) - 3] << 16) |
            ((uint32_t)aux[(bits / 8) - 2] << 8) |
            (uint32_t)aux[(bits / 8) - 1];
        crc2 = modeS_checksum(aux, bits);

        if (crc1 == crc2)
        {
            /* The error is fixed. Overwrite the original buffer with
             * the corrected sequence, and returns the error bit
             * position.
             */
            memcpy(msg, aux, bits / 8);
            return (i);
        }
    }
    return (-1);
}

/**
 * Similar to `fix_single_bit_errors()` but try every possible two bit combination.
 *
 * This is very slow and should be tried only against DF17 messages that
 * don't pass the checksum, and only in Aggressive Mode.
 */
int fix_two_bits_errors(uint8_t* msg, int bits)
{
    int     j, i;
    uint8_t aux[MODES_LONG_MSG_BITS / 8];

    for (j = 0; j < bits; j++)
    {
        int byte1 = j / 8;
        int bitmask1 = 1 << (7 - (j % 8));

        /* Don't check the same pairs multiple times, so i starts from j+1 */
        for (i = j + 1; i < bits; i++)
        {
            int      byte2 = i / 8;
            int      bitmask2 = 1 << (7 - (i % 8));
            uint32_t crc1, crc2;

            memcpy(aux, msg, bits / 8);

            aux[byte1] ^= bitmask1; /* Flip j-th bit. */
            aux[byte2] ^= bitmask2; /* Flip i-th bit. */

            crc1 = ((uint32_t)aux[(bits / 8) - 3] << 16) |
                ((uint32_t)aux[(bits / 8) - 2] << 8) |
                (uint32_t)aux[(bits / 8) - 1];
            crc2 = modeS_checksum(aux, bits);

            if (crc1 == crc2)
            {
                /* The error is fixed. Overwrite the original buffer with
                 * the corrected sequence, and returns the error bit
                 * position.
                 */
                memcpy(msg, aux, bits / 8);

                /* We return the two bits as a 16 bit integer by shifting
                 * 'i' on the left. This is possible since 'i' will always
                 * be non-zero because i starts from j+1.
                 */
                return (j | (i << 8));
            }
        }
    }
    return (-1);
}

/**
 * Hash the ICAO address to index our cache of MODES_ICAO_CACHE_LEN
 * elements, that is assumed to be a power of two.
 */
uint32_t ICAO_cache_hash_address(uint32_t a)
{
    /* The following three rounds will make sure that every bit affects
     * every output bit with ~ 50% of probability.
     */
    a = ((a >> 16) ^ a) * 0x45D9F3B;
    a = ((a >> 16) ^ a) * 0x45D9F3B;
    a = ((a >> 16) ^ a);
    return (a & (MODES_ICAO_CACHE_LEN - 1));
}

/**
 * Add the specified entry to the cache of recently seen ICAO addresses.
 *
 * Note that we also add a timestamp so that we can make sure that the
 * entry is only valid for `MODES_ICAO_CACHE_TTL` seconds.
 */
void ICAO_cache_add_address(uint32_t addr)
{
    uint32_t h = ICAO_cache_hash_address(addr);

    Modes.ICAO_cache[h * 2] = addr;
    Modes.ICAO_cache[h * 2 + 1] = (uint32_t)time(NULL);
}

/**
 * Returns 1 if the specified ICAO address was seen in a DF format with
 * proper checksum (not XORed with address) no more than
 * `MODES_ICAO_CACHE_TTL` seconds ago. Otherwise returns 0.
 */
int ICAO_address_recently_seen(uint32_t addr)
{
    uint32_t h = ICAO_cache_hash_address(addr);
    uint32_t a = Modes.ICAO_cache[h * 2];
    uint32_t t = Modes.ICAO_cache[h * 2 + 1];
    time_t   now = time(NULL);

    return (a && a == addr && (now - t) <= MODES_ICAO_CACHE_TTL);
}

/**
 * Returns TRUE if the ICAO address is in one of these military ranges.
 */
static const ICAO_range military_range[] = {
     { 0xADF7C8,  0xAFFFFF },
     { 0x010070,  0x01008F },
     { 0x0A4000,  0x0A4FFF },
     { 0x33FF00,  0x33FFFF },
     { 0x350000,  0x37FFFF },
     { 0x3A8000,  0x3AFFFF },
     { 0x3B0000,  0x3BFFFF },
     { 0x3EA000,  0x3EBFFF },
     { 0x3F4000,  0x3FBFFF },
     { 0x400000,  0x40003F },
     { 0x43C000,  0x43CFFF },
     { 0x444000,  0x446FFF },
     { 0x44F000,  0x44FFFF },
     { 0x457000,  0x457FFF },
     { 0x45F400,  0x45F4FF },
     { 0x468000,  0x4683FF },
     { 0x473C00,  0x473C0F },
     { 0x478100,  0x4781FF },
     { 0x480000,  0x480FFF },
     { 0x48D800,  0x48D87F },
     { 0x497C00,  0x497CFF },
     { 0x498420,  0x49842F },
     { 0x4B7000,  0x4B7FFF },
     { 0x4B8200,  0x4B82FF },
     { 0x506F00,  0x506FFF },
     { 0x70C070,  0x70C07F },
     { 0x710258,  0x71028F },
     { 0x710380,  0x71039F },
     { 0x738A00,  0x738AFF },
     { 0x7C822E,  0x7C84FF },
     { 0x7C8800,  0x7C88FF },
     { 0x7C9000,  0x7CBFFF },
     { 0x7D0000,  0x7FFFFF },
     { 0x800200,  0x8002FF },
     { 0xC20000,  0xC3FFFF },
     { 0xE40000,  0xE41FFF }
};

bool ICAO_is_military(uint32_t addr)
{
    for (uint16_t i = 0; i < DIM(military_range); i++)
        if (addr >= military_range[i].low && addr <= military_range[i].high)
            return (true);
    return (false);
}

/**
 * If the message type has the checksum XORed with the ICAO address, try to
 * brute force it using a list of recently seen ICAO addresses.
 *
 * Do this in a brute-force fashion by XORing the predicted CRC with
 * the address XOR checksum field in the message. This will recover the
 * address: if we found it in our cache, we can assume the message is okay.
 *
 * This function expects `mm->msg_type` and `mm->msg_bits` to be correctly
 * populated by the caller.
 *
 * On success the correct ICAO address is stored in the `modeS_message`
 * structure in the `AA3`, `AA2`, and `AA1` fields.
 *
 * \retval 1 successfully recovered a message with a correct checksum.
 * \retval 0 failed to recover a message with a correct checksum.
 */
int brute_force_AP(uint8_t* msg, modeS_message* mm)
{
    uint8_t aux[MODES_LONG_MSG_BYTES];
    int     msg_type = mm->msg_type;
    int     msg_bits = mm->msg_bits;

    if (msg_type == 0 ||         /* Short air surveillance */
        msg_type == 4 ||         /* Surveillance, altitude reply */
        msg_type == 5 ||         /* Surveillance, identity reply */
        msg_type == 16 ||        /* Long Air-Air Surveillance */
        msg_type == 20 ||        /* Comm-A, altitude request */
        msg_type == 21 ||        /* Comm-A, identity request */
        msg_type == 24)          /* Comm-C ELM */
    {
        uint32_t addr;
        uint32_t crc;
        int      last_byte = (msg_bits / 8) - 1;

        /* Work on a copy. */
        memcpy(aux, msg, msg_bits / 8);

        /* Compute the CRC of the message and XOR it with the AP field
         * so that we recover the address, because:
         *
         * (ADDR xor CRC) xor CRC = ADDR.
         */
        crc = modeS_checksum(aux, msg_bits);
        aux[last_byte] ^= crc & 0xFF;
        aux[last_byte - 1] ^= (crc >> 8) & 0xFF;
        aux[last_byte - 2] ^= (crc >> 16) & 0xFF;

        /* If the obtained address exists in our cache we consider
         * the message valid.
         */
        addr = aux[last_byte] |
            (aux[last_byte - 1] << 8) |
            (aux[last_byte - 2] << 16);
        if (ICAO_address_recently_seen(addr))
        {
            mm->AA1 = aux[last_byte - 2];
            mm->AA2 = aux[last_byte - 1];
            mm->AA3 = aux[last_byte];
            return (1);
        }
    }
    return (0);
}

/**
 * Decode the 13 bit AC altitude field (in DF 20 and others).
 *
 * \param in  msg   the raw message to work with.
 * \param out unit  set to either `MODES_UNIT_METERS` or `MDOES_UNIT_FEETS`.
 * \retval the altitude.
 */
int decode_AC13_field(const uint8_t* msg, int* unit)
{
    int m_bit = msg[3] & (1 << 6);
    int q_bit = msg[3] & (1 << 4);

    if (!m_bit)
    {
        *unit = MODES_UNIT_FEET;
        if (q_bit)
        {
            /* N is the 11 bit integer resulting from the removal of bit Q and M
             */
            int n = ((msg[2] & 31) << 6) |
                ((msg[3] & 0x80) >> 2) |
                ((msg[3] & 0x20) >> 1) |
                (msg[3] & 15);

            /** The final altitude is due to the resulting number multiplied
             * by 25, minus 1000.
             */
            return (25 * n - 1000);
        }
        else
        {
            /** \todo Implement altitude where Q=0 and M=0 */
        }
    }
    else
    {
        *unit = MODES_UNIT_METERS;

        /** \todo Implement altitude when meter unit is selected.
         */
    }
    return (0);
}

/**
 * Decode the 12 bit AC altitude field (in DF 17 and others).
 * Returns the altitude or 0 if it can't be decoded.
 */
int decode_AC12_field(uint8_t* msg, int* unit)
{
    int n, q_bit = msg[5] & 1;

    if (q_bit)
    {
        /* N is the 11 bit integer resulting from the removal of bit Q
         */
        *unit = MODES_UNIT_FEET;
        n = ((msg[5] >> 1) << 4) | ((msg[6] & 0xF0) >> 4);

        /* The final altitude is due to the resulting number multiplied
         * by 25, minus 1000.
         */
        return (25 * n - 1000);
    }
    return (0);
}

/**
 * Capability table.
 */
const char* capability_str[8] = {
    /* 0 */ "Level 1 (Surveillance Only)",
    /* 1 */ "Level 2 (DF0,4,5,11)",
    /* 2 */ "Level 3 (DF0,4,5,11,20,21)",
    /* 3 */ "Level 4 (DF0,4,5,11,20,21,24)",
    /* 4 */ "Level 2+3+4 (DF0,4,5,11,20,21,24,code7 - is on ground)",
    /* 5 */ "Level 2+3+4 (DF0,4,5,11,20,21,24,code7 - is airborne)",
    /* 6 */ "Level 2+3+4 (DF0,4,5,11,20,21,24,code7)",
    /* 7 */ "Level 7 ???"
};

/**
 * Flight status table.
 */
const char* flight_status_str[8] = {
    /* 0 */ "Normal, Airborne",
    /* 1 */ "Normal, On the ground",
    /* 2 */ "ALERT,  Airborne",
    /* 3 */ "ALERT,  On the ground",
    /* 4 */ "ALERT & Special Position Identification. Airborne or Ground",
    /* 5 */ "Special Position Identification. Airborne or Ground",
    /* 6 */ "Value 6 is not assigned",
    /* 7 */ "Value 7 is not assigned"
};

/**
 * Emergency state table from: <br>
 *   https://www.ll.mit.edu/mission/aviation/publications/publication-files/atc-reports/Grappel_2007_ATC-334_WW-15318.pdf
 *
 * and 1090-DO-260B_FRAC
 */
const char* emerg_state_str[8] = {
    /* 0 */ "No emergency",
    /* 1 */ "General emergency (Squawk 7700)",
    /* 2 */ "Lifeguard/Medical",
    /* 3 */ "Minimum fuel",
    /* 4 */ "No communications (Squawk 7600)",
    /* 5 */ "Unlawful interference (Squawk 7500)",
    /* 6 */ "Reserved",
    /* 7 */ "Reserved"
};

const char* get_ME_description(const modeS_message* mm)
{
    if (mm->ME_type >= 1 && mm->ME_type <= 4)
        return ("Aircraft Identification and Category");

    if (mm->ME_type >= 5 && mm->ME_type <= 8)
        return ("Surface Position");

    if (mm->ME_type >= 9 && mm->ME_type <= 18)
        return ("Airborne Position (Baro Altitude)");

    if (mm->ME_type == 19 && mm->ME_subtype >= 1 && mm->ME_subtype <= 4)
        return ("Airborne Velocity");

    if (mm->ME_type >= 20 && mm->ME_type <= 22)
        return ("Airborne Position (GNSS Height)");

    if (mm->ME_type == 23 && mm->ME_subtype == 0)
        return ("Test Message");

    if (mm->ME_type == 23 && mm->ME_subtype == 7)
        return ("Test Message -- Squawk");

    if (mm->ME_type == 24 && mm->ME_subtype == 1)
        return ("Surface System Status");

    if (mm->ME_type == 28 && mm->ME_subtype == 1)
        return ("Extended Squitter Aircraft Status (Emergency)");

    if (mm->ME_type == 28 && mm->ME_subtype == 2)
        return ("Extended Squitter Aircraft Status (1090ES TCAS RA)");

    if (mm->ME_type == 29 && (mm->ME_subtype == 0 || mm->ME_subtype == 1))
        return ("Target State and Status Message");

    if (mm->ME_type == 31 && (mm->ME_subtype == 0 || mm->ME_subtype == 1))
        return ("Aircraft Operational Status Message");

    return ("Unknown");
}

/**
 * Decode a raw Mode S message demodulated as a stream of bytes by `detect_modeS()`.
 *
 * And split it into fields populating a `modeS_message` structure.
 */
void decode_modeS_message(modeS_message* mm, const uint8_t* _msg)
{
    uint32_t    crc2;   /* Computed CRC, used to verify the message CRC. */
    const char* AIS_charset = "?ABCDEFGHIJKLMNOPQRSTUVWXYZ????? ???????????????0123456789??????";
    uint8_t* msg;

    memset(mm, '\0', sizeof(*mm));

    /* Work on our local copy
     */
    memcpy(mm->msg, _msg, sizeof(mm->msg));
    msg = mm->msg;

    /* Get the message type ASAP as other operations depend on this
     */
    mm->msg_type = msg[0] >> 3;    /* Downlink Format */
    mm->msg_bits = modeS_message_len_by_type(mm->msg_type);

    /* CRC is always the last three bytes.
     */
    mm->CRC = ((uint32_t)msg[(mm->msg_bits / 8) - 3] << 16) |
        ((uint32_t)msg[(mm->msg_bits / 8) - 2] << 8) |
        (uint32_t)msg[(mm->msg_bits / 8) - 1];
    crc2 = modeS_checksum(msg, mm->msg_bits);

    /* Check CRC and fix single bit errors using the CRC when
     * possible (DF 11 and 17).
     */
    mm->error_bit = -1;    /* No error */
    mm->CRC_ok = (mm->CRC == crc2);

    if (!mm->CRC_ok && (mm->msg_type == 11 || mm->msg_type == 17))
    {
        mm->error_bit = fix_single_bit_errors(msg, mm->msg_bits);
        if (mm->error_bit != -1)
        {
            mm->CRC = modeS_checksum(msg, mm->msg_bits);
            mm->CRC_ok = true;
        }
        else if (Modes.aggressive && mm->msg_type == 17 && (mm->error_bit = fix_two_bits_errors(msg, mm->msg_bits)) != -1)
        {
            mm->CRC = modeS_checksum(msg, mm->msg_bits);
            mm->CRC_ok = true;
        }
    }

    /* Note: most of the other computation happens **after** we fix the single bit errors.
     * Otherwise we would need to recompute the fields again.
     */
    mm->ca = msg[0] & 7;        /* Responder capabilities. */

    /* ICAO address
     */
    mm->AA1 = msg[1];
    mm->AA2 = msg[2];
    mm->AA3 = msg[3];

    /* DF17 type (assuming this is a DF17, otherwise not used)
     */
    mm->ME_type = msg[4] >> 3;         /* Extended squitter message type. */
    mm->ME_subtype = msg[4] & 7;       /* Extended squitter message subtype. */

    /* Fields for DF4,5,20,21
     */
    mm->flight_status = msg[0] & 7;         /* Flight status for DF4,5,20,21 */
    mm->DR_status = msg[1] >> 3 & 31;       /* Request extraction of downlink request. */
    mm->UM_status = ((msg[1] & 7) << 3) |   /* Request extraction of downlink request. */
        (msg[2] >> 5);

    /*
     * In the squawk (identity) field bits are interleaved like this:
     * (message bit 20 to bit 32):
     *
     * C1-A1-C2-A2-C4-A4-ZERO-B1-D1-B2-D2-B4-D4
     *
     * So every group of three bits A, B, C, D represent an integer
     * from 0 to 7.
     *
     * The actual meaning is just 4 octal numbers, but we convert it
     * into a base ten number that happens to represent the four octal numbers.
     *
     * For more info: http://en.wikipedia.org/wiki/Gillham_code
     */
    {
        int a, b, c, d;

        a = ((msg[3] & 0x80) >> 5) |
            ((msg[2] & 0x02) >> 0) |
            ((msg[2] & 0x08) >> 3);
        b = ((msg[3] & 0x02) << 1) |
            ((msg[3] & 0x08) >> 2) |
            ((msg[3] & 0x20) >> 5);
        c = ((msg[2] & 0x01) << 2) |
            ((msg[2] & 0x04) >> 1) |
            ((msg[2] & 0x10) >> 4);
        d = ((msg[3] & 0x01) << 2) |
            ((msg[3] & 0x04) >> 1) |
            ((msg[3] & 0x10) >> 4);
        mm->identity = a * 1000 + b * 100 + c * 10 + d;
    }

    /* DF 11 & 17: try to populate our ICAO addresses whitelist.
     * DFs with an AP field (XORed addr and CRC), try to decode it.
     */
    if (mm->msg_type != 11 && mm->msg_type != 17)
    {
        /* Check if we can check the checksum for the Downlink Formats where
         * the checksum is XORed with the aircraft ICAO address. We try to
         * brute force it using a list of recently seen aircraft addresses.
         */
        if (brute_force_AP(msg, mm))
        {
            /* We recovered the message, mark the checksum as valid.
             */
            mm->CRC_ok = true;
        }
        else
            mm->CRC_ok = false;
    }
    else
    {
        /* If this is DF 11 or DF 17 and the checksum was ok, we can add this address to the list
         * of recently seen addresses.
         */
        if (mm->CRC_ok && mm->error_bit == -1)
        {
            uint32_t addr = (mm->AA1 << 16) | (mm->AA2 << 8) | mm->AA3;
            ICAO_cache_add_address(addr);
        }
    }

    /* Decode 13 bit altitude for DF0, DF4, DF16, DF20
     */
    if (mm->msg_type == 0 || mm->msg_type == 4 || mm->msg_type == 16 || mm->msg_type == 20)
        mm->altitude = decode_AC13_field(msg, &mm->unit);

    /** Decode extended squitter specific stuff.
     */
    if (mm->msg_type == 17)
    {
        /* Decode the extended squitter message.
         */
        if (mm->ME_type >= 1 && mm->ME_type <= 4)
        {
            /* Aircraft Identification and Category
             */
            mm->aircraft_type = mm->ME_type - 1;
            mm->flight[0] = AIS_charset[msg[5] >> 2];
            mm->flight[1] = AIS_charset[((msg[5] & 3) << 4) | (msg[6] >> 4)];
            mm->flight[2] = AIS_charset[((msg[6] & 15) << 2) | (msg[7] >> 6)];
            mm->flight[3] = AIS_charset[msg[7] & 63];
            mm->flight[4] = AIS_charset[msg[8] >> 2];
            mm->flight[5] = AIS_charset[((msg[8] & 3) << 4) | (msg[9] >> 4)];
            mm->flight[6] = AIS_charset[((msg[9] & 15) << 2) | (msg[10] >> 6)];
            mm->flight[7] = AIS_charset[msg[10] & 63];
            mm->flight[8] = '\0';
        }
        else if (mm->ME_type >= 9 && mm->ME_type <= 18)
        {
            /* Airborne position Message
             */
            mm->odd_flag = msg[6] & (1 << 2);
            mm->UTC_flag = msg[6] & (1 << 3);
            mm->altitude = decode_AC12_field(msg, &mm->unit);
            mm->raw_latitude = ((msg[6] & 3) << 15) | (msg[7] << 7) | (msg[8] >> 1); /* Bits 23 - 39 */
            mm->raw_longitude = ((msg[8] & 1) << 16) | (msg[9] << 8) | msg[10];       /* Bits 40 - 56 */
        }
        else if (mm->ME_type == 19 && mm->ME_subtype >= 1 && mm->ME_subtype <= 4)
        {
            /* Airborne Velocity Message
             */
            if (mm->ME_subtype == 1 || mm->ME_subtype == 2)
            {
                mm->EW_dir = (msg[5] & 4) >> 2;
                mm->EW_velocity = ((msg[5] & 3) << 8) | msg[6];
                mm->NS_dir = (msg[7] & 0x80) >> 7;
                mm->NS_velocity = ((msg[7] & 0x7F) << 3) | ((msg[8] & 0xE0) >> 5);
                mm->vert_rate_source = (msg[8] & 0x10) >> 4;
                mm->vert_rate_sign = (msg[8] & 0x08) >> 3;
                mm->vert_rate = ((msg[8] & 7) << 6) | ((msg[9] & 0xFC) >> 2);

                /* Compute velocity and angle from the two speed components.
                 */
                mm->velocity = (int)hypot(mm->NS_velocity, mm->EW_velocity);   /* hypot(x,y) == sqrt(x*x+y*y) */

                if (mm->velocity)
                {
                    int    ewV = mm->EW_velocity;
                    int    nsV = mm->NS_velocity;
                    double heading;

                    if (mm->EW_dir)
                        ewV *= -1;
                    if (mm->NS_dir)
                        nsV *= -1;
                    heading = atan2(ewV, nsV);

                    /* Convert to degrees.
                     */
                    mm->heading = (int)(heading * 360 / TWO_PI);
                    mm->heading_is_valid = true;

                    /* We don't want negative values but a [0 .. 360> scale.
                     */
                    if (mm->heading < 0)
                        mm->heading += 360;
                }
                else
                    mm->heading = 0;
            }
            else if (mm->ME_subtype == 3 || mm->ME_subtype == 4)
            {
                mm->heading_is_valid = msg[5] & (1 << 2);
                mm->heading = (int)(360.0 / 128) * (((msg[5] & 3) << 5) | (msg[6] >> 3));
            }
        }
    }
    mm->phase_corrected = false;  /* Set to 'true' by the caller if needed. */
}

/**
 * Return the hex-string for a 24-bit ICAO address.
 * Also look for the registration number and manufacturer from
 * the `Modes.aircraft_list`.
 */
const char* get_ICAO_details(int AA1, int AA2, int AA3)
{
    static char ret_buf[100];
    const aircraft_CSV* a;
    char* p = ret_buf;
    size_t n, left = sizeof(ret_buf);
    uint32_t addr = (AA1 << 16) + (AA2 << 8) + AA3;

    n = snprintf(p, left, "%02X%02X%02X", AA1, AA2, AA3);
    p += n;
    left -= n;

    a = aircraft_CSV_lookup_entry(addr);
    if (a && a->reg_num[0])
        snprintf(p, left, " (reg-num: %s, manuf: %s, call-sign: %s%s)",
            a->reg_num, a->manufact[0] ? a->manufact : "?", a->call_sign[0] ? a->call_sign : "?",
            ICAO_is_military(addr) ? ", Military" : "");
    return (ret_buf);
}

/**
 * This function gets a decoded Mode S Message and prints it on the screen
 * in a human readable format.
 */
void display_modeS_message(const modeS_message* mm)
{
    char   buf[200];
    char* p = buf;
    size_t left = sizeof(buf);
    int    i;

    /* Handle only addresses mode first.
     */
    if (Modes.only_addr)
    {
        puts(get_ICAO_details(mm->AA1, mm->AA2, mm->AA3));
        return;
    }

    /* Show the raw message.
     */
    *p++ = '*';
    left--;
    for (i = 0; i < mm->msg_bits / 8 && left > 5; i++)
    {
        snprintf(p, left, "%02x", mm->msg[i]);
        p += 2;
        left -= 2;
    }
    *p++ = ';';
    *p++ = '\n';
    *p = '\0';
    LOG_STDOUT("%s", buf);

    if (Modes.raw)
        return;         /* Enough for --raw mode */

    LOG_STDOUT("CRC: %06X (%s)\n", (int)mm->CRC, mm->CRC_ok ? "ok" : "wrong");
    if (mm->error_bit != -1)
        LOG_STDOUT("Single bit error fixed, bit %d\n", mm->error_bit);

    if (mm->sig_level > 0)
        LOG_STDOUT("RSSI: %.1lf dBFS\n", 10 * log10(mm->sig_level));

    if (mm->msg_type == 0)
    {
        /* DF 0 */
        LOG_STDOUT("DF 0: Short Air-Air Surveillance.\n");
        LOG_STDOUT("  Altitude       : %d %s\n", mm->altitude, mm->unit == MODES_UNIT_METERS ? "meters" : "feet");
        LOG_STDOUT("  ICAO Address   : %s\n", get_ICAO_details(mm->AA1, mm->AA2, mm->AA3));
    }
    else if (mm->msg_type == 4 || mm->msg_type == 20)
    {
        LOG_STDOUT("DF %d: %s, Altitude Reply.\n", mm->msg_type, mm->msg_type == 4 ? "Surveillance" : "Comm-B");
        LOG_STDOUT("  Flight Status  : %s\n", flight_status_str[mm->flight_status]);
        LOG_STDOUT("  DR             : %d\n", mm->DR_status);
        LOG_STDOUT("  UM             : %d\n", mm->UM_status);
        LOG_STDOUT("  Altitude       : %d %s\n", mm->altitude, mm->unit == MODES_UNIT_METERS ? "meters" : "feet");
        LOG_STDOUT("  ICAO Address   : %s\n", get_ICAO_details(mm->AA1, mm->AA2, mm->AA3));

        if (mm->msg_type == 20)
        {
            /** \todo 56 bits DF20 MB additional field. */
        }
    }
    else if (mm->msg_type == 5 || mm->msg_type == 21)
    {
        LOG_STDOUT("DF %d: %s, Identity Reply.\n", mm->msg_type, mm->msg_type == 5 ? "Surveillance" : "Comm-B");
        LOG_STDOUT("  Flight Status  : %s\n", flight_status_str[mm->flight_status]);
        LOG_STDOUT("  DR             : %d\n", mm->DR_status);
        LOG_STDOUT("  UM             : %d\n", mm->UM_status);
        LOG_STDOUT("  Squawk         : %d\n", mm->identity);
        LOG_STDOUT("  ICAO Address   : %s\n", get_ICAO_details(mm->AA1, mm->AA2, mm->AA3));

        if (mm->msg_type == 21)
        {
            /** \todo 56 bits DF21 MB additional field. */
        }
    }
    else if (mm->msg_type == 11)
    {
        /* DF 11 */
        LOG_STDOUT("DF 11: All Call Reply.\n");
        LOG_STDOUT("  Capability  : %s\n", capability_str[mm->ca]);
        LOG_STDOUT("  ICAO Address: %s\n", get_ICAO_details(mm->AA1, mm->AA2, mm->AA3));
    }
    else if (mm->msg_type == 17)
    {
        /* DF 17 */
        LOG_STDOUT("DF 17: ADS-B message.\n");
        LOG_STDOUT("  Capability     : %d (%s)\n", mm->ca, capability_str[mm->ca]);
        LOG_STDOUT("  ICAO Address   : %s\n", get_ICAO_details(mm->AA1, mm->AA2, mm->AA3));
        LOG_STDOUT("  Extended Squitter Type: %d\n", mm->ME_type);
        LOG_STDOUT("  Extended Squitter Sub : %d\n", mm->ME_subtype);
        LOG_STDOUT("  Extended Squitter Name: %s\n", get_ME_description(mm));

        /* Decode the extended squitter message. */
        if (mm->ME_type >= 1 && mm->ME_type <= 4)
        {
            /* Aircraft identification. */
            const char* ac_type_str[4] = {
                       "Aircraft Type D",
                       "Aircraft Type C",
                       "Aircraft Type B",
                       "Aircraft Type A"
            };
            LOG_STDOUT("    Aircraft Type  : %s\n", ac_type_str[mm->aircraft_type]);
            LOG_STDOUT("    Identification : %s\n", mm->flight);
        }
        else if (mm->ME_type >= 9 && mm->ME_type <= 18)
        {
            LOG_STDOUT("    F flag   : %s\n", mm->odd_flag ? "odd" : "even");
            LOG_STDOUT("    T flag   : %s\n", mm->UTC_flag ? "UTC" : "non-UTC");
            LOG_STDOUT("    Altitude : %d feet\n", mm->altitude);
            LOG_STDOUT("    Latitude : %d (not decoded)\n", mm->raw_latitude);
            LOG_STDOUT("    Longitude: %d (not decoded)\n", mm->raw_longitude);
        }
        else if (mm->ME_type == 19 && mm->ME_subtype >= 1 && mm->ME_subtype <= 4)
        {
            if (mm->ME_subtype == 1 || mm->ME_subtype == 2)
            {
                /* Velocity */
                LOG_STDOUT("    EW direction      : %d\n", mm->EW_dir);
                LOG_STDOUT("    EW velocity       : %d\n", mm->EW_velocity);
                LOG_STDOUT("    NS direction      : %d\n", mm->NS_dir);
                LOG_STDOUT("    NS velocity       : %d\n", mm->NS_velocity);
                LOG_STDOUT("    Vertical rate src : %d\n", mm->vert_rate_source);
                LOG_STDOUT("    Vertical rate sign: %d\n", mm->vert_rate_sign);
                LOG_STDOUT("    Vertical rate     : %d\n", mm->vert_rate);
            }
            else if (mm->ME_subtype == 3 || mm->ME_subtype == 4)
            {
                LOG_STDOUT("    Heading status: %d\n", mm->heading_is_valid);
                LOG_STDOUT("    Heading: %d\n", mm->heading);
            }
        }
        else if (mm->ME_type == 23)  /* Test Message */
        {
            if (mm->ME_subtype == 7)
                LOG_STDOUT("    Squawk: %04x\n", mm->identity);
            else LOG_STDOUT("    Unrecognized ME subtype: %d\n", mm->ME_subtype);
        }
        else if (mm->ME_type == 28)  /* Extended Squitter Aircraft Status */
        {
            if (mm->ME_subtype == 1)
            {
                LOG_STDOUT("    Emergency State: %s\n", emerg_state_str[(mm->msg[5] & 0xE0) >> 5]);
                LOG_STDOUT("    Squawk: %04x\n", mm->identity);
            }
            else
                LOG_STDOUT("    Unrecognized ME subtype: %d\n", mm->ME_subtype);
        }
#if 0
        /**\todo */
        else if (mm->ME_type == 29)  /* Target State + Status Message */
        {
        }
        /**\todo Ref: chapter 8 in `The-1090MHz-riddle.pdf` */
        else if (mm->ME_type == 31)  /* Aircraft operation status */
        {
        }
#endif
        else
        {
            LOG_STDOUT("    Unrecognized ME type: %d, subtype: %d\n", mm->ME_type, mm->ME_subtype);
            Modes.stat.unrecognized_ME++;
        }
    }
    else
    {
        LOG_STDOUT("DF %d with good CRC received (decoding still not implemented).\n", mm->msg_type);
    }
}


#define _vassert(v,suffix) assert((uint64_t)(test ## v ## Ex) == (uint64_t)(test ## v ## suffix))
#define _iqassert(suffix)   \
    do {                    \
    _vassert(I, suffix);    \
    _vassert(Q, suffix);    \
    } while(0)              \

/**
 * Turn I/Q samples pointed by `Modes.data` into the magnitude vector
 * pointed by `Modes.magnitude`.
 */
void compute_magnitude_vector()
{
    //uint16_t *m = Modes.magnitude;
    //uint32_t  i;

    /* Compute the magnitude vector. It's just `sqrt(I^2 + Q^2)`, but
     * we rescale to the 0-255 range to exploit the full resolution.
     */
    for (auto i = 0; i < RAW_IQ_DATA_LEN / 2; i++)
    {

        iq_value iq = Modes.iq[i];
#ifdef DEBUG_1090
        auto testIStruct = iq.i;
        auto testQStruct = iq.q;
        auto testIEx = Modes.data[i * 2];
        auto testQEx = Modes.data[i * 2 + 1];
        auto testIRaw = Modes.iqraw[i].value.i;
        auto testQRaw = Modes.iqraw[i].value.q;
        auto testIQ = Modes.iqraw[i].word;
        auto testIPacked = testIQ & 0xff;
        auto testQPacked = (testIQ & 0xff00) >> 8;
        _iqassert(Packed);
        _iqassert(Raw);
        _iqassert(Struct);
#endif

        /*if (iq.i != Modes.data[i * 2])
        {
            printf("bad");
        }
        if (iq.q != Modes.data[i * 2 + 1])
        {
            printf("bad");
        }*/

        /*int I = Modes.data [i] - 127;
        int Q = Modes.data[i+1] - 127;*/
#ifdef TEST_FAST_IQ
        int I = iq.i - 127;
        int Q = iq.q - 127;

#endif
        int ii = iq.i, qq = iq.q;
        //I2;
        

        /*I2 = iq.i & 0x80 ? iq.i - 127 : 127 - iq.i;
        Q2 = iq.q & 0x80 ? iq.q - 127 : 127 - iq.q;*/

#ifdef TEST_FAST_IQ
        if (I < 0) {
            I = -I;

            if (127 - iq.i != I)
            {
                printf("bad");
            }
        }
        if (Q < 0)
        {
            Q = -Q;

            if (127 - iq.q != Q)
            {
                printf("bad");
            }
        }

        if (I2 != I || Q2 != Q)
        {
            printf("bad");
    }
#else
//#define I I2
//#define Q Q2
#endif


        auto tmpMag2 = magnitude_multi_lut[ii >= 127 ? ii - 127 : 127 - ii][qq >= 127 ? qq - 127 : 127 - qq];
        /*auto tmpMag = magnitude_lut[129 * I + Q];

        assert(tmpMag == tmpMag2);*/
        Modes.magnitude[i] = tmpMag2;
        /*if (m[i / 2] != magnitude_lut[129 * I + Q])
            printf("bad");*/
}
    //return (m);
}

/**
 * Return -1 if the message is out of phase left-side
 * Return  1 if the message is out of phase right-size
 * Return  0 if the message is not particularly out of phase.
 *
 * Note: this function will access m[-1], so the caller should make sure to
 * call it only if we are not at the start of the current buffer.
 */
int detect_out_of_phase(const uint16_t* m)
{
    if (m[3] > m[2] / 3)
        return (1);
    if (m[10] > m[9] / 3)
        return (1);
    if (m[6] > m[7] / 3)
        return (-1);
    if (m[-1] > m[1] / 3)
        return (-1);
    return (0);
}

/**
 * This function does not really correct the phase of the message, it just
 * applies a transformation to the first sample representing a given bit:
 *
 * If the previous bit was one, we amplify it a bit.
 * If the previous bit was zero, we decrease it a bit.
 *
 * This simple transformation makes the message a bit more likely to be
 * correctly decoded for out of phase messages:
 *
 * When messages are out of phase there is more uncertainty in
 * sequences of the same bit multiple times, since `11111` will be
 * transmitted as continuously altering magnitude (high, low, high, low...)
 *
 * However because the message is out of phase some part of the high
 * is mixed in the low part, so that it is hard to distinguish if it is
 * a zero or a one.
 *
 * However when the message is out of phase passing from `0` to `1` or from
 * `1` to `0` happens in a very recognizable way, for instance in the `0 -> 1`
 * transition, magnitude goes low, high, high, low, and one of of the
 * two middle samples the high will be *very* high as part of the previous
 * or next high signal will be mixed there.
 *
 * Applying our simple transformation we make more likely if the current
 * bit is a zero, to detect another zero. Symmetrically if it is a one
 * it will be more likely to detect a one because of the transformation.
 * In this way similar levels will be interpreted more likely in the
 * correct way.
 */
void apply_phase_correction(uint16_t* m)
{
    int j;

    m += 16; /* Skip preamble. */
    for (j = 0; j < 2 * (MODES_LONG_MSG_BITS - 1); j += 2)
    {
        if (m[j] > m[j + 1])
        {
            /* One */
            m[j + 2] = (m[j + 2] * 5) / 4;
        }
        else
        {
            /* Zero */
            m[j + 2] = (m[j + 2] * 4) / 5;
        }
    }
}

#define m Modes.magnitude
#define mlen (RAW_IQ_DATA_LEN / 2)
/**
 * Detect a Mode S messages inside the magnitude buffer pointed by `m` and of
 * size `mlen` bytes. Every detected Mode S message is converted into a
 * stream of bits and passed to the function to display it.
 */
int detect_modeS()
{
    uint8_t  bits[MODES_LONG_MSG_BITS];
    uint8_t  msg[MODES_LONG_MSG_BITS / 2];
    uint16_t aux[MODES_LONG_MSG_BITS * 2];
    //uint32_t j;
    bool     use_correction = false;
    int      rc = 0;  /**\todo fix this */

    /* The Mode S preamble is made of impulses of 0.5 microseconds at
     * the following time offsets:
     *
     * 0   - 0.5 usec: first impulse.
     * 1.0 - 1.5 usec: second impulse.
     * 3.5 - 4   usec: third impulse.
     * 4.5 - 5   usec: last impulse.
     *
     * If we are sampling at 2 MHz, every sample in our magnitude vector
     * is 0.5 usec. So the preamble will look like this, assuming there is
     * an impulse at offset 0 in the array:
     *
     * 0   -----------------
     * 1   -
     * 2   ------------------
     * 3   --
     * 4   -
     * 5   --
     * 6   -
     * 7   ------------------
     * 8   --
     * 9   -------------------
     */
    for (auto j = 0; j < mlen - 2 * MODES_FULL_LEN; j++)
    {
        int  low, high, delta, i, errors;
        bool good_message = false;

        /*if (Modes.exit)
            break;*/

        if (use_correction)
            goto good_preamble;    /* We already checked it. */

         /* First check of relations between the first 10 samples
          * representing a valid preamble. We don't even investigate further
          * if this simple test is not passed.
          */

        auto m_j_ = m[j];

#define _local(off) auto m_j_##off##_ = m[j + off]
        //auto m_j_1_ = m[j + 1];
        _local(1);
        _local(2);
        _local(3);
        _local(4);
        _local(5);
        _local(6);
        _local(7);
        _local(8);
        _local(9);

        if (!(m_j_ > m_j_1_ &&
            m_j_1_ < m_j_2_ &&
            m_j_2_ > m_j_3_ &&
            m_j_3_ < m_j_ &&
            m_j_4_ < m_j_ &&
            m_j_5_ < m_j_ &&
            m_j_6_ < m_j_ &&
            m_j_7_ > m_j_8_ &&
            m_j_8_ < m_j_9_ &&
            m_j_9_ > m_j_6_))

        /*if (!(m[j] > m[j + 1] &&
            m[j + 1] < m[j + 2] &&
            m[j + 2] > m[j + 3] &&
            m[j + 3] < m[j] &&
            m[j + 4] < m[j] &&
            m[j + 5] < m[j] &&
            m[j + 6] < m[j] &&
            m[j + 7] > m[j + 8] &&
            m[j + 8] < m[j + 9] &&
            m[j + 9] > m[j + 6]))*/
        {
            __lassert(!(m[j] > m[j + 1] &&
                m[j + 1] < m[j + 2] &&
                m[j + 2] > m[j + 3] &&
                m[j + 3] < m[j] &&
                m[j + 4] < m[j] &&
                m[j + 5] < m[j] &&
                m[j + 6] < m[j] &&
                m[j + 7] > m[j + 8] &&
                m[j + 8] < m[j + 9] &&
                m[j + 9] > m[j + 6]));

#ifdef DEBUG_1090
            if ((Modes.debug & DEBUG_NOPREAMBLE) && m[j] > DEBUG_NOPREAMBLE_LEVEL)
                dump_raw_message("Unexpected ratio among first 10 samples", msg, m, j);
#endif
            continue;
        }

        /* The samples between the two spikes must be < than the average
         * of the high spikes level. We don't test bits too near to
         * the high levels as signals can be out of phase so part of the
         * energy can be in the near samples.
         */
        high = (m_j_ + m[j+2] + m[j+7] + m[j+9]) / 6;
        if (m[j + 4] >= high || m[j + 5] >= high)
        {
#ifdef DEBUG_1090
            if ((Modes.debug & DEBUG_NOPREAMBLE) && m[j] > DEBUG_NOPREAMBLE_LEVEL)
                dump_raw_message("Too high level in samples between 3 and 6", msg, m, j);
#endif
            continue;
        }

        /* Similarly samples in the range 11-14 must be low, as it is the
         * space between the preamble and real data. Again we don't test
         * bits too near to high levels, see above.
         */
        if (m[j + 11] >= high || m[j + 12] >= high || m[j + 13] >= high || m[j + 14] >= high)
        {
#ifdef DEBUG_1090
            if ((Modes.debug & DEBUG_NOPREAMBLE) && m[j] > DEBUG_NOPREAMBLE_LEVEL)
                dump_raw_message("Too high level in samples between 10 and 15", msg, m, j);
#endif
            continue;
        }

        Modes.stat.valid_preamble++;

    good_preamble:

        /* If the previous attempt with this message failed, retry using
         * magnitude correction.
          */
        if (use_correction)
        {
            memcpy(aux, m + j + MODES_PREAMBLE_US * 2, sizeof(aux));
            if (j && detect_out_of_phase(m + j))
            {
                apply_phase_correction(m + j);
                Modes.stat.out_of_phase++;
            }
            /** \todo Apply other kind of corrections. */
        }

        /* Decode all the next 112 bits, regardless of the actual message
         * size. We'll check the actual message type later.
         */
        errors = 0;
        for (i = 0; i < 2 * MODES_LONG_MSG_BITS; i += 2)
        {
            low = m[j + i + 2 * MODES_PREAMBLE_US];
            high = m[j + i + 2 * MODES_PREAMBLE_US + 1];
            delta = low - high;
            if (delta < 0)
                delta = -delta;

            if (i > 0 && delta < 256)
                bits[i / 2] = bits[i / 2 - 1];

            else if (low == high)
            {
                /* Checking if two adjacent samples have the same magnitude
                 * is an effective way to detect if it's just random noise
                 * that was detected as a valid preamble.
                 */
                bits[i / 2] = 2;    /* error */
                if (i < 2 * MODES_SHORT_MSG_BITS)
                    errors++;
            }
            else if (low > high)
            {
                bits[i / 2] = 1;
            }
            else
            {
                /* (low < high) for exclusion
                 */
                bits[i / 2] = 0;
            }
        }

        /* Restore the original message if we used magnitude correction.
         */
        if (use_correction)
            memcpy(m + j + 2 * MODES_PREAMBLE_US, aux, sizeof(aux));

        /* Pack bits into bytes
         */
        for (i = 0; i < MODES_LONG_MSG_BITS; i += 8)
        {
            msg[i / 8] = bits[i] << 7 |
                bits[i + 1] << 6 |
                bits[i + 2] << 5 |
                bits[i + 3] << 4 |
                bits[i + 4] << 3 |
                bits[i + 5] << 2 |
                bits[i + 6] << 1 |
                bits[i + 7];
        }

        int msg_type = msg[0] >> 3;
        int msg_len = modeS_message_len_by_type(msg_type) / 8;

        /* Last check, high and low bits are different enough in magnitude
         * to mark this as real message and not just noise? */
        delta = 0;
        for (i = 0; i < 8 * 2 * msg_len; i += 2)
        {
            delta += abs(m[j + i + 2 * MODES_PREAMBLE_US] -
                m[j + i + 2 * MODES_PREAMBLE_US + 1]);
        }
        delta /= 4 * msg_len;

        /* Filter for an average delta of three is small enough to let almost
         * every kind of message to pass, but high enough to filter some
         * random noise.
         */
        if (delta < 10 * 255)
        {
            use_correction = false;
            continue;
        }

        /* If we reached this point, and error is zero, we are very likely
         * with a Mode S message in our hands, but it may still be broken
         * and CRC may not be correct. This is handled by the next layer.
         */
        if (errors == 0 || (Modes.aggressive && errors <= 2))
        {
            modeS_message mm;
            double        signal_power = 0ULL;
            int           signal_len = mlen;
            uint32_t      k, mag;

            /* Decode the received message and update statistics
             */
            decode_modeS_message(&mm, msg);

            /* measure signal power
             */
            for (k = j; k < j + MODES_FULL_LEN; k++)
            {
                mag = m[k];
                signal_power += mag * mag;
            }
            mm.sig_level = signal_power / (65536.0 * signal_len);

            /* Update statistics.
             */
            if (mm.CRC_ok || use_correction)
            {
                if (errors == 0)
                    Modes.stat.demodulated++;
                if (mm.error_bit == -1)
                {
                    if (mm.CRC_ok)
                        Modes.stat.good_CRC++;
                    else Modes.stat.bad_CRC++;
                }
                else
                {
                    Modes.stat.bad_CRC++;
                    Modes.stat.fixed++;
                    if (mm.error_bit < MODES_LONG_MSG_BITS)
                        Modes.stat.single_bit_fix++;
                    else Modes.stat.two_bits_fix++;
                }
            }

            /* Output debug mode info if needed.
             */
            if (!use_correction)
            {
                if (Modes.debug & DEBUG_DEMOD)
                    dump_raw_message("Demodulated with 0 errors", msg, m, j);

                else if ((Modes.debug & DEBUG_BADCRC) && mm.msg_type == 17 && (!mm.CRC_ok || mm.error_bit != -1))
                    dump_raw_message("Decoded with bad CRC", msg, m, j);

                else if ((Modes.debug & DEBUG_GOODCRC) && mm.CRC_ok && mm.error_bit == -1)
                    dump_raw_message("Decoded with good CRC", msg, m, j);
            }

            /* Skip this message if we are sure it's fine.
             */
            if (mm.CRC_ok)
            {
                j += 2 * (MODES_PREAMBLE_US + (8 * msg_len));
                good_message = true;
                if (use_correction)
                    mm.phase_corrected = true;
            }

            /* Pass data to the next layer
             */
            modeS_user_message(&mm);
        }
        else
        {
            if ((Modes.debug & DEBUG_DEMODERR) && use_correction)
            {
                LOG_STDOUT("The following message has %d demod errors", errors);
                dump_raw_message("Demodulated with errors", msg, m, j);
            }
        }

        /* Retry with phase correction if possible.
         */
        if (!good_message && !use_correction)
        {
            j--;
            use_correction = true;
        }
        else
        {
            use_correction = false;
        }
    }
    return (rc);
}
#undef m
#undef mlen
/**
 * When a new message is available, because it was decoded from the
 * RTL/SDRplay device, file, or received in a TCP input port, or any other
 * way we can receive a decoded message, we call this function in order
 * to use the message.
 *
 * Basically this function passes a raw message to the upper layers for
 * further processing and visualization.
 */
void modeS_user_message(const modeS_message* mm)
{
    uint64_t num_clients;

    if (!mm->CRC_ok)
        return;

    Modes.stat.messages_total++;


    /* Track aircrafts in interactive mode or if we have some HTTP / SBS clients.
     */
    num_clients = Modes.stat.cli_accepted[MODES_NET_SERVICE_HTTP] +
        Modes.stat.cli_accepted[MODES_NET_SERVICE_SBS_OUT];

    if (Modes.interactive || num_clients > 0)
    {
        uint64_t  now = MSEC_TIME();
        aircraft* a = interactive_receive_data(mm, now);

        if (a && Modes.stat.cli_accepted[MODES_NET_SERVICE_SBS_OUT] > 0)
            modeS_send_SBS_output(mm, a);     /* Feed SBS output clients. */
    }

    /* In non-interactive mode, display messages on standard output.
     * In silent-mode, do nothing just to consentrate on network traces.
     */
    if (!Modes.interactive && !Modes.silent)
    {
        display_modeS_message(mm);
        if (!Modes.raw && !Modes.only_addr)
        {
            puts("");
            modeS_log("\n\n");
        }
    }

    /* Send data to connected clients.
     * In `--net-active` mode we have no clients.
     */
    if (Modes.net)
        modeS_send_raw_output(mm);
}

/**
 * Create a new aircraft structure.
 *
 * Store the printable hex-address as 6 digits since an ICAO address should never
 * contain more than 24 bits.
 *
 * \param in addr  the specific ICAO address.
 * \param in now   the current tick-time in milli-seconds.
 */
aircraft* aircraft_create(uint32_t addr, uint64_t now)
{
    aircraft* a = calloc(sizeof(*a), 1);

    if (a)
    {
        a->addr = addr;
        a->seen_first = now;
        a->seen_last = now;
        a->CSV = aircraft_CSV_lookup_entry(addr);
        a->show = A_SHOW_FIRST_TIME;

        /* We really can't tell if it's unique since we keep no global list of that yet
         */
        Modes.stat.unique_aircrafts++;
        if (a->CSV)
            Modes.stat.unique_aircrafts_CSV++;
    }
    return (a);
}

/**
 * Return the aircraft with the specified ICAO address, or NULL if no aircraft
 * exists with this ICAO address.
 *
 * \param in addr  the specific ICAO address.
 */
aircraft* aircraft_find(uint32_t addr)
{
    aircraft* a = Modes.aircrafts;

    while (a)
    {
        if (a->addr == addr)
            return (a);
        a = a->next;
    }
    return (NULL);
}

/**
 * Return the number of aircrafts we have now.
 */
int aircraft_numbers(void)
{
    aircraft* a = Modes.aircrafts;
    int       num;

    for (num = 0; a; num++)
        a = a->next;
    return (num);
}

/**
 * Distance between 2 points on a spherical earth.
 * This has up to 0.5% error because the earth isn't actually spherical
 * (but we don't use it in situations where that matters)
 *
 * \ref https://en.wikipedia.org/wiki/Great-circle_distance
 */
double great_circle_dist(pos_t pos1, pos_t pos2)
{
    double lat1 = TWO_PI * pos1.lat / 360.0;  /* convert to radians */
    double lon1 = TWO_PI * pos1.lon / 360.0;
    double lat2 = TWO_PI * pos2.lat / 360.0;
    double lon2 = TWO_PI * pos2.lon / 360.0;
    double angle;

    /* Avoid a 'NaN'
     */
    if (fabs(lat1 - lat2) < SMALL_VAL && fabs(lon1 - lon2) < SMALL_VAL)
        return (0.0);

    angle = sin(lat1) * sin(lat2) + cos(lat1) * cos(lat2) * cos(fabs(lon1 - lon2));

    /* Radius of the Earth * 'arcosine of angular distance'.
     */
    return (6371000.0 * acos(angle));
}

/**
 * Set this aircraft's distance to our home position.
 *
 * The reference time-tick is the latest of `a->odd_CPR_time` and `a->even_CPR_time`.
 */
void set_home_distance(aircraft* a)
{
    if (VALID_POS(Modes.home_pos) && VALID_POS(a->position))
    {
        double distance = great_circle_dist(a->position, Modes.home_pos);

        if (distance != 0.0)
            a->distance = distance;
        a->EST_position = a->position;
        a->EST_seen_last = (a->even_CPR_time > a->odd_CPR_time) ? a->even_CPR_time : a->odd_CPR_time;
    }
}

/**
 * From SDRangel's 'sdrbase/util/azel.cpp':
 *
 * Convert geodetic latitude to geocentric latitude;
 * angle from centre of Earth between the point and equator.
 *
 * https://en.wikipedia.org/wiki/Latitude#Geocentric_latitude
 */
double geocentric_latitude(double lat)
{
    double e2 = 0.00669437999014;

    return atan((1.0 - e2) * tan(lat));
}

/**
 * Convert spherical coordinate to cartesian.
 * Also calculates radius and a normal vector
 */
void spherical_to_cartesian(cartesian_t* cart, pos_t pos)
{
    double lat = TWO_PI * pos.lat / 360.0;
    double lon = TWO_PI * pos.lon / 360.0;
    double clat = geocentric_latitude(lat);

    cart->c_x = 6371000.0 * cos(lon) * cos(clat);
    cart->c_y = 6371000.0 * sin(lon) * cos(clat);
    cart->c_z = 6371000.0 * sin(clat);
}

/**
 * \ref https://keisan.casio.com/exec/system/1359533867
 */
void cartesian_to_spherical(pos_t* pos, cartesian_t cart)
{
    /* We do not need this; close to earth's radius = 6371000 m.
     *
     * double radius = sqrt (cart.c_x*cart.c_x + cart.c_y*cart.c_y + cart.c_z*cart->c_z);
     */
    pos->lon = 360.0 * atan2(cart.c_y, cart.c_x) / TWO_PI;
    pos->lat = 360.0 * atan2(hypot(cart.c_x, cart.c_y), cart.c_z) / TWO_PI;
}

/**
 * Return the distance between 2 cartesian points.
 */
double cartesian_distance(const cartesian_t* a, const cartesian_t* b)
{
    double dX = b->c_x - a->c_x;
    double dY = b->c_y - a->c_y;

    return hypot(dX, dY);
}

/**
 * Return the closest of `val1` and `val2` to `val`.
 */
double closest_to(double val, double val1, double val2)
{
    double diff1 = fabs(val1 - val);
    double diff2 = fabs(val2 - val);

    return (diff1 > diff2 ? val2 : val1);
}

/**
 * Set this aircraft's estimated distance to our home position.
 *
 * Assuming a constant good last heading and speed, calculate the
 * new position from that using the elapsed time.
 */
void set_est_home_distance(aircraft* a, uint64_t now)
{
    double      heading, distance, gc_distance, cart_distance, dX, dY;
    cartesian_t cpos;

    if (!Modes.home_pos_ok || a->speed == 0 || !a->heading_is_valid)
        return;

    if (!VALID_POS(a->EST_position) || a->EST_seen_last < a->seen_last)
        return;

    spherical_to_cartesian(&cpos, a->EST_position);

    /* Ensure heading is in range '[-Phi .. +Phi]'
     */
    if (a->heading >= 180)
        heading = TWO_PI * (a->heading - 360) / 360;
    else heading = TWO_PI * a->heading / 360;

    /* knots (1852 m/s) to distance (in meters) traveled in dT msec:
     */
    distance = 0.001852 * (double)a->speed * (now - a->EST_seen_last);
    a->EST_seen_last = now;

    dX = distance * sin(heading);
    dY = distance * cos(heading);
    cpos.c_x += dX;
    cpos.c_y += dY;

    cartesian_to_spherical(&a->EST_position, cpos);

    gc_distance = great_circle_dist(a->EST_position, Modes.home_pos);
    cart_distance = cartesian_distance(&cpos, &Modes.home_pos_cart);
    a->EST_distance = closest_to(a->EST_distance, gc_distance, cart_distance);

#if 0
    LOG_FILEONLY("addr %04X: heading: %+7.1lf, dX: %+8.3lf, dY: %+8.3lf, gc_distance: %6.1lf, cart_distance: %6.1lf\n",
        a->addr, 360.0 * heading / TWO_PI, dX, dY, gc_distance / 1000, cart_distance / 1000);
#endif
}

/**
 * Return a string showing this aircraft's distance to our home position.
 *
 * If `Modes.metric == true`, return it in kilo-meters. <br>
 * Otherwise Knots.
 */
const char* get_home_distance(const aircraft* a, const char** km_kts)
{
    static char buf[20];
    double divisor = Modes.metric ? 1000.0 : 1852.0;

    if (km_kts)
        *km_kts = Modes.metric ? "km" : "kts";

    if (a->distance <= SMALL_VAL)
        return (NULL);

    snprintf(buf, sizeof(buf), "%.1lf", a->distance / divisor);
    return (buf);
}

/**
 * As for `get_home_distance()`, but return the estimated distance.
 */
const char* get_est_home_distance(const aircraft* a, const char** km_kts)
{
    static char buf[20];
    double divisor = Modes.metric ? 1000.0 : 1852.0;

    if (km_kts)
        *km_kts = Modes.metric ? "km" : "kts";

    if (a->EST_distance <= SMALL_VAL)
        return (NULL);

    snprintf(buf, sizeof(buf), "%.1lf", a->EST_distance / divisor);
    return (buf);
}

/**
 * Helper function for decoding the **CPR** (*Compact Position Reporting*). <br>
 * Always positive MOD operation, used for CPR decoding.
 */
int CPR_mod_func(int a, int b)
{
    int res = a % b;

    if (res < 0)
        res += b;
    return (res);
}

/**
 * Helper function for decoding the **CPR** (*Compact Position Reporting*).
 *
 * Calculates **NL** *(lat)*; *Number of Longitude* zone. <br>
 * Given the latitude, this function returns the number of longitude zones between 1 and 59.
 *
 * The NL function uses the precomputed table from 1090-WP-9-14. <br>
 * Refer [The-1090MHz-riddle](./The-1090MHz-riddle.pdf), page 45 for the exact equation.
 */
int CPR_NL_func(double lat)
{
    if (lat < 0) lat = -lat;   /* Table is symmetric about the equator. */
    if (lat < 10.47047130) return (59);
    if (lat < 14.82817437) return (58);
    if (lat < 18.18626357) return (57);
    if (lat < 21.02939493) return (56);
    if (lat < 23.54504487) return (55);
    if (lat < 25.82924707) return (54);
    if (lat < 27.93898710) return (53);
    if (lat < 29.91135686) return (52);
    if (lat < 31.77209708) return (51);
    if (lat < 33.53993436) return (50);
    if (lat < 35.22899598) return (49);
    if (lat < 36.85025108) return (48);
    if (lat < 38.41241892) return (47);
    if (lat < 39.92256684) return (46);
    if (lat < 41.38651832) return (45);
    if (lat < 42.80914012) return (44);
    if (lat < 44.19454951) return (43);
    if (lat < 45.54626723) return (42);
    if (lat < 46.86733252) return (41);
    if (lat < 48.16039128) return (40);
    if (lat < 49.42776439) return (39);
    if (lat < 50.67150166) return (38);
    if (lat < 51.89342469) return (37);
    if (lat < 53.09516153) return (36);
    if (lat < 54.27817472) return (35);
    if (lat < 55.44378444) return (34);
    if (lat < 56.59318756) return (33);
    if (lat < 57.72747354) return (32);
    if (lat < 58.84763776) return (31);
    if (lat < 59.95459277) return (30);
    if (lat < 61.04917774) return (29);
    if (lat < 62.13216659) return (28);
    if (lat < 63.20427479) return (27);
    if (lat < 64.26616523) return (26);
    if (lat < 65.31845310) return (25);
    if (lat < 66.36171008) return (24);
    if (lat < 67.39646774) return (23);
    if (lat < 68.42322022) return (22);
    if (lat < 69.44242631) return (21);
    if (lat < 70.45451075) return (20);
    if (lat < 71.45986473) return (19);
    if (lat < 72.45884545) return (18);
    if (lat < 73.45177442) return (17);
    if (lat < 74.43893416) return (16);
    if (lat < 75.42056257) return (15);
    if (lat < 76.39684391) return (14);
    if (lat < 77.36789461) return (13);
    if (lat < 78.33374083) return (12);
    if (lat < 79.29428225) return (11);
    if (lat < 80.24923213) return (10);
    if (lat < 81.19801349) return (9);
    if (lat < 82.13956981) return (8);
    if (lat < 83.07199445) return (7);
    if (lat < 83.99173563) return (6);
    if (lat < 84.89166191) return (5);
    if (lat < 85.75541621) return (4);
    if (lat < 86.53536998) return (3);
    if (lat < 87.00000000) return (2);
    return (1);
}

int CPR_N_func(double lat, int isodd)
{
    int nl = CPR_NL_func(lat) - isodd;

    if (nl < 1)
        nl = 1;
    return (nl);
}

double CPR_Dlong_func(double lat, int isodd)
{
    return 360.0 / CPR_N_func(lat, isodd);
}

/**
 * Decode the **CPR** (*Compact Position Reporting*).
 *
 * This algorithm comes from: <br>
 * http://www.lll.lu/~edward/edward/adsb/DecodingADSBposition.html.
 *
 * A few remarks:
 *
 * \li 131072 is 2^17 since CPR latitude and longitude are encoded in 17 bits.
 * \li We assume that we always received the odd packet as last packet for
 *     simplicity. This may provide a position that is less fresh of a few seconds.
 */
void decode_CPR(aircraft* a)
{
    const double AirDlat0 = 360.0 / 60;
    const double AirDlat1 = 360.0 / 59;
    double lat0 = a->even_CPR_lat;
    double lat1 = a->odd_CPR_lat;
    double lon0 = a->even_CPR_lon;
    double lon1 = a->odd_CPR_lon;

    /* Compute the Latitude Index "j"
     */
    int    j = (int)floor(((59 * lat0 - 60 * lat1) / 131072) + 0.5);
    double rlat0 = AirDlat0 * (CPR_mod_func(j, 60) + lat0 / 131072);
    double rlat1 = AirDlat1 * (CPR_mod_func(j, 59) + lat1 / 131072);

    if (rlat0 >= 270)
        rlat0 -= 360;

    if (rlat1 >= 270)
        rlat1 -= 360;

    /* Check that both are in the same latitude zone, or return.
     */
    if (CPR_NL_func(rlat0) != CPR_NL_func(rlat1))
        return;

    /* Compute ni and the longitude index m
     */
    if (a->even_CPR_time > a->odd_CPR_time)
    {
        /* Use even packet */
        int ni = CPR_N_func(rlat0, 0);
        int m = (int)floor((((lon0 * (CPR_NL_func(rlat0) - 1)) -
            (lon1 * CPR_NL_func(rlat0))) / 131072) + 0.5);
        a->position.lon = CPR_Dlong_func(rlat0, 0) * (CPR_mod_func(m, ni) + lon0 / 131072);
        a->position.lat = rlat0;
    }
    else
    {
        /* Use odd packet */
        int ni = CPR_N_func(rlat1, 1);
        int m = (int)floor((((lon0 * (CPR_NL_func(rlat1) - 1)) -
            (lon1 * CPR_NL_func(rlat1))) / 131072.0) + 0.5);
        a->position.lon = CPR_Dlong_func(rlat1, 1) * (CPR_mod_func(m, ni) + lon1 / 131072);
        a->position.lat = rlat1;
    }

    if (a->position.lon > 180)
        a->position.lon -= 360;

    set_home_distance(a);
}

/**
 * Receive new messages and populate the interactive mode with more info.
 */
aircraft* interactive_receive_data(const modeS_message* mm, uint64_t now)
{
    aircraft* a;
    char* p;
    uint32_t  addr;

    if (!mm->CRC_ok)
        return (NULL);

    addr = (mm->AA1 << 16) | (mm->AA2 << 8) | mm->AA3;

    /* Loookup our aircraft or create a new one.
     */
    a = aircraft_find(addr);
    if (!a)
    {
        a = aircraft_create(addr, now);
        if (!a)
            return (NULL);          /* Not fatal; there could be available memory later */

        LIST_ADD_HEAD(aircraft, &Modes.aircrafts, a);
    }
    else
    {
        /* If it is an already known aircraft, move it on head
         * so we keep aircrafts ordered by received message time.
         *
         * However move it on head only if at least one second elapsed
         * since the aircraft that is currently on head sent a message,
         * otherwise with multiple aircrafts at the same time we have an
         * useless shuffle of positions on the screen.
         */
#if 0
        if (Modes.aircrafts != a && (now - a->seen_last) >= 1000)
        {
            aircraft* aux = Modes.aircrafts;

            while (aux->next != a)
                aux = aux->next;

            /* Now we are a node before the aircraft to remove.
             */
            aux->next = aux->next->next; /* removed. */

            /* Add on head */
            a->next = Modes.aircrafts;
            Modes.aircrafts = a;
    }
#endif
}

    a->seen_last = now;
    a->messages++;

    /* Ensure number of elements is 2^n.
     */
    assert((DIM(a->sig_levels) & -(int)DIM(a->sig_levels)) == DIM(a->sig_levels));

    a->sig_levels[a->sig_idx++] = mm->sig_level;
    a->sig_idx &= DIM(a->sig_levels) - 1;

    if (mm->msg_type == 5 || mm->msg_type == 21)
    {
        if (mm->identity)
            a->identity = mm->identity;       /* Set thee Squawk code. */
        else a->identity = 0;
    }

    if (mm->msg_type == 0 || mm->msg_type == 4 || mm->msg_type == 20)
    {
        a->altitude = mm->altitude;
    }
    else if (mm->msg_type == 17)
    {
        if (mm->ME_type >= 1 && mm->ME_type <= 4)
        {
            memcpy(a->flight, mm->flight, sizeof(a->flight));
            p = a->flight + sizeof(a->flight) - 1;
            while (*p == ' ')
                *p-- = '\0';  /* Remove trailing spaces */

        }
        else if ((mm->ME_type >= 9 && mm->ME_type <= 18) || /* Airborne Position (Baro Altitude) */
            (mm->ME_type >= 20 && mm->ME_type <= 22))   /* Airborne Position (GNSS Height) */
        {
            a->altitude = mm->altitude;
            if (mm->odd_flag)
            {
                a->odd_CPR_lat = mm->raw_latitude;
                a->odd_CPR_lon = mm->raw_longitude;
                a->odd_CPR_time = now;
            }
            else
            {
                a->even_CPR_lat = mm->raw_latitude;
                a->even_CPR_lon = mm->raw_longitude;
                a->even_CPR_time = now;
            }

            /* If the two reports are less than 10 minutes apart, compute the position.
             * This used to be '10 sec', but I used some code from:
             *   https://github.com/Mictronics/readsb/blob/master/track.c
             *
             * which says:
             *   A wrong relative position decode would require the aircraft to
             *   travel 360-100=260 NM in the 10 minutes of position validity.
             *   This is impossible for planes slower than 1560 knots/Mach 2.3 over the ground.
             */
            int64_t t_diff = (int64_t)(a->even_CPR_time - a->odd_CPR_time);

            if (llabs(t_diff) <= 60 * 10 * 1000)
                decode_CPR(a);
            // else LOG_FILEONLY ("t_diff for '%04X' too large: %lld sec.\n", a->addr, t_diff/1000);
        }
        else if (mm->ME_type == 19)
        {
            if (mm->ME_subtype == 1 || mm->ME_subtype == 2)
            {
                a->speed = mm->velocity;
                a->heading = mm->heading;
                a->heading_is_valid = mm->heading_is_valid;
            }
        }
    }
    return (a);
}

/**
 * Show information for a single aircraft.
 *
 * If `a->show == A_SHOW_FIRST_TIME`, print in GREEN colour.
 * If `a->show == A_SHOW_LAST_TIME`, print in RED colour.
 *
 * \param in a    the aircraft to show.
 * \param in now  the currect tick-timer in milli-seconds.
 */
void interactive_show_aircraft(const aircraft* a, uint64_t now)
{
    int   altitude = a->altitude;
    int   speed = a->speed;
    char  alt_buf[10] = "  - ";
    char  lat_buf[10] = "   - ";
    char  lon_buf[10] = "    - ";
    char  speed_buf[8] = " - ";
    char  heading_buf[8] = " - ";
    char  distance_buf[10] = " - ";
    char  RSSI_buf[7] = " - ";
    bool  restore_colour = false;
    const char* reg_num = "";
    const char* call_sign = "";
    const char* flight = "";
    const char* distance = NULL;
    const char* est_distance = NULL;
    const char* km_kts = NULL;
    double  sig_avg = 0;
    int64_t ms_diff;

    /* Convert units to metric if --metric was specified.
     */
    if (Modes.metric)
    {
        altitude = (int)round((double)altitude / 3.2828);
        speed = (int)round((double)speed * 1.852);
    }

    /* Get the average RSSI from last 4 messages.
     */
    for (uint8_t i = 0; i < DIM(a->sig_levels); i++)
        sig_avg += a->sig_levels[i];
    sig_avg /= DIM(a->sig_levels);

    if (sig_avg > 1E-5)
        snprintf(RSSI_buf, sizeof(RSSI_buf), "% +4.1lf", 10 * log10(sig_avg));

    if (altitude)
        snprintf(alt_buf, sizeof(alt_buf), "%5d", altitude);

    if (a->position.lat)
        snprintf(lat_buf, sizeof(lat_buf), "% +7.03f", a->position.lat);

    if (a->position.lon)
        snprintf(lon_buf, sizeof(lon_buf), "% +8.03f", a->position.lon);

    if (speed)
        snprintf(speed_buf, sizeof(speed_buf), "%4d", speed);

    if (a->heading_is_valid)
        snprintf(heading_buf, sizeof(heading_buf), "%3d", a->heading);

    if (Modes.home_pos_ok)
    {
        distance = get_home_distance(a, &km_kts);
        est_distance = get_est_home_distance(a, &km_kts);
        if (est_distance)
            snprintf(distance_buf, sizeof(distance_buf), "%s", est_distance);
    }

    if (a->CSV)
    {
        if (a->CSV->reg_num[0])
            reg_num = a->CSV->reg_num;
#if 0
        if (a->CSV->call_sign[0])
            call_sign = a->CSV->call_sign;
#endif
    }

    if (!a->flight[0] && call_sign[0])
        flight = call_sign;
    else flight = a->flight;

    if (a->show == A_SHOW_FIRST_TIME)
    {
        setcolor(COLOUR_GREEN);
        restore_colour = true;
        LOG_FILEONLY("plane '%06X' entering.\n", a->addr);
    }
    else if (a->show == A_SHOW_LAST_TIME)
    {
        setcolor(COLOUR_RED);
        restore_colour = true;
        LOG_FILEONLY("plane '%06X' leaving. Active for %.1lf sec. Distance: %s/%s %s.\n",
            a->addr, (double)(now - a->seen_first) / 1000.0,
            distance ? distance : "-",
            est_distance ? est_distance : "-", km_kts);
    }

    ms_diff = (now - a->seen_last);
    if (ms_diff < 0LL)  /* clock wrapped */
        ms_diff = 0L;

    printf("%06X %-9.9s %-8s %-5s     %-5s %-7s %-8s   %-5s ", a->addr, flight, reg_num, alt_buf, speed_buf, lat_buf, lon_buf, heading_buf);
    printf("%6s  %5s %5u  %2llu sec \n", distance_buf, RSSI_buf, a->messages, (long long)( ms_diff / 1000));

    if (restore_colour)
        setcolor(0);
}

/**
 * Show the currently captured aircraft information on screen.
 * \param in now  the currect tick-timer in mill-seconds
 */
void interactive_show_data(uint64_t now)
{
    static int spin_idx = 0;
    static int old_count = -1;
    int        count = 0;
    char       spinner[] = "|/-\\";
    aircraft* a = Modes.aircrafts;

    /* Unless debug or raw-mode is active, clear the screen to remove old info.
     * But only if current number of aircrafts is less than last time. This is to
     * avoid an annoying blinking of the console.
     */
    if (Modes.debug == 0)
    {
        if (old_count == -1 || aircraft_numbers() < old_count)
            clrscr();
        gotoxy(1, 1);
    }

    setcolor(COLOUR_WHITE);
    printf("ICAO   Callsign  Reg-num  Altitude  Speed   Lat      Long    Hdg     Dist   RSSI   Msg  Seen %c\n"
        "----------------------------------------------------------------------------------------------\n",
        spinner[spin_idx & 3]);
    spin_idx++;
    setcolor(0);

    while (a && count < Modes.interactive_rows && !Modes.exit)
    {
        if (a->show != A_SHOW_NONE)
        {
            set_est_home_distance(a, now);
            interactive_show_aircraft(a, now);
        }

        /* Simple state-machine for the plane's show-state
         */
        if (a->show == A_SHOW_FIRST_TIME)
            a->show = A_SHOW_NORMAL;
        else if (a->show == A_SHOW_LAST_TIME)
            a->show = A_SHOW_NONE;      /* don't show again before deleting it */

        a = a->next;
        count++;
    }
    old_count = count;
}

/**
 * Called from `background_tasks()` 4 times per second.
 *
 * If we don't receive new nessages within `Modes.interactive_ttl`
 * milli-seconds, we remove the aircraft from the list.
 */
void remove_stale_aircrafts(uint64_t now)
{
    aircraft* a, * a_next;

    for (a = Modes.aircrafts; a; a = a_next)
    {
        int64_t diff = (int64_t)(now - a->seen_last);

        a_next = a->next;

        /* Mark this plane for a "last time" view on next refresh?
         */
        if (a->show == A_SHOW_NORMAL && diff >= Modes.interactive_ttl - 1000)
        {
            a->show = A_SHOW_LAST_TIME;
        }
        else if (diff > Modes.interactive_ttl)
        {
            /* Remove the element from the linked list.
             */
            LIST_DELETE(aircraft, &Modes.aircrafts, a);
            free(a);
        }
    }
}

/**
 * Remove all active aircrafts from the list.
 */
void free_all_aircrafts(void)
{
    aircraft* a = Modes.aircrafts;
    aircraft* prev = NULL;

    while (a)
    {
        aircraft* next = a->next;

        free(a);
        if (!prev)
            Modes.aircrafts = next;
        else prev->next = next;
        a = next;
    }
}

/**
 * Read raw IQ samples from `stdin` and filter everything that is lower than the
 * specified level for more than 256 samples in order to reduce
 * example file size.
 *
 * Will print to `stdout` in BINARY-mode.
 */
int strip_mode(int level)
{
    int i, q;
    uint64_t c = 0;

    _setmode(_fileno(stdin), O_BINARY);
    _setmode(_fileno(stdout), O_BINARY);

    while ((i = getchar()) != EOF && (q = getchar()) != EOF)
    {
        if (abs(i - 127) < level && abs(q - 127) < level)
        {
            c++;
            if (c > 4 * MODES_PREAMBLE_US)
                continue;
        }
        else
            c = 0;

        putchar(i);
        putchar(q);
    }
    return (0);
}

/*
 * Taken from Dump1090-FA's 'net_io.c':
 */
char* aircraft_json_Dump1090_OL3(const char* url_path, int* len)
{
    MODES_NOTUSED(url_path);
    MODES_NOTUSED(len);
    return (NULL);
}

/**
 * Return a description of the receiver in JSON.
 { "version" : "0.1-gv", "refresh" : 1000, "history" : 3 }
 */
char* receiver_to_json(void)
{
    int history_size = DIM(Modes.json_aircraft_history) - 1;

    /* work out number of valid history entries
     */
    if (!Modes.json_aircraft_history[history_size].ptr)
        history_size = Modes.json_aircraft_history_next;

    return mg_mprintf("{%Q: %s, "    // "version", DUMP1090_VERSION
        "%Q: %llu, "  // "refresh", Modes.json_interval
        "%Q: %d, "    // "history", history_size
        "%Q: %.6g, "  // "lat",     Modes.home_pos.lat; if 'Modes.home_pos_ok == false', this is 0.
        "%Q: %.6g}",  // "lon",     Modes.home_pos.lon; ditto
        "version", DUMP1090_VERSION,
        "refresh", Modes.json_interval,
        "history", history_size,
        "lat", Modes.home_pos.lat,
        "lon", Modes.home_pos.lon);
}

/**
 * Return a malloced JSON description of the active planes.
 * But only those whose latitude and longitude is known.
 *
 * Since various Web-clients expects different elements in this returned
 * JSON array, add those which is approprite for that Web-clients only.
 *
 * E.g. an extended web-client want an empty array like this:
 * ```
 *  { "now": 1656176445, "messages" : 1,
 *    "aircraft" : []
 *  }
 * ```
 * Or an array with 1 element like this:
 * ```
 * {
 *   "now:": 1656176445, "messages": 1,
 *   "aircraft": [{"hex":"47807D", "flight":"", "lat":60.280609, "lon":5.223715, "altitude":875, "track":199, "speed":96}]
 * }
 * ```
 */
char* aircrafts_to_json(int* num_planes, bool extended_client)
{
    struct timeval tv_now;
    aircraft* a = Modes.aircrafts;

    *num_planes = 0;

#if 0
    char* ret_buf;
    int   aircraft_size = 1024;
    char* aircraft_json = malloc(aircraft_size);

    while (a)
    {
        int    altitude = a->altitude;
        int    speed = a->speed;
        size_t f_len = strlen(a->flight);

        /* Convert units to metric if --metric was specified.
         * But option '--metric' has no effect on the Web-page yet.
         */
        if (Modes.metric)
        {
            altitude = (int)(double)(a->altitude / 3.2828);
            speed = (int)(1.852 * (double)a->speed);
        }

        mg_asprintf(&aircraft_json, aircraft_size,
            "%Q: %Q"     // "hex": "addr"
            "%Q: %.*Q"   // "flight": a->flight
            "%Q: %f"     // "lat": a->position.lat
            "%Q: %f"     // "lon": a->position.lon
            "hex", a->addr,
            "flight", f_len, a->flight,
            "lat", a->position.lat,
            "lon", a->position.lon,
            "altitude", altitude,
            "track", a->heading,
            "speed", speed);

        a = a->next;
    }

    mg_asprintf(&ret_buf, 0,
        "{%Q: %lu.%03lu,"
        "%Q: %llu:, "
        "%Q: [ %s ]}",      // Json array of aircrafts
        "now", tv_now.tv_sec, tv_now.tv_usec / 1000,
        "messages", Modes.stat.messages_total,
        "aircraft", aircraft_json);

    free(aircraft_json);
    return (ret_buf);

#else
    int    buflen = 1024;        /* The initial buffer is incremented as needed. */
    char* buf = malloc(buflen);
    char* p = buf;
    int    l;

    if (!buf)
        return (NULL);

    if (extended_client)
    {
        _gettimeofday(&tv_now, NULL);
        l = snprintf(p, buflen, "{\"now\": %lu.%03lu, \"messages\": %llu, \"aircraft\" : [",
            (unsigned long)tv_now.tv_sec, (unsigned long)tv_now.tv_usec / 1000, Modes.stat.messages_total);

        p += l;
        buflen -= l;
    }
    else
    {
        *p++ = '[';
        buflen--;
    }


    while (a)
    {
        int altitude = a->altitude;
        int speed = a->speed;

        /* Convert units to metric if --metric was specified.
         * But option '--metric' has no effect on the Web-page yet.
         */
        if (Modes.metric)
        {
            altitude = (int)(double)(a->altitude / 3.2828);
            speed = (int)(1.852 * (double)a->speed);
        }

        //if (VALID_POS(a->position))
        {
            size_t f_len = strlen(a->flight);

            while (a->flight[f_len - 1] == ' ') /* do not send trailing spaces */
                f_len--;

            if (VALID_POS(a->position))
            {
                l = snprintf(p, buflen,
                    "{\"hex\": \"%06X\", \"flight\": \"%.*s\", \"lat\": %f, \"lon\": %f, \"altitude\": %d, \"track\": %d, \"gs\": %d",
                    a->addr, (unsigned int)f_len, a->flight, a->position.lat, a->position.lon, altitude, a->heading, speed);
            }
            else
            {
                l = snprintf(p, buflen,
                    "{\"hex\": \"%06X\", \"flight\": \"%.*s\", \"altitude\": %d, \"track\": %d, \"gs\": %d",
                    a->addr, (unsigned int)f_len, a->flight, altitude, a->heading, speed);
            }

            p += l;
            buflen -= l;

            if (extended_client)
            {
                l = snprintf(p, buflen, ", \"rssi\": %f, \"type\": \"%s\", \"messages\": %u, \"seen\": %lu, \"seen_pos\": %lu",
                    10 * log10(a->sig_levels[a->sig_idx == 0 ? 3 : a->sig_idx - 1]),
                    "adsb_icao", a->messages, 2, 1 /* tv_now.tv_sec - a->seen_first/1000 */);
                p += l;
                buflen -= l;
            }

            strcpy(p, "},\n");
            p += 3;
            buflen -= 3;

            (*num_planes)++;

            /* Resize if needed.
             */
            if (buflen < 256)
            {
                int used = p - buf;

                buflen += 1024;    /* Our increment. */
                buf = realloc(buf, used + buflen);
                if (!buf)
                {
                    *num_planes = 0;
                    return (NULL);
                }
                p = buf + used;
            }
        }
        a = a->next;
    }

    /* Remove the final comma if any, and close the json array
     */
    if (p[-2] == ',')
        p -= 2;

    *p++ = ']';
    if (extended_client)
        *p++ = '}';
    *p = '\0';
    return (buf);
#endif
}

/**
 * Returns a 'connection *' based on the remote 'addr' and 'service'.
 * This can be either client or server.
 */
connection* connection_get_addr(const mg_addr* addr, intptr_t service, bool is_server)
{
    connection* srv;

    assert(service >= MODES_NET_SERVICE_RAW_OUT && service < MODES_NET_SERVICES_NUM);

    for (srv = Modes.connections[service]; srv; srv = srv->next)
    {
        if (srv->service == service && !memcmp(&srv->addr, addr, sizeof(srv->addr)))
            return (srv);
    }
    is_server ? Modes.stat.srv_unknown[service]++ :   /* Should never happen */
        Modes.stat.cli_unknown[service]++;
    return (NULL);
}

/**
 * Free a specific connection, client or server.
 */
void connection_free(connection* this_conn, intptr_t service)
{
    connection* conn;
    uint32_t    conn_id = (uint32_t)-1;
    int         is_server = -1;

    if (!this_conn)
        return;

    for (conn = Modes.connections[service]; conn; conn = conn->next)
    {
        if (conn != this_conn)
            continue;

        LIST_DELETE(connection, &Modes.connections[service], conn);
        if (conn->conn->is_accepted)
        {
            Modes.stat.cli_removed[service]++;
            is_server = 0;
        }
        else
        {
            Modes.stat.srv_removed[service]++;
            is_server = 1;
        }
        conn_id = conn->id;
        free(conn);
        break;
    }

    TRACE(DEBUG_NET2, "Freeing %s %u for service \"%s\".\n",
        is_server == 1 ? "server" :
        is_server == 0 ? "client" : "?",
        conn_id, handler_descr(service));
}

/*
 * Free all connections in all services.
 */
unsigned connection_free_all(void)
{
    intptr_t service;
    int      num = 0;

    for (service = MODES_NET_SERVICE_RAW_OUT; service < MODES_NET_SERVICES_NUM; service++)
    {
        connection* conn, * conn_next;

        for (conn = Modes.connections[service]; conn; conn = conn_next)
        {
            conn_next = conn->next;
            connection_free(conn, service);
            num++;
        }
    }
    return (num);
}

/**
 * Iterate over all the listening connections and send a `msg` to
 * all clients in the specified `service`.
 *
 * There can only be 1 service that matches this. But this
 * service can have many clients.
 *
 * \note
 *  \li This function is not used for sending HTTP data.
 *  \li This function is not called when `--net-active` is used.
 */
void connection_send(intptr_t service, const void* msg, size_t len)
{
    connection* c;
    int         found = 0;

    for (c = Modes.connections[service]; c; c = c->next)
    {
        if (c->service != service)
            continue;

        mg_send(c->conn, msg, len);   /* if write fails, the client gets freed in connection_handler() */
        found++;
    }
    if (found > 0)
        TRACE(DEBUG_NET, "Sent %zd bytes to %d clients in service \"%s\".\n",
            len, found, handler_descr(service));
}

/**
 * Handlers for the network services.
 *
 * We use Mongoose for handling all the server and low-level network I/O. <br>
 * We register event-handlers that gets called on important network events.
 *
 * Keep the data for our 4 network services in this structure.
 */
net_service modeS_net_services[MODES_NET_SERVICES_NUM] = {
          { &Modes.raw_out,  NULL, "Raw TCP output", MODES_NET_PORT_RAW_OUT },
          { &Modes.raw_in,   NULL, "Raw TCP input",  MODES_NET_PORT_RAW_IN },
          { &Modes.sbs_out,  NULL, "SBS TCP output", MODES_NET_PORT_SBS },
          { &Modes.sbs_in,   NULL, "SBS TCP input",  MODES_NET_PORT_SBS },
          { &Modes.http_out, NULL, "HTTP server",    MODES_NET_PORT_HTTP }
};

/* Mongoose event names.
 */
const char* event_name(int ev)
{
    if (ev >= MG_EV_USER)
    {
        static char buf[20];
        snprintf(buf, sizeof(buf), "MG_EV_USER%d", ev - MG_EV_USER);
        return (buf);
    }

    return (ev == MG_EV_OPEN ? "MG_EV_OPEN" :     /* Event on 'connect()', 'listen()' and 'accept()'. Ignored */
        ev == MG_EV_POLL ? "MG_EV_POLL" :
        ev == MG_EV_RESOLVE ? "MG_EV_RESOLVE" :
        ev == MG_EV_CONNECT ? "MG_EV_CONNECT" :
        ev == MG_EV_ACCEPT ? "MG_EV_ACCEPT" :
        ev == MG_EV_READ ? "MG_EV_READ" :
        ev == MG_EV_WRITE ? "MG_EV_WRITE" :
        ev == MG_EV_CLOSE ? "MG_EV_CLOSE" :
        ev == MG_EV_ERROR ? "MG_EV_ERROR" :
        ev == MG_EV_HTTP_MSG ? "MG_EV_HTTP_MSG" :
        ev == MG_EV_HTTP_CHUNK ? "MG_EV_HTTP_CHUNK" :
        ev == MG_EV_WS_OPEN ? "MG_EV_WS_OPEN" :
        ev == MG_EV_WS_MSG ? "MG_EV_WS_MSG" :
        ev == MG_EV_WS_CTL ? "MG_EV_WS_CTL" :
        ev == MG_EV_MQTT_CMD ? "MG_EV_MQTT_CMD" :   /* Can never occur here */
        ev == MG_EV_MQTT_MSG ? "MG_EV_MQTT_MSG" :   /* Can never occur here */
        ev == MG_EV_MQTT_OPEN ? "MG_EV_MQTT_OPEN" :  /* Can never occur here */
        ev == MG_EV_SNTP_TIME ? "MG_EV_SNTP_TIME"    /* Can never occur here */
        : "?");
}

mg_connection* handler_conn(intptr_t service)
{
    assert(service >= MODES_NET_SERVICE_RAW_OUT && service < MODES_NET_SERVICES_NUM);
    return (*modeS_net_services[service].conn);
}

uint16_t* handler_num_connections(intptr_t service)
{
    assert(service >= MODES_NET_SERVICE_RAW_OUT && service < MODES_NET_SERVICES_NUM);
    return (&modeS_net_services[service].num_connections);
}

const char* handler_descr(intptr_t service)
{
    assert(service >= MODES_NET_SERVICE_RAW_OUT && service < MODES_NET_SERVICES_NUM);
    return (modeS_net_services[service].descr);
}

u_short handler_port(intptr_t service)
{
    assert(service >= MODES_NET_SERVICE_RAW_OUT && service < MODES_NET_SERVICES_NUM);
    return (modeS_net_services[service].port);
}

char* handler_error(intptr_t service)
{
    assert(service >= MODES_NET_SERVICE_RAW_OUT && service < MODES_NET_SERVICES_NUM);
    return (modeS_net_services[service].last_err);
}

bool handler_sending(intptr_t service)
{
    assert(service >= MODES_NET_SERVICE_RAW_OUT && service < MODES_NET_SERVICES_NUM);
    return (modeS_net_services[service].active_send);
}

void net_flushall(void)
{
    mg_connection* conn;
    unsigned       num_active = 0;
    unsigned       num_passive = 0;
    unsigned       num_unknown = 0;
    unsigned       total_rx = 0;
    unsigned       total_tx = 0;

    for (conn = Modes.mgr.conns; conn; conn = conn->next)
    {
        total_rx += conn->recv.len;
        total_tx += conn->send.len;

        mg_iobuf_free(&conn->recv);
        mg_iobuf_free(&conn->send);

        if (conn->is_accepted || conn->is_listening)
            num_passive++;
        else if (conn->is_client)
            num_active++;
        else num_unknown++;
    }
    TRACE(DEBUG_NET,
        "Flushed %u active connections, %u passive, %u unknown. Remaining bytes: %u Rx, %u Tx.\n",
        num_active, num_passive, num_unknown, total_rx, total_tx);
}

int print_server_errors(void)
{
    int   service, num = 0;
    char* err;

    for (service = MODES_NET_SERVICE_RAW_OUT; service < MODES_NET_SERVICES_NUM; service++)
    {
        err = handler_error(service);
        if (err)
        {
            LOG_STDERR("%s\n", err);
            free(err);
            num++;
        }
    }
    return (num);
}

/**
 * \todo
 * The event handler for WebSocket control messages.
 */
void connection_handler_websocket(mg_connection* conn, const char* remote, int ev, void* ev_data)
{
    mg_ws_message* ws = ev_data;

    TRACE(DEBUG_NET, "WebSocket event %s from client at %s has %zd bytes for us.\n",
        event_name(ev), remote, conn->recv.len);

    if (ev == MG_EV_WS_MSG)
    {
    }
    else if (ev == MG_EV_WS_CTL)
    {
        Modes.stat.HTTP_websockets++;
    }
    MODES_NOTUSED(ws);
}

const char* get_client_headers(const connection* cli, const char* hdr)
{
    static char buf[100];
    int    len = snprintf(buf, sizeof(buf), "%s\r\n", hdr);

    if (cli->keep_alive)
        strncpy(buf + len, "Connection: keep-alive\r\n", sizeof(buf) - len - 1);
    return (buf);
}

/*
 * Generated arrays from
 *   xxd -i favicon.png
 *   xxd -i favicon.ico
 */
#include "favicon.c"

 /**
  * The event handler for HTTP traffic.
  */
int connection_handler_http(mg_connection* conn,
    int            ev,
    void* ev_data,
    char* request_data,
    size_t         request_size,
    char** ret_data)
{
    mg_http_message* hm = ev_data;
    connection* cli;
    bool             is_dump1090, is_extended;
    const char* content = NULL;
    const char* uri, * ext;
    char* request, * end;
    char             header[1000];
    int              header_len;

    *ret_data = NULL;
    *request_data = '\0';

    if ((ev != MG_EV_HTTP_MSG && ev != MG_EV_HTTP_CHUNK) || strncmp(hm->head.ptr, "GET /", 5))
        return (400);  /* Bad Request */

    request = strncpy(alloca(hm->head.len + 1), hm->head.ptr, hm->head.len);
    strncpy(request_data, request, request_size);

    uri = request + strlen("GET ");
    end = strchr(uri, ' ');
    if (!end)
    {
        conn->is_closing = 1;
        return (400);         /* Bad Request */
    }

    *end = '\0';

    end = strchr(uri, '?');
    if (end)
    {
        *end = '\0';
    }



    end = strchr(request_data + 4, ' '); /* extract only the important file-part */
    if (end)
        *end = '\0';

    Modes.stat.HTTP_get_requests++;

    if (str_startswith(request, "GET /data/receiver.json"))
    {
        char* data = receiver_to_json();

        if (!data)
            return (444);  /* No Response */

        *ret_data = data;
        TRACE(DEBUG_NET, "Feeding client %lu with receiver-data:\n%s\n", conn->id, data);

        mg_http_reply(conn, 200, MODES_CONTENT_TYPE_JSON "\r\n", data);
        return (200);
    }

    if (str_startswith(request, "GET /chunks/chunks.json"))
    {
    }

    /* What we normally expect with the default 'web_root/gmap.html'
     */
    is_dump1090 = (str_startswith(request, "GET /data.json"));

    /* Or From an OpenLayers3/Tar1090/FlightAware web-client
     */
    is_extended = str_startswith(request, "GET /data/aircraft.json");

    if (is_dump1090 || is_extended)
    {
        int   num_planes;
        char* data = aircrafts_to_json(&num_planes, is_extended);

        if (!data)
        {
            conn->is_closing = 1;
            return (444);       /* No Response */
        }
        *ret_data = data;

        /* This is rather inefficient way to pump data over to the client.
         * Better use a WebSocket instead.
         */
        if (is_extended)
            mg_http_reply(conn, 200, NULL, "%s", data);
        else mg_http_reply(conn, 200, MODES_CONTENT_TYPE_JSON "\r\n", data);
        return (200);
    }

    cli = connection_get_addr(&conn->rem, MODES_NET_SERVICE_HTTP, false);

    /* Redirect a 'GET /' to a 'GET /' + 'web_page'
     */
    if (!strcmp(request, "GET /"))
    {
        char redirect[50 + MG_PATH_MAX];

        if (hm->proto.len >= 9 && strncmp(hm->proto.ptr, "HTTP/1.1", 8))
        {
            Modes.stat.HTTP_keep_alive_recv++;
            cli->keep_alive = 1;
        }
        snprintf(redirect, sizeof(redirect),
            "%sLocation: %s\r\n", cli->keep_alive ? "Connection: keep-alive\r\n" : "", basename(Modes.web_page));
        mg_http_reply(conn, 303, redirect, "");
        return (303);
    }

    /**
     * \todo Check header for a "Upgrade: websocket" and call mg_ws_upgrade()?
     */
    if (!_stricmp(request, "GET /echo"))
    {
        TRACE(DEBUG_NET, "Got WebSocket echo:\n'%.*s'.\n", (int)hm->head.len, hm->head.ptr);
        mg_ws_upgrade(conn, hm, "WS test");
        return (200);
    }

    ext = strrchr(uri, '.');
    if (ext)
    {
        char file[MG_PATH_MAX];
        int  rc = 200;        /* Assume status 200 OK */

        if (!_stricmp(ext, ".html"))
            content = MODES_CONTENT_TYPE_HTML;
        else if (!_stricmp(ext, ".css"))
            content = MODES_CONTENT_TYPE_CSS;
        else if (!_stricmp(ext, ".js"))
            content = MODES_CONTENT_TYPE_JS;
        else if (!_stricmp(ext, ".json"))
            content = MODES_CONTENT_TYPE_JSON;
        else if (!_stricmp(ext, ".png"))
            content = MODES_CONTENT_TYPE_PNG;

        if (!_stricmp(request, "GET /favicon.png"))
        {

            TRACE(DEBUG_NET, "Sending \"favicon.png\" to cli: %lu.\n", conn->id);

            header_len = snprintf(header, sizeof(header),
                "HTTP/1.1 200 OK\r\nContent-Type: %s\r\n"
                "Content-Length: %u\r\n%s\r\n",
                content, favicon_png_len,
                cli->keep_alive ? "Connection: keep-alive\r\n" : "");
            mg_send(conn, header, header_len);
            mg_send(conn, favicon_png, favicon_png_len);
        }
        else if (!_stricmp(request, "GET /favicon.ico"))  /* Other browsers may want a 'favicon.ico' file */
        {
            TRACE(DEBUG_NET, "Sending \"favicon.ico\" to cli: %lu.\n", conn->id);

            header_len = snprintf(header, sizeof(header),
                "HTTP/1.1 200 OK\r\nContent-Type: %s\r\n"
                "Content-Length: %u\r\n%s\r\n",
                content, favicon_ico_len,
                cli->keep_alive ? "Connection: keep-alive\r\n" : "");
            mg_send(conn, header, header_len);
            mg_send(conn, favicon_ico, favicon_ico_len);
        }
        else
        {
            struct mg_http_serve_opts opts;
            struct stat st;

            memset(&opts, '\0', sizeof(opts));
            opts.extra_headers = get_client_headers(cli, content);
            opts.page404 = PAGE_404_HTML;
            snprintf(file, sizeof(file), "%s\\%s", Modes.web_root, uri + 1);
            mg_http_serve_file(conn, hm, file, &opts);
            if (stat(file, &st) != 0)
            {
                Modes.stat.HTTP_404_responses++;
                rc = 404;
            }
        }
        if (cli->keep_alive)
            Modes.stat.HTTP_keep_alive_sent++;

        return (rc);
    }

    mg_http_reply(conn, 404, cli->keep_alive ? "Connection: keep-alive\r\n" : "", "Not found\n");
    Modes.stat.HTTP_404_responses++;
    return (404);
}

/**
 * The timer callback for an active `connect()`.
 */
void connection_timeout(void* fn_data)
{
    INT_PTR service = (int)(INT_PTR)fn_data;
    char    err[200];
    char    host_port[100];

    snprintf(host_port, sizeof(host_port), modeS_net_services[service].is_ip6 ? "[%s]:%u" : "%s:%u",
        modeS_net_services[service].host, modeS_net_services[service].port);

    snprintf(err, sizeof(err), "Timeout in connection to service \"%s\" on host %s",
        handler_descr(service), host_port);
    modeS_net_services[service].last_err = _strdup(err);
    TRACE(DEBUG_NET, "%s.\n", err);

    sigint_handler(0);  /* break out of main_data_loop()  */
}

/**
 * The event handler for ALL network I/O.
 */
void connection_handler(mg_connection* this_conn, int ev, void* ev_data, void* fn_data)
{
    connection* conn;
    char* remote, remote_buf[100];
    uint16_t    port;
    INT_PTR     service = (int)(INT_PTR)fn_data;   /* 'fn_data' is arbitrary user data */

    if (Modes.exit)
        return;

    if (ev == MG_EV_POLL)    /* Ignore this events */
        return;

    if (ev == MG_EV_ERROR)
    {
        char err[200];

        remote = modeS_net_services[service].host;
        port = modeS_net_services[service].port;

        if (remote && service >= MODES_NET_SERVICE_RAW_OUT && service < MODES_NET_SERVICES_NUM)
        {
            snprintf(err, sizeof(err), "Connection to %s:%u failed: %s", remote, port, (const char*)ev_data);
            modeS_net_services[service].last_err = _strdup(err);
            TRACE(DEBUG_NET, "Error: %s\n", err);
            sigint_handler(0);   /* break out of main_data_loop()  */
        }
        return;
    }

    remote = mg_straddr(&this_conn->rem, remote_buf, sizeof(remote_buf));

    if (ev == MG_EV_OPEN)
    {
        TRACE(DEBUG_NET2, "MG_EV_OPEN for host %s\n", remote);
        return;
    }

    if (ev == MG_EV_RESOLVE)
    {
        TRACE(DEBUG_NET, "Resolved to host %s\n", remote);
        return;
    }

    if (ev == MG_EV_CONNECT)
    {
        mg_timer_free(&Modes.mgr.timers, &modeS_net_services[service].timer);
        conn = calloc(sizeof(*conn), 1);
        if (!conn)
        {
            this_conn->is_closing = 1;
            return;
        }

        conn->conn = this_conn;      /* Keep a copy of the active connection */
        conn->service = service;
        conn->id = this_conn->id;
        conn->addr = this_conn->rem;

        LIST_ADD_TAIL(connection, &Modes.connections[service], conn);
        ++(*handler_num_connections(service));  /* should never go above 1 */
        Modes.stat.srv_connected[service]++;
        TRACE(DEBUG_NET, "Connected to host %s (service \"%s\")\n", remote, handler_descr(service));
        return;
    }

    if (ev == MG_EV_ACCEPT)
    {
        conn = calloc(sizeof(*conn), 1);
        if (!conn)
        {
            this_conn->is_closing = 1;
            return;
        }

        conn->conn = this_conn;      /* Keep a copy of the passive (listen) connection */
        conn->service = service;
        conn->id = this_conn->id;
        conn->addr = this_conn->rem;

        LIST_ADD_TAIL(connection, &Modes.connections[service], conn);
        ++(*handler_num_connections(service));
        Modes.stat.cli_accepted[service]++;

        TRACE(DEBUG_NET, "New client %u (service \"%s\") from %s.\n",
            conn->id, handler_descr(service), remote);
        return;
    }

    if (ev == MG_EV_READ)
    {
        const mg_str* data = (const mg_str*)ev_data;

        Modes.stat.bytes_recv[service] += data->len;

        TRACE(DEBUG_NET2, "MG_EV_READ from %s (service \"%s\")\n", remote, handler_descr(service));

        if (service == MODES_NET_SERVICE_RAW_IN)
        {
            conn = connection_get_addr(&this_conn->rem, service, false);
            connection_read(conn, decode_hex_message, false);

            conn = connection_get_addr(&this_conn->rem, service, true);
            connection_read(conn, decode_hex_message, true);
        }
        else if (service == MODES_NET_SERVICE_SBS_IN)
        {
            conn = connection_get_addr(&this_conn->rem, service, true);
            connection_read(conn, decode_SBS_message, true);
        }
        return;
    }

    if (ev == MG_EV_WRITE)         /* Increment our own send() bytes */
    {
        Modes.stat.bytes_sent[service] += *(const int*)ev_data;
        TRACE(DEBUG_NET2, "writing %d bytes to client %lu (%s)\n", *(const int*)ev_data, this_conn->id, remote);
        return;
    }

    if (ev == MG_EV_CLOSE)
    {
        conn = connection_get_addr(&this_conn->rem, service, false);
        connection_free(conn, service);

        conn = connection_get_addr(&this_conn->rem, service, true);
        connection_free(conn, service);
        --(*handler_num_connections(service));
        return;
    }

    if (service == MODES_NET_SERVICE_HTTP)
    {
        char  request_data[100];
        char* response_data;
        int   rc;

        if (this_conn->is_websocket && (ev == MG_EV_WS_MSG || ev == MG_EV_WS_CTL))
            connection_handler_websocket(this_conn, remote, ev, ev_data);

        rc = connection_handler_http(this_conn, ev, ev_data, request_data, sizeof(request_data) - 1, &response_data);

        LOG_FILEONLY("HTTP %d for '%s' (client %lu), response: '%.400s'.. \n",
            rc, request_data, this_conn->id, response_data ? response_data : "<none>");

        free(response_data);
    }
}

/**
 * Setup a connection for a service.
 * Active or passive (`listen == true`).
 */
mg_connection* connection_setup(intptr_t service, bool listen, bool sending)
{
    mg_connection* conn = NULL;
    char           url[50];

    if (listen)
    {
        snprintf(url, sizeof(url), "tcp://0.0.0.0:%u", modeS_net_services[service].port);
        if (service == MODES_NET_SERVICE_HTTP)
            conn = mg_http_listen(&Modes.mgr, url, connection_handler, (void*)service);
        else conn = mg_listen(&Modes.mgr, url, connection_handler, (void*)service);
        modeS_net_services[service].active_send = sending;
    }
    else
    {
        /* For an active connect(), we'll get one of these event in connection_handler():
         *  - MG_EV_ERROR    -- the `--host-xx` argument was not resolved or the connection failed or timed out.
         *  - MG_EV_RESOLVE  -- the `--host-xx` argument was successfully resolved to an IP-address.
         *  - MG_EV_CONNECT  -- successfully connected.
         */
        const char* fmt = (modeS_net_services[service].is_ip6 ? "tcp://[%s]:%u" : "tcp://%s:%u");

        snprintf(url, sizeof(url), fmt, modeS_net_services[service].host, modeS_net_services[service].port);
        mg_timer_add(&Modes.mgr, MODES_CONNECT_TIMEOUT, 0, connection_timeout, (void*)service);
        modeS_net_services[service].active_send = sending;

        LOG_STDOUT("Connecting to %s for service \"%s\".\n", url, handler_descr(service));
        conn = mg_connect(&Modes.mgr, url, connection_handler, (void*)service);
    }

    if (conn && (Modes.debug & DEBUG_NET2))
        conn->is_hexdumping = 1;
    return (conn);
}

/**
 * Initialize the Mongoose network manager and:
 *  \li start the 2 active network services.
 *  \li or start the 4 listening (passive) network services.
 */
int modeS_init_net(void)
{
    struct stat st;

    mg_mgr_init(&Modes.mgr);

    if (Modes.net_active)
    {
        if (modeS_net_services[MODES_NET_SERVICE_RAW_IN].host)
            Modes.raw_in = connection_setup(MODES_NET_SERVICE_RAW_IN, false, false);

        if (modeS_net_services[MODES_NET_SERVICE_SBS_IN].host)
            Modes.sbs_in = connection_setup(MODES_NET_SERVICE_SBS_IN, false, false);

        if (!Modes.raw_in && !Modes.sbs_in)
        {
            LOG_STDERR("No hosts for any `--net-active` services specified.\n");
            return (1);
        }
    }
    else
    {
        Modes.raw_out = connection_setup(MODES_NET_SERVICE_RAW_OUT, true, true);
        Modes.raw_in = connection_setup(MODES_NET_SERVICE_RAW_IN, true, false);
        Modes.sbs_out = connection_setup(MODES_NET_SERVICE_SBS_OUT, true, true);
        Modes.http_out = connection_setup(MODES_NET_SERVICE_HTTP, true, true);

        if (!Modes.raw_out || !Modes.raw_in || !Modes.sbs_out || !Modes.http_out)
        {
            LOG_STDERR("Fail to set-up listen socket(s).\n");
            return (1);
        }
    }

    if (Modes.http_out)
    {
        char full_name[MG_PATH_MAX];

        snprintf(full_name, sizeof(full_name), "%s\\%s", Modes.web_root, basename(Modes.web_page));
        TRACE(DEBUG_NET, "Web-page: \"%s\"\n", full_name);

        if (stat(full_name, &st) != 0)
        {
            LOG_STDERR("Web-page \"%s\" does not exist.\n", full_name);
            return (1);
        }
        if (((st.st_mode) & _S_IFMT) != _S_IFREG)
        {
            LOG_STDERR("Web-page \"%s\" is not a regular file.\n", full_name);
            return (1);
        }
    }
    return (0);
}

/**
 * Write raw output to TCP clients.
 */
void modeS_send_raw_output(const modeS_message* mm)
{
    char  msg[10 + 2 * MODES_LONG_MSG_BYTES];
    char* p = msg;

    if (!handler_sending(MODES_NET_SERVICE_RAW_OUT))
        return;

    *p++ = '*';
    mg_hex(&mm->msg, mm->msg_bits / 8, p);
    p = strchr(p, '\0');
    *p++ = ';';
    *p++ = '\n';
    connection_send(MODES_NET_SERVICE_RAW_OUT, msg, p - msg);
}

/**
 * Write SBS output to TCP clients (Base Station format).
 */
void modeS_send_SBS_output(const modeS_message* mm, const aircraft* a)
{
    char msg[MODES_MAX_SBS_SIZE], * p = msg;
    int  emergency = 0, ground = 0, alert = 0, spi = 0;

    if (mm->msg_type == 4 || mm->msg_type == 5 || mm->msg_type == 21)
    {
        /**\note
         * identity is calculated/kept in base10 but is actually
         * octal (07500 is represented as 7500)
         */
        if (mm->identity == 7500 || mm->identity == 7600 || mm->identity == 7700)
            emergency = -1;
        if (mm->flight_status == 1 || mm->flight_status == 3)
            ground = -1;
        if (mm->flight_status == 2 || mm->flight_status == 3 || mm->flight_status == 4)
            alert = -1;
        if (mm->flight_status == 4 || mm->flight_status == 5)
            spi = -1;
    }

    /* Field 11 could contain the call-sign we can get from `aircraft_find()::reg_num`.
     */
    if (mm->msg_type == 0)
    {
        p += sprintf(p, "MSG,5,,,%02X%02X%02X,,,,,,,%d,,,,,,,,,,",
            mm->AA1, mm->AA2, mm->AA3, mm->altitude);
    }
    else if (mm->msg_type == 4)
    {
        p += sprintf(p, "MSG,5,,,%02X%02X%02X,,,,,,,%d,,,,,,,%d,%d,%d,%d",
            mm->AA1, mm->AA2, mm->AA3, mm->altitude, alert, emergency, spi, ground);
    }
    else if (mm->msg_type == 5)
    {
        p += sprintf(p, "MSG,6,,,%02X%02X%02X,,,,,,,,,,,,,%d,%d,%d,%d,%d",
            mm->AA1, mm->AA2, mm->AA3, mm->identity, alert, emergency, spi, ground);
    }
    else if (mm->msg_type == 11)
    {
        p += sprintf(p, "MSG,8,,,%02X%02X%02X,,,,,,,,,,,,,,,,,",
            mm->AA1, mm->AA2, mm->AA3);
    }
    else if (mm->msg_type == 17 && mm->ME_type == 4)
    {
        p += sprintf(p, "MSG,1,,,%02X%02X%02X,,,,,,%s,,,,,,,,0,0,0,0",
            mm->AA1, mm->AA2, mm->AA3, mm->flight);
    }
    else if (mm->msg_type == 17 && mm->ME_type >= 9 && mm->ME_type <= 18)
    {
        if (a->position.lat == 0 && a->position.lon == 0)
            p += sprintf(p, "MSG,3,,,%02X%02X%02X,,,,,,,%d,,,,,,,0,0,0,0",
                mm->AA1, mm->AA2, mm->AA3, mm->altitude);
        else p += sprintf(p, "MSG,3,,,%02X%02X%02X,,,,,,,%d,,,%1.5f,%1.5f,,,0,0,0,0",
            mm->AA1, mm->AA2, mm->AA3, mm->altitude, a->position.lat, a->position.lon);
    }
    else if (mm->msg_type == 17 && mm->ME_type == 19 && mm->ME_subtype == 1)
    {
        int vr = (mm->vert_rate_sign == 0 ? 1 : -1) * 64 * (mm->vert_rate - 1);

        p += sprintf(p, "MSG,4,,,%02X%02X%02X,,,,,,,,%d,%d,,,%i,,0,0,0,0",
            mm->AA1, mm->AA2, mm->AA3, (signed int)a->speed, a->heading, vr);
    }
    else if (mm->msg_type == 21)
    {
        p += sprintf(p, "MSG,6,,,%02X%02X%02X,,,,,,,,,,,,,%d,%d,%d,%d,%d",
            mm->AA1, mm->AA2, mm->AA3, mm->identity, alert, emergency, spi, ground);
    }
    else
        return;

    *p++ = '\n';
    connection_send(MODES_NET_SERVICE_SBS_OUT, msg, p - msg);
}

/**
 * Turn an hex digit into its 4 bit decimal value.
 * Returns -1 if the digit is not in the 0-F range.
 */
int hex_digit_val(int c)
{
    c = tolower(c);
    if (c >= '0' && c <= '9')
        return (c - '0');
    if (c >= 'a' && c <= 'f')
        return (c - 'a' + 10);
    return (-1);
}

/**
 * This function decodes a string representing a Mode S message in
 * raw hex format like: `*8D4B969699155600E87406F5B69F;<eol>`
 *
 * The string is supposed to be at the start of the client buffer
 * and NUL-terminated. It accepts both '\n' and '\r\n' terminated records.
 *
 * The message is passed to the higher level layers, so it feeds
 * the selected screen output, the network output and so forth.
 *
 * If the message looks invalid, it is silently discarded.
 */
void decode_hex_message(mg_iobuf* msg, int loop_cnt)
{
    modeS_message mm;
    uint8_t       bin_msg[MODES_LONG_MSG_BYTES];
    int           len, j;
    uint8_t* hex;
    uint8_t* end = memchr(msg->buf, '\n', msg->len);

    if (!end)
    {
        if (!Modes.interactive)
            LOG_STDOUT("RAW(%d): Bogus msg: '%.*s'...\n", loop_cnt, (int)msg->len, msg->buf);
        Modes.stat.unrecognized_raw++;
        mg_iobuf_del(msg, 0, msg->len);
        return;
    }

    *end++ = '\0';
    if (end[-2] == '\r')
        end[-2] = '\0';

    /* Remove spaces on the left and on the right.
     */
    hex = msg->buf;
    len = end - msg->buf - 1;
    while (len && isspace(hex[len - 1]))
    {
        hex[len - 1] = '\0';
        len--;
    }
    while (isspace(*hex))
    {
        hex++;
        len--;
    }

    /* Check it's format.
     */
    if (len < 2)
    {
        Modes.stat.empty_raw++;
        mg_iobuf_del(msg, 0, end - msg->buf);
        return;
    }
    if (hex[0] != '*' || !memchr(msg->buf, ';', len))
    {
        Modes.stat.unrecognized_raw++;
        mg_iobuf_del(msg, 0, end - msg->buf);
        return;
    }

    /* Turn the message into binary.
     */
    hex++;   /* Skip `*` and `;` */
    len -= 2;
    if (len > 2 * MODES_LONG_MSG_BYTES)   /* Too long message... broken. */
    {
        Modes.stat.unrecognized_raw++;
        mg_iobuf_del(msg, 0, end - msg->buf);
        return;
    }

    for (j = 0; j < len; j += 2)
    {
        int high = hex_digit_val(hex[j]);
        int low = hex_digit_val(hex[j + 1]);

        if (high == -1 || low == -1)
        {
            Modes.stat.unrecognized_raw++;
            mg_iobuf_del(msg, 0, end - msg->buf);
            return;
        }
        bin_msg[j / 2] = (high << 4) | low;
    }
    mg_iobuf_del(msg, 0, end - msg->buf);
    Modes.stat.good_raw++;
    decode_modeS_message(&mm, bin_msg);
    modeS_user_message(&mm);
}

/**
 * \todo
 * Ref: http://woodair.net/sbs/article/barebones42_socket_data.htm
 */
int modeS_recv_SBS_input(mg_iobuf* msg, modeS_message* mm)
{
    memset(mm, '\0', sizeof(*mm));

    //decode 'msg' and fill 'mm'
    //modeS_user_message (&mm);
    MODES_NOTUSED(msg);
    return (0);
}

/**
 * This function decodes a string representing a Mode S message in
 * SBS format (Base Station) like: `MSG,5,1,1,4CC52B,1,2021/09/20,23:30:43.897,2021/09/20,23:30:43.901,,38000,,,,,,,0,,0,`
 *
 * It accepts both '\n' and '\r\n' terminated records.
 */
void decode_SBS_message(mg_iobuf* msg, int loop_cnt)
{
    modeS_message mm;
    uint8_t* end = memchr(msg->buf, '\n', msg->len);

    if (!end)
    {
        if (!Modes.interactive)
            LOG_STDOUT("SBS(%d): Bogus msg: '%.*s'...\n", loop_cnt, (int)msg->len, msg->buf);
        Modes.stat.unrecognized_SBS++;
        mg_iobuf_del(msg, 0, msg->len);
        return;
    }
    *end++ = '\0';
    if (end[-2] == '\r')
        end[-2] = '\0';

    if (!Modes.interactive)
        LOG_STDOUT("SBS(%d): '%s'\n", loop_cnt, msg->buf);

    if (!strncmp((char*)msg->buf, "MSG,", 4))
    {
        modeS_recv_SBS_input(msg, &mm);
        Modes.stat.good_SBS++;
    }
    mg_iobuf_del(msg, 0, end - msg->buf);
}

/**
 * This function reads client/server data for services:
 *  \li `MODES_NET_SERVICE_RAW_IN` or
 *  \li `MODES_NET_SERVICE_SBS_IN`
 *
 * when the event `MG_EV_READ` is received in `connection_handler()`.
 *
 * The message is supposed to be separated by the next message by the
 * separator 'sep', that is a NUL-terminated C string.
 *
 * The `handler` function is responsible for freeing `msg` as it consumes each record
 * in the `msg`. This `msg` can consist of several records or incomplete records since
 * Mongoose uses non-blocking sockets.
 *
 * The `tools/SBS_client.py` script is sending this in "RAW-OUT" test-mode:
 * ```
 *  *8d4b969699155600e87406f5b69f;\n
 * ```
 *
 * This message shows up as ICAO "4B9696" and Reg-num "TC-ETV" in
 * `--interactive` mode.
 */
void connection_read(connection* conn, msg_handler handler, bool is_server)
{
    mg_iobuf* msg;
    int       loops;

    if (!conn)
        return;

    msg = &conn->conn->recv;
    if (msg->len == 0)
    {
        TRACE(DEBUG_NET2, "No msg for %s.\n", is_server ? "server" : "client");
        return;
    }

    for (loops = 0; msg->len > 0; loops++)
    {
        TRACE(DEBUG_NET2, "%s msg(%d): '%.*s'.\n", is_server ? "server" : "client", loops, (int)msg->len, msg->buf);
        (*handler) (msg, loops);
    }
}

/**
 * Show the program usage
 */
void show_help(const char* fmt, ...)
{
    if (fmt)
    {
        va_list args;

        va_start(args, fmt);
        vprintf(fmt, args);
        va_end(args);
    }
    else
        printf("A 1090 MHz receiver, decoder and web-server for\n%s.\n", ADS_B_ACRONYM);

    printf("  Usage: %s [options]\n"
        "  General options:\n"
        "    --aggressive             Use a more aggressive CRC check (two bits fixes, ...).\n"
        "    --database <file>        The CSV file for the aircraft database\n"
        "                             (default: \"%s\").\n"
        "    --debug <flags>          Debug mode; see below for details.\n"
        "    --infile <filename>      Read data from file (use `-' for stdin).\n"
        "    --interactive            Interactive mode refreshing data on screen.\n"
        "    --interactive-rows <num> Max number of rows in interactive mode (default: 15).\n"
        "    --interactive-ttl <sec>  Remove aircraft if not seen for <sec> (default: %u).\n"
        "    --logfile <file>         Enable logging to file (default: off)\n"
        "    --loop <N>               With --infile, read the file in a loop <N> times (default: 2^63).\n"
        "    --max-messages <N>       Max number of messages to process (default: Inf).\n"
        "    --metric                 Use metric units (meters, km/h, ...).\n"
        "    --no-fix                 Disable single-bits error correction using CRC.\n"
        "    --no-crc-check           Disable checking CRC of messages (discouraged).\n"
        "    --only-addr              Show only ICAO addresses (testing purposes).\n"
        "    --raw                    Show only the raw Mode-S hex message.\n"
        "    --silent                 Silent mode for testing network I/O (together with '--debug n').\n"
        "    --strip <level>          Strip IQ file removing samples below level.\n"
        "    -h, --help               Show this help.\n\n",
        Modes.who_am_I, Modes.aircraft_db, MODES_INTERACTIVE_TTL / 1000);

    printf("  Network options:\n"
        "    --net                    Enable network listening services.\n"
        "    --net-active             Enable network active services. `--net-only` is implied.\n"
        "    --net-only               Enable just networking, no physical device or file.\n"
        "    --net-http-port <port>   HTTP server port (default: %u).\n"
        "    --net-ri-port <port>     TCP listening port for raw input  (default: %u).\n"
        "    --net-ro-port <port>     TCP listening port for raw output (default: %u).\n"
        "    --net-sbs-port <port>    TCP listening port for SBS output (default: %u).\n"
        "    --host-raw <addr:port>   Remote host/port for raw input with `--net-active`.\n"
        "    --host-sbs <addr:port>   Remote host/port for SBS input with `--net-active`.\n"
        "    --web-page <file>        The Web-page to serve for HTTP clients\n"
        "                             (default: \"%s\\%s\").\n\n",
        MODES_NET_PORT_HTTP, MODES_NET_PORT_RAW_IN, MODES_NET_PORT_RAW_OUT,
        MODES_NET_PORT_SBS, Modes.web_root, Modes.web_page);

    printf("  RTLSDR / SDRplay options:\n"
        "    --agc                    Enable Digital AGC              (default: off)\n"
        "    --bias                   Enable Bias-T output            (default: off)\n"
        "    --calibrate              Enable calibrating R820 devices (default: off)\n"
        "    --device <N / name>      Select device                   (default: 0).\n"
        "    --freq <Hz>              Set frequency                   (default: %.0f MHz).\n"
        "    --gain <dB>              Set gain                        (default: AUTO).\n"
        "    --if-mode <ZIF | LIF>    Intermediate Frequency mode     (default: ZIF).\n"
        "    --ppm <correction>       Set frequency correction        (default: 0).\n"
        "    --samplerate <Hz>        Set sample-rate                 (default: %.0f MS/s).\n\n",
        MODES_DEFAULT_FREQ / 1E6, MODES_DEFAULT_RATE / 1E6);

    printf("  --debug <flags>: E = Log frames decoded with errors.\n"
        "                   D = Log frames decoded with 0 errors.\n"
        "                   c = Log frames with bad CRC.\n"
        "                   C = Log frames with good CRC.\n"
        "                   p = Log frames with bad preamble.\n"
        "                   n = Log network debugging information.\n"
        "                   N = A bit more network information than flag 'n'.\n"
        "                   j = Log frames to frames.js, loadable by `debug.html'.\n"
        "                   g = Log general debugging info.\n"
        "                   G = A bit more general debug info than flag 'g'.\n\n");

    printf("  Your home-position for distance calculation can be set like:\n"
        "  'c:\\> set DUMP1090_HOMEPOS=51.5285578,-0.2420247' for London.\n");

    modeS_exit();
    exit(1);
}

/**
 * This background function is called continously by `main_data_loop()`.
 * It performs:
 *  *) Removes inactive aircrafts from the list.
 *  *) Polls the network for events blocking less than `MODES_INTERACTIVE_REFRESH_TIME`.
 *  *) Refreshes interactive data 4 times per second (`MODES_INTERACTIVE_REFRESH_TIME`).
 *  *) Refreshes the console-title with some statistics (also 4 times per second).
 */
bool background_tasks(void)
{
    bool     refresh;
    uint64_t now;

    if (Modes.net)
        mg_mgr_poll(&Modes.mgr, MG_NET_POLL_TIME); /* Poll Mongoose for network events */

    if (Modes.exit)
        return true;

    now = MSEC_TIME();

    refresh = (now - Modes.last_update_ms) >= MODES_INTERACTIVE_REFRESH_TIME;
    if (!refresh)
        return false;

    Modes.last_update_ms = now;

    if (Modes.log)
        fflush(Modes.log);

    remove_stale_aircrafts(now);

    /* Refresh screen and console-title when in interactive mode
     */
    if (Modes.interactive)
        interactive_show_data(now);

    if (Modes.rtlsdr.device || Modes.sdrplay.device)
    {
        console_title_stats();
        console_update_gain();
    }
#if 0
    else
        console_raw_SBS_stats();
#endif
    return true;
    }

/**
 * The handler called in for `SIGINT` or `SIGBREAK` . <br>
 * I.e. user presses `^C`.
 */
void sigint_handler(int sig)
{
    int rc;

    if (sig > 0)
        signal(sig, SIG_DFL);   /* reset signal handler - bit extra safety */

    Modes.exit = true;          /* Signal to threads that we are done */
    console_exit();

    if (sig == SIGINT)
        LOG_STDOUT("Caught SIGINT, shutting down ...\n");
    else if (sig == SIGBREAK)
        LOG_STDOUT("Caught SIGBREAK, shutting down ...\n");
    else if (sig == 0)
        TRACE(DEBUG_GENERAL, "Breaking 'main_data_loop()', shutting down ...\n");

    if (Modes.rtlsdr.device)
    {
        EnterCriticalSection(&Modes.data_mutex);
        rc = rtlsdr_cancel_async(Modes.rtlsdr.device);
        TRACE(DEBUG_GENERAL, "rtlsdr_cancel_async(): rc: %d.\n", rc);

        if (rc == -2)  /* RTLSDR is not streaming data */
            Sleep(5);
        LeaveCriticalSection(&Modes.data_mutex);
    }
    else if (Modes.sdrplay.device)
    {
#if !defined(USE_RTLSDR_EMUL)
        rc = sdrplay_cancel_async(Modes.sdrplay.device);
        TRACE(DEBUG_GENERAL, "sdrplay_cancel_async(): rc: %d / %s.\n", rc, sdrplay_strerror(rc));
#endif
    }
}

void show_connection_stats(void)
{
    const char* cli_srv = (Modes.net_active ? "server" : "client");
    uint64_t    sum;
    int         s;

    LOG_STDOUT("\nNetwork statistics:\n");

    for (s = MODES_NET_SERVICE_RAW_OUT; s < MODES_NET_SERVICES_NUM; s++)
    {
        LOG_STDOUT("  %s (port %u):\n", handler_descr(s), handler_port(s));

        if (s == MODES_NET_SERVICE_HTTP)
        {
            if (Modes.net_active)
            {
                LOG_STDOUT("    Not used.\n");
                continue;
            }
            LOG_STDOUT("    %8llu HTTP GET requests received.\n", Modes.stat.HTTP_get_requests);
            LOG_STDOUT("    %8llu HTTP 404 replies sent.\n", Modes.stat.HTTP_404_responses);
            LOG_STDOUT("    %8llu HTTP/WebSocket upgrades.\n", Modes.stat.HTTP_websockets);
            LOG_STDOUT("    %8llu server connection \"keep-alive\".\n", Modes.stat.HTTP_keep_alive_sent);
            LOG_STDOUT("    %8llu client connection \"keep-alive\".\n", Modes.stat.HTTP_keep_alive_recv);
        }

        if (Modes.net_active)
            sum = Modes.stat.srv_connected[s] + Modes.stat.srv_removed[s] + Modes.stat.srv_unknown[s];
        else sum = Modes.stat.cli_accepted[s] + Modes.stat.cli_removed[s] + Modes.stat.cli_unknown[s];

        sum += Modes.stat.bytes_sent[s] + Modes.stat.bytes_recv[s] + *handler_num_connections(s);

        if (sum == 0ULL)
        {
            LOG_STDOUT("    Nothing.\n");
            continue;
        }

        if (Modes.net_active)
        {
            LOG_STDOUT("    %8llu server connections done.\n", Modes.stat.srv_connected[s]);
            LOG_STDOUT("    %8llu server connections removed.\n", Modes.stat.srv_removed[s]);
            LOG_STDOUT("    %8llu server connections unknown.\n", Modes.stat.srv_unknown[s]);
        }
        else
        {
            LOG_STDOUT("    %8llu client connections accepted.\n", Modes.stat.cli_accepted[s]);
            LOG_STDOUT("    %8llu client connections removed.\n", Modes.stat.cli_removed[s]);
            LOG_STDOUT("    %8llu client connections unknown.\n", Modes.stat.cli_unknown[s]);
        }

        LOG_STDOUT("    %8llu bytes sent.\n", Modes.stat.bytes_sent[s]);
        LOG_STDOUT("    %8llu bytes recv.\n", Modes.stat.bytes_recv[s]);
        LOG_STDOUT("    %8u %s now.\n", *handler_num_connections(s), cli_srv);
    }
}

void show_raw_SBS_stats(void)
{
    LOG_STDOUT("  SBS-in:  %8llu good messages.\n", Modes.stat.good_SBS);
    LOG_STDOUT("           %8llu unrecognized messages.\n", Modes.stat.unrecognized_SBS);
    LOG_STDOUT("           %8llu empty messages.\n", Modes.stat.empty_SBS);
    LOG_STDOUT("  Raw-in:  %8llu good messages.\n", Modes.stat.good_raw);
    LOG_STDOUT("           %8llu unrecognized messages.\n", Modes.stat.unrecognized_raw);
    LOG_STDOUT("           %8llu empty messages.\n", Modes.stat.empty_raw);
    LOG_STDOUT("  Unknown: %8llu empty messages.\n", Modes.stat.empty_unknown);
}

void show_statistics(void)
{
    if (!Modes.net_only)
    {
        LOG_STDOUT("Decoder statistics:\n");
        LOG_STDOUT(" %8llu valid preambles.\n", Modes.stat.valid_preamble);
        LOG_STDOUT(" %8llu demodulated after phase correction.\n", Modes.stat.out_of_phase);
        LOG_STDOUT(" %8llu demodulated with 0 errors.\n", Modes.stat.demodulated);
        LOG_STDOUT(" %8llu with CRC okay.\n", Modes.stat.good_CRC);
        LOG_STDOUT(" %8llu with CRC failure.\n", Modes.stat.bad_CRC);
        LOG_STDOUT(" %8llu errors corrected.\n", Modes.stat.fixed);
        LOG_STDOUT(" %8llu messages with 1 bit errors fixed.\n", Modes.stat.single_bit_fix);
        LOG_STDOUT(" %8llu messages with 2 bit errors fixed.\n", Modes.stat.two_bits_fix);
        LOG_STDOUT(" %8llu total usable messages (%llu + %llu).\n", Modes.stat.good_CRC + Modes.stat.fixed, Modes.stat.good_CRC, Modes.stat.fixed);
        LOG_STDOUT(" %8llu unique aircrafts.\n", Modes.stat.unique_aircrafts);
        LOG_STDOUT(" %8llu unique aircrafts from CSV.\n", Modes.stat.unique_aircrafts_CSV);
        LOG_STDOUT(" %8llu unrecognized ME types.\n", Modes.stat.unrecognized_ME);
    }
    if (Modes.net)
        show_connection_stats();
    if (Modes.net_active)
        show_raw_SBS_stats();
}

/**
 * Our exit function. Free all resources here.
 */
void modeS_exit(void)
{
    int rc;

    if (Modes.net)
    {
        unsigned num = connection_free_all();

        net_flushall();
        mg_mgr_free(&Modes.mgr);
        Modes.mgr.conns = NULL;
        if (num > 0)
            Sleep(100);
    }

    if (Modes.rtlsdr.device)
    {
        if (Modes.bias_tee)
            verbose_bias_tee(Modes.rtlsdr.device, 0);
        Modes.bias_tee = 0;
        rc = rtlsdr_close(Modes.rtlsdr.device);
        free(Modes.rtlsdr.gains);
        Modes.rtlsdr.device = NULL;
        TRACE(DEBUG_GENERAL2, "rtlsdr_close(), rc: %d.\n", rc);
    }
    else if (Modes.sdrplay.device)
    {
        rc = sdrplay_exit(Modes.sdrplay.device);
        free(Modes.sdrplay.gains);
        Modes.sdrplay.device = NULL;
        TRACE(DEBUG_GENERAL2, "sdrplay_exit(), rc: %d.\n", rc);
    }

    if (Modes.reader_thread)
        CloseHandle((HANDLE)Modes.reader_thread);

    if (Modes.fd > STDIN_FILENO)
        _close(Modes.fd);

    free_all_aircrafts();

    /*free (Modes.magnitude_lut);
    free (Modes.magnitude);*/
    free(Modes.data);
    free(Modes.ICAO_cache);
    free(Modes.aircraft_list);
    free(Modes.selected_dev);

    DeleteCriticalSection(&Modes.magnitude_mutex);
    DeleteCriticalSection(&Modes.data_mutex);
    DeleteCriticalSection(&Modes.print_mutex);

    Modes.reader_thread = 0;
    //Modes.data          = NULL;
    /*Modes.magnitude     = NULL;
    Modes.magnitude_lut = NULL;*/
    Modes.ICAO_cache = NULL;
    Modes.selected_dev = NULL;

    if (Modes.log)
        fclose(Modes.log);

#if defined(USE_RTLSDR_EMUL)
    RTLSDR_emul_unload_DLL();
#endif

#if defined(_DEBUG)
    crtdbug_exit();
#endif
}

static void select_device(char* arg)
{
    if (isdigit(arg[0]))
        Modes.rtlsdr.index = atoi(arg);
    else
    {
        Modes.rtlsdr.name = arg;
        Modes.rtlsdr.index = -1;  /* select on name only */
    }

    if (!_strnicmp(arg, "sdrplay", 7))
    {
        Modes.sdrplay.name = arg;
        if (isdigit(arg[+7]))
            Modes.sdrplay.index = atoi(arg + 7);
    }
}

static void select_debug(const char* flags)
{
    while (*flags)
    {
        switch (*flags)
        {
        case 'D':
            Modes.debug |= DEBUG_DEMOD;
            break;
        case 'E':
            Modes.debug |= DEBUG_DEMODERR;
            break;
        case 'C':
            Modes.debug |= DEBUG_GOODCRC;
            break;
        case 'c':
            Modes.debug |= DEBUG_BADCRC;
            break;
        case 'p':
        case 'P':
            Modes.debug |= DEBUG_NOPREAMBLE;
            break;
        case 'n':
            Modes.debug |= DEBUG_NET;
            break;
        case 'N':
            Modes.debug |= (DEBUG_NET2 | DEBUG_NET);  /* A bit more network details */
            break;
        case 'j':
        case 'J':
            Modes.debug |= DEBUG_JS;
            break;
        case 'g':
            Modes.debug |= DEBUG_GENERAL;
            break;
        case 'G':
            Modes.debug |= (DEBUG_GENERAL2 | DEBUG_GENERAL);
            break;
        default:
            show_help("Unknown debugging flag: %c\n", *flags);
            /* not reached */
            break;
        }
        flags++;
    }
}

static bool select_if_mode(const char* arg)
{
    if (!_stricmp(arg, "zif"))
    {
        Modes.sdrplay.if_mode = false;
        return (true);
    }
    if (!_stricmp(arg, "lif"))
    {
        Modes.sdrplay.if_mode = true;
        return (true);
    }
    return (false);
}

static struct option long_options[] = {
  { "agc",              no_argument,        (int*)&Modes.dig_agc,          1   },
  { "aggressive",       no_argument,        (int*)&Modes.aggressive,       1   },
  { "database",         required_argument,  NULL,                          'b' },
  { "bias",             no_argument,        (int*)&Modes.bias_tee,         1   },
  { "calibrate",        no_argument,        (int*)&Modes.rtlsdr.calibrate, 1   },
  { "debug",            required_argument,  NULL,                          'd' },
  { "device",           required_argument,  NULL,                          'D' },
  { "freq",             required_argument,  NULL,                          'f' },
  { "gain",             required_argument,  NULL,                          'g' },
  { "help",             no_argument,        NULL,                          'h' },
  { "if-mode",          required_argument,  NULL,                          'I' },
  { "infile",           required_argument,  NULL,                          'i' },
  { "interactive",      no_argument,        (int*)&Modes.interactive,      1   },
  { "interactive-rows", required_argument,  NULL,                          'r' },
  { "interactive-ttl",  required_argument,  NULL,                          't' },
  { "logfile",          required_argument,  NULL,                          'L' },
  { "loop",             optional_argument,  NULL,                          'l' },
  { "max-messages",     required_argument,  NULL,                          'm' },
  { "metric",           no_argument,        (int*)&Modes.metric,           1   },
  { "net",              no_argument,        (int*)&Modes.net,              1   },
  { "net-active",       no_argument,        (int*)&Modes.net_active,       1   },
  { "net-only",         no_argument,        (int*)&Modes.net_only,         1   },
  { "net-http-port",    required_argument,  NULL,                          'x' + MODES_NET_SERVICE_HTTP },
  { "net-ri-port",      required_argument,  NULL,                          'x' + MODES_NET_SERVICE_RAW_IN },
  { "net-ro-port",      required_argument,  NULL,                          'x' + MODES_NET_SERVICE_RAW_OUT },
  { "net-sbs-port",     required_argument,  NULL,                          'x' + MODES_NET_SERVICE_SBS_OUT },
  { "host-raw",         required_argument,  NULL,                          'Y' + MODES_NET_SERVICE_RAW_IN },
  { "host-sbs",         required_argument,  NULL,                          'Y' + MODES_NET_SERVICE_SBS_IN },
  { "only-addr",        no_argument,        (int*)&Modes.only_addr,        1   },
  { "ppm",              required_argument,  NULL,                          'p' },
  { "raw",              no_argument,        (int*)&Modes.raw,              1   },
  { "samplerate",       required_argument,  NULL,                          's' },
  { "silent",           no_argument,        (int*)&Modes.silent,           1   },
  { "strip",            required_argument,  NULL,                          'S' },
  { "web-page",         required_argument,  NULL,                          'w' },
  { NULL,               no_argument,        NULL,                          0   }
};

#ifdef NOT_YET
/**
 * The handler for long options called from `getopt_long()`.
 *
 * \param[in] o    the index into `long_options[]`.
 * \param[in] arg  the optional argument for the option.
 */
static void set_long_option(int idx, const char* arg)
{
}
#endif

void parse_cmd_line(int argc, char** argv)
{
    char* end;
    int   c, idx = 0;

    while ((c = getopt_long(argc, argv, "+h?", long_options, &idx)) != EOF)
    {
        // printf ("c: '%c' / %d, long_options[%d]: '%s'\n", c, c, idx, long_options[idx].name);

        switch (c)
        {
#ifdef NOT_YET
        case 0:
            set_long_option(idx, optarg);
            break;
#else
        case 'b':
            strncpy(Modes.aircraft_db, optarg, sizeof(Modes.aircraft_db) - 1);
            break;

        case 'D':
            if (dev_selection_done)
                show_help("Option '--device' already done.\n\n");
            select_device(optarg);
            dev_selection_done = true;
            break;

        case 'd':
            select_debug(optarg);
            break;

        case 'f':
            Modes.freq = (uint32_t)ato_hertz(optarg);
            break;

        case 'g':
            if (!_stricmp(optarg, "auto"))
                Modes.gain_auto = true;
            else
            {
                Modes.gain = (int)(10.0 * strtof(optarg, &end));  /* Gain is in tens of dBs */
                if (end == optarg || *end != '\0')
                    show_help("Illegal gain: %s.\n", optarg);
                Modes.gain_auto = false;
            }
            break;

        case 'I':
            if (!select_if_mode(optarg))
                show_help("Illegal '--if-mode': %s.\n", optarg);
            break;

        case 'i':
            Modes.infile = optarg;
            break;

        case 'l':
            Modes.loops = optarg ? _atoi64(optarg) : LLONG_MAX;
            break;

        case 'L':
            Modes.logfile = optarg;
            break;

        case 'm':
            Modes.max_messages = _atoi64(optarg);
            break;

        case 'n':
            Modes.net_only = Modes.net = true;
            break;

        case 'N':
            Modes.net_active = Modes.net = true;
            break;

        case 'x' + MODES_NET_SERVICE_RAW_OUT:
            modeS_net_services[MODES_NET_SERVICE_RAW_OUT].port = atoi(optarg);
            break;

        case 'x' + MODES_NET_SERVICE_RAW_IN:
            modeS_net_services[MODES_NET_SERVICE_RAW_IN].port = atoi(optarg);
            break;

        case 'x' + MODES_NET_SERVICE_HTTP:
            modeS_net_services[MODES_NET_SERVICE_HTTP].port = atoi(optarg);
            break;

        case 'x' + MODES_NET_SERVICE_SBS_OUT:
            modeS_net_services[MODES_NET_SERVICE_SBS_OUT].port = atoi(optarg);
            break;

        case 'Y' + MODES_NET_SERVICE_RAW_OUT:
            modeS_net_services[MODES_NET_SERVICE_RAW_OUT].host = optarg;
            break;

        case 'Y' + MODES_NET_SERVICE_RAW_IN:
            set_host_port(optarg, &modeS_net_services[MODES_NET_SERVICE_RAW_IN], MODES_NET_PORT_RAW_IN);
            break;

        case 'Y' + MODES_NET_SERVICE_SBS_IN:
            set_host_port(optarg, &modeS_net_services[MODES_NET_SERVICE_SBS_IN], MODES_NET_PORT_SBS);
            break;

        case 'p':
            Modes.rtlsdr.ppm_error = atoi(optarg);
            break;

        case 'r':
            Modes.interactive_rows = atoi(optarg);
            break;

        case 's':
            Modes.sample_rate = (uint32_t)ato_hertz(optarg);
            break;

        case 'S':
            Modes.strip_level = atoi(optarg);
            if (Modes.strip_level == 0)
                show_help("Illegal --strip level %d.\n\n", Modes.strip_level);
            break;

        case 't':
            Modes.interactive_ttl = 1000 * atoi(optarg);
            break;

        case 'w':
            strncpy(Modes.web_root, dirname(optarg), sizeof(Modes.web_root) - 1);
            strncpy(Modes.web_page, basename(optarg), sizeof(Modes.web_page) - 1);
            break;
#endif

        case 'h':
        case '?':
            show_help(NULL);
            break;
    }
}
    if (Modes.net_only || Modes.net_active)
        Modes.net = Modes.net_only = true;
}

/**
 * Our main entry.
 */
int main(int argc, char** argv)
{
    //printf("%d", offsetof(iq_value, i));
    //printf("%d", offsetof(iq_value, q));
    //printf("%d", offsetof(iq_value_unpacked, i));
    //printf("%d", offsetof(iq_value_unpacked, q));
    int dev_opened = 0;
    int rc;

#if defined(_DEBUG)
    crtdbug_init();
#endif

    modeS_init_config();  /* Set sane defaults */

    parse_cmd_line(argc, argv);

    rc = modeS_init();    /* Initialization based on cmd-line options */
    if (rc)
        goto quit;

    if (Modes.net_only)
    {
        LOG_STDERR("Net-only mode, no physical device or file open.\n");
    }
    else if (Modes.strip_level)
    {
        rc = strip_mode(Modes.strip_level);
    }
    else if (Modes.infile)
    {
        rc = 1;
        if (Modes.infile[0] == '-' && Modes.infile[1] == '\0')
        {
            Modes.fd = STDIN_FILENO;
        }
        else if ((Modes.fd = _open(Modes.infile, O_RDONLY)) == -1)
        {
            LOG_STDERR("Error opening `%s`: %s\n", Modes.infile, strerror(errno));
            goto quit;
        }
    }
    else
    {
        if (Modes.sdrplay.name)
        {
#ifdef USE_RTLSDR_EMUL
            Modes.emul_loaded = RTLSDR_emul_load_DLL();
            if (!Modes.emul_loaded)
            {
                LOG_STDERR("Cannot use device `%s` without `%s` loaded. Error: %s\n",
                    Modes.sdrplay.name, emul.dll_name, trace_strerror(emul.last_rc));
                goto quit;
    }
#endif

            rc = sdrplay_init(Modes.sdrplay.name, &Modes.sdrplay.device);
            TRACE(DEBUG_GENERAL, "sdrplay_init(): rc: %d / %s.\n", rc, sdrplay_strerror(rc));
            if (rc)
                goto quit;
}
        else
        {
            rc = modeS_init_RTLSDR();
            TRACE(DEBUG_GENERAL, "modeS_init_RTLSDR(): rc: %d.\n", rc);
            if (rc)
                goto quit;
            dev_opened = 1;
        }
  }

    if (Modes.net)
    {
        rc = modeS_init_net();
        TRACE(DEBUG_GENERAL, "modeS_init_net(): rc: %d.\n", rc);
        if (rc)
            goto quit;
    }

    if (Modes.infile)
    {
        rc = read_from_data_file();
    }
    else if (Modes.strip_level == 0)
    {
        /* Create the thread that will read the data from the RTLSDR or SDRplay device.
         */
        Modes.reader_thread = _beginthreadex(NULL, 0, data_thread_fn, NULL, 0, NULL);
        if (!Modes.reader_thread)
        {
            rc = 1;
            LOG_STDERR("_beginthreadex() failed: %s.\n", strerror(errno));
            goto quit;
        }
        main_data_loop();
    }

quit:
    if (print_server_errors() == 0 && dev_opened)
        show_statistics();
    modeS_exit();
    return (0);
}
